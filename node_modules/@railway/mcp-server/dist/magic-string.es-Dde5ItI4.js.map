{"version":3,"file":"magic-string.es-Dde5ItI4.js","names":["n","segment","replacement"],"sources":["../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs","../node_modules/.pnpm/magic-string@0.30.19/node_modules/magic-string/dist/magic-string.es.mjs"],"sourcesContent":["// src/vlq.ts\nvar comma = \",\".charCodeAt(0);\nvar semicolon = \";\".charCodeAt(0);\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar intToChar = new Uint8Array(64);\nvar charToInt = new Uint8Array(128);\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -2147483648 | -value;\n  }\n  return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n  let delta = num - relative;\n  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;\n  do {\n    let clamped = delta & 31;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 32;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n  return num;\n}\nfunction hasMoreVlq(reader, max) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n\n// src/strings.ts\nvar bufLength = 1024 * 16;\nvar td = typeof TextDecoder !== \"undefined\" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = \"\";\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nvar StringWriter = class {\n  constructor() {\n    this.pos = 0;\n    this.out = \"\";\n    this.buffer = new Uint8Array(bufLength);\n  }\n  write(v) {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n  flush() {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n};\nvar StringReader = class {\n  constructor(buffer) {\n    this.pos = 0;\n    this.buffer = buffer;\n  }\n  next() {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.pos);\n  }\n  indexOf(char) {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n};\n\n// src/scopes.ts\nvar EMPTY = [];\nfunction decodeOriginalScopes(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes = [];\n  const stack = [];\n  let line = 0;\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop();\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 1;\n    const scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];\n    let vars = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n    scopes.push(scope);\n    stack.push(scope);\n  }\n  return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n  const writer = new StringWriter();\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n  return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n  if (index > 0) writer.write(comma);\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n  const fields = scope.length === 6 ? 1 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n  return index;\n}\nfunction decodeGeneratedRanges(input) {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges = [];\n  const stack = [];\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    let genColumn = 0;\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop();\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 1;\n      const hasCallsite = fields & 2;\n      const hasScope = fields & 4;\n      let callsite = null;\n      let bindings = EMPTY;\n      let range;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0\n        );\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n      } else {\n        range = [genLine, genColumn, 0, 0];\n      }\n      range.isScope = !!hasScope;\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0\n        );\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges;\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n      ranges.push(range);\n      stack.push(range);\n    }\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n  return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n  if (ranges.length === 0) return \"\";\n  const writer = new StringWriter();\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n  return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings\n  } = range;\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, range[1], state[1]);\n  const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);\n  encodeInteger(writer, fields, 0);\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n        encodeInteger(writer, expRange[0], 0);\n      }\n    }\n  }\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || l === endLine && c >= endColumn) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n  return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n\n// src/sourcemap-codec.ts\nfunction decode(mappings) {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  do {\n    const semi = reader.indexOf(\";\");\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n    while (reader.pos < semi) {\n      let seg;\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n      line.push(seg);\n      reader.pos++;\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n  return decoded;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n    let genColumn = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n  return writer.flush();\n}\nexport {\n  decode,\n  decodeGeneratedRanges,\n  decodeOriginalScopes,\n  encode,\n  encodeGeneratedRanges,\n  encodeOriginalScopes\n};\n//# sourceMappingURL=sourcemap-codec.mjs.map\n","import { encode } from '@jridgewell/sourcemap-codec';\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nconst wordRegex = /\\w/;\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\tif (this.outro) {\n\t\t\tmappings.advance(this.outro);\n\t\t}\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tlet previousChunk = chunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n\t\t\t// Prevent infinite loop (e.g. via empty chunks, where start === end)\n\t\t\tif (chunk === previousChunk) return;\n\n\t\t\tpreviousChunk = chunk;\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\treplacement = replacement(string, index, original);\n\t\t\t}\n\t\t\tif (string !== replacement) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tlet _replacement = replacement;\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\t_replacement = replacement(previous, index, original);\n\t\t\t}\n\t\t\tif (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nexport { Bundle, SourceMap, MagicString as default };\n//# sourceMappingURL=magic-string.es.mjs.map\n"],"x_google_ignoreList":[0,1],"mappings":"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"}