import { __commonJS, __toESM } from "./chunk-DbKvDyjX.js";
import { isatty } from "tty";

//#region node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
var f$2 = {
	reset: [0, 0],
	bold: [
		1,
		22,
		"\x1B[22m\x1B[1m"
	],
	dim: [
		2,
		22,
		"\x1B[22m\x1B[2m"
	],
	italic: [3, 23],
	underline: [4, 24],
	inverse: [7, 27],
	hidden: [8, 28],
	strikethrough: [9, 29],
	black: [30, 39],
	red: [31, 39],
	green: [32, 39],
	yellow: [33, 39],
	blue: [34, 39],
	magenta: [35, 39],
	cyan: [36, 39],
	white: [37, 39],
	gray: [90, 39],
	bgBlack: [40, 49],
	bgRed: [41, 49],
	bgGreen: [42, 49],
	bgYellow: [43, 49],
	bgBlue: [44, 49],
	bgMagenta: [45, 49],
	bgCyan: [46, 49],
	bgWhite: [47, 49],
	blackBright: [90, 39],
	redBright: [91, 39],
	greenBright: [92, 39],
	yellowBright: [93, 39],
	blueBright: [94, 39],
	magentaBright: [95, 39],
	cyanBright: [96, 39],
	whiteBright: [97, 39],
	bgBlackBright: [100, 49],
	bgRedBright: [101, 49],
	bgGreenBright: [102, 49],
	bgYellowBright: [103, 49],
	bgBlueBright: [104, 49],
	bgMagentaBright: [105, 49],
	bgCyanBright: [106, 49],
	bgWhiteBright: [107, 49]
}, h$2 = Object.entries(f$2);
function a$1(n) {
	return String(n);
}
a$1.open = "";
a$1.close = "";
function C$1(n = !1) {
	let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
	return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p$1(n = !1) {
	let e = C$1(n), i = (r$1, t, c, o) => {
		let l$1 = "", s = 0;
		do
			l$1 += r$1.substring(s, o) + c, s = o + t.length, o = r$1.indexOf(t, s);
		while (~o);
		return l$1 + r$1.substring(s);
	}, g = (r$1, t, c = r$1) => {
		let o = (l$1) => {
			let s = String(l$1), b$1 = s.indexOf(t, r$1.length);
			return ~b$1 ? r$1 + i(s, t, c, b$1) + t : r$1 + s + t;
		};
		return o.open = r$1, o.close = t, o;
	}, u$2 = { isColorSupported: e }, d = (r$1) => `\x1B[${r$1}m`;
	for (let [r$1, t] of h$2) u$2[r$1] = e ? g(d(t[0]), d(t[1]), t[2]) : a$1;
	return u$2;
}

//#endregion
//#region node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
var r = process.env.FORCE_TTY !== void 0 || isatty(1);
var u = p$1(r);

//#endregion
//#region node_modules/.pnpm/@vitest+pretty-format@3.2.4/node_modules/@vitest/pretty-format/dist/index.js
function _mergeNamespaces(n, m$1) {
	m$1.forEach(function(e) {
		e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k$1) {
			if (k$1 !== "default" && !(k$1 in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k$1);
				Object.defineProperty(n, k$1, d.get ? d : {
					enumerable: true,
					get: function() {
						return e[k$1];
					}
				});
			}
		});
	});
	return Object.freeze(n);
}
function getKeysOfEnumerableProperties(object$1, compareKeys) {
	const rawKeys = Object.keys(object$1);
	const keys$1 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
	if (Object.getOwnPropertySymbols) {
		for (const symbol of Object.getOwnPropertySymbols(object$1)) if (Object.getOwnPropertyDescriptor(object$1, symbol).enumerable) keys$1.push(symbol);
	}
	return keys$1;
}
/**
* Return entries (for example, of a map)
* with spacing, indentation, and comma
* without surrounding punctuation (for example, braces)
*/
function printIteratorEntries(iterator, config$1, indentation, depth, refs, printer$1, separator = ": ") {
	let result = "";
	let width = 0;
	let current = iterator.next();
	if (!current.done) {
		result += config$1.spacingOuter;
		const indentationNext = indentation + config$1.indent;
		while (!current.done) {
			result += indentationNext;
			if (width++ === config$1.maxWidth) {
				result += "…";
				break;
			}
			const name = printer$1(current.value[0], config$1, indentationNext, depth, refs);
			const value = printer$1(current.value[1], config$1, indentationNext, depth, refs);
			result += name + separator + value;
			current = iterator.next();
			if (!current.done) result += `,${config$1.spacingInner}`;
			else if (!config$1.min) result += ",";
		}
		result += config$1.spacingOuter + indentation;
	}
	return result;
}
/**
* Return values (for example, of a set)
* with spacing, indentation, and comma
* without surrounding punctuation (braces or brackets)
*/
function printIteratorValues(iterator, config$1, indentation, depth, refs, printer$1) {
	let result = "";
	let width = 0;
	let current = iterator.next();
	if (!current.done) {
		result += config$1.spacingOuter;
		const indentationNext = indentation + config$1.indent;
		while (!current.done) {
			result += indentationNext;
			if (width++ === config$1.maxWidth) {
				result += "…";
				break;
			}
			result += printer$1(current.value, config$1, indentationNext, depth, refs);
			current = iterator.next();
			if (!current.done) result += `,${config$1.spacingInner}`;
			else if (!config$1.min) result += ",";
		}
		result += config$1.spacingOuter + indentation;
	}
	return result;
}
/**
* Return items (for example, of an array)
* with spacing, indentation, and comma
* without surrounding punctuation (for example, brackets)
*/
function printListItems(list, config$1, indentation, depth, refs, printer$1) {
	let result = "";
	list = list instanceof ArrayBuffer ? new DataView(list) : list;
	const isDataView = (l$1) => l$1 instanceof DataView;
	const length = isDataView(list) ? list.byteLength : list.length;
	if (length > 0) {
		result += config$1.spacingOuter;
		const indentationNext = indentation + config$1.indent;
		for (let i = 0; i < length; i++) {
			result += indentationNext;
			if (i === config$1.maxWidth) {
				result += "…";
				break;
			}
			if (isDataView(list) || i in list) result += printer$1(isDataView(list) ? list.getInt8(i) : list[i], config$1, indentationNext, depth, refs);
			if (i < length - 1) result += `,${config$1.spacingInner}`;
			else if (!config$1.min) result += ",";
		}
		result += config$1.spacingOuter + indentation;
	}
	return result;
}
/**
* Return properties of an object
* with spacing, indentation, and comma
* without surrounding punctuation (for example, braces)
*/
function printObjectProperties(val, config$1, indentation, depth, refs, printer$1) {
	let result = "";
	const keys$1 = getKeysOfEnumerableProperties(val, config$1.compareKeys);
	if (keys$1.length > 0) {
		result += config$1.spacingOuter;
		const indentationNext = indentation + config$1.indent;
		for (let i = 0; i < keys$1.length; i++) {
			const key = keys$1[i];
			const name = printer$1(key, config$1, indentationNext, depth, refs);
			const value = printer$1(val[key], config$1, indentationNext, depth, refs);
			result += `${indentationNext + name}: ${value}`;
			if (i < keys$1.length - 1) result += `,${config$1.spacingInner}`;
			else if (!config$1.min) result += ",";
		}
		result += config$1.spacingOuter + indentation;
	}
	return result;
}
const asymmetricMatcher = typeof Symbol === "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
const SPACE$2 = " ";
const serialize$5 = (val, config$1, indentation, depth, refs, printer$1) => {
	const stringedValue = val.toString();
	if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
		if (++depth > config$1.maxDepth) return `[${stringedValue}]`;
		return `${stringedValue + SPACE$2}[${printListItems(val.sample, config$1, indentation, depth, refs, printer$1)}]`;
	}
	if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
		if (++depth > config$1.maxDepth) return `[${stringedValue}]`;
		return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config$1, indentation, depth, refs, printer$1)}}`;
	}
	if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") return stringedValue + SPACE$2 + printer$1(val.sample, config$1, indentation, depth, refs);
	if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") return stringedValue + SPACE$2 + printer$1(val.sample, config$1, indentation, depth, refs);
	if (typeof val.toAsymmetricMatcher !== "function") throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
	return val.toAsymmetricMatcher();
};
const test$5 = (val) => val && val.$$typeof === asymmetricMatcher;
const plugin$5 = {
	serialize: serialize$5,
	test: test$5
};
const SPACE$1 = " ";
const OBJECT_NAMES = new Set(["DOMStringMap", "NamedNodeMap"]);
const ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
	return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
const test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
function isNamedNodeMap(collection) {
	return collection.constructor.name === "NamedNodeMap";
}
const serialize$4 = (collection, config$1, indentation, depth, refs, printer$1) => {
	const name = collection.constructor.name;
	if (++depth > config$1.maxDepth) return `[${name}]`;
	return (config$1.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => {
		props[attribute.name] = attribute.value;
		return props;
	}, {}) : { ...collection }, config$1, indentation, depth, refs, printer$1)}}` : `[${printListItems([...collection], config$1, indentation, depth, refs, printer$1)}]`);
};
const plugin$4 = {
	serialize: serialize$4,
	test: test$4
};
/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
function escapeHTML(str) {
	return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys$1, props, config$1, indentation, depth, refs, printer$1) {
	const indentationNext = indentation + config$1.indent;
	const colors = config$1.colors;
	return keys$1.map((key) => {
		const value = props[key];
		let printed = printer$1(value, config$1, indentationNext, depth, refs);
		if (typeof value !== "string") {
			if (printed.includes("\n")) printed = config$1.spacingOuter + indentationNext + printed + config$1.spacingOuter + indentation;
			printed = `{${printed}}`;
		}
		return `${config$1.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
	}).join("");
}
function printChildren(children, config$1, indentation, depth, refs, printer$1) {
	return children.map((child) => config$1.spacingOuter + indentation + (typeof child === "string" ? printText(child, config$1) : printer$1(child, config$1, indentation, depth, refs))).join("");
}
function printText(text, config$1) {
	const contentColor = config$1.colors.content;
	return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config$1) {
	const commentColor = config$1.colors.comment;
	return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type$1, printedProps, printedChildren, config$1, indentation) {
	const tagColor = config$1.colors.tag;
	return `${tagColor.open}<${type$1}${printedProps && tagColor.close + printedProps + config$1.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config$1.spacingOuter}${indentation}${tagColor.open}</${type$1}` : `${printedProps && !config$1.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type$1, config$1) {
	const tagColor = config$1.colors.tag;
	return `${tagColor.open}<${type$1}${tagColor.close} …${tagColor.open} />${tagColor.close}`;
}
const ELEMENT_NODE = 1;
const TEXT_NODE = 3;
const COMMENT_NODE = 8;
const FRAGMENT_NODE = 11;
const ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
	try {
		return typeof val.hasAttribute === "function" && val.hasAttribute("is");
	} catch {
		return false;
	}
}
function testNode(val) {
	const constructorName = val.constructor.name;
	const { nodeType, tagName } = val;
	const isCustomElement = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
	return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
const test$3 = (val) => {
	var _val$constructor;
	return (val === null || val === void 0 || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
};
function nodeIsText(node) {
	return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
	return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
	return node.nodeType === FRAGMENT_NODE;
}
const serialize$3 = (node, config$1, indentation, depth, refs, printer$1) => {
	if (nodeIsText(node)) return printText(node.data, config$1);
	if (nodeIsComment(node)) return printComment(node.data, config$1);
	const type$1 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
	if (++depth > config$1.maxDepth) return printElementAsLeaf(type$1, config$1);
	return printElement(type$1, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => {
		props[attribute.name] = attribute.value;
		return props;
	}, {}), config$1, indentation + config$1.indent, depth, refs, printer$1), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config$1, indentation + config$1.indent, depth, refs, printer$1), config$1, indentation);
};
const plugin$3 = {
	serialize: serialize$3,
	test: test$3
};
const IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
const IS_LIST_SENTINEL$1 = "@@__IMMUTABLE_LIST__@@";
const IS_KEYED_SENTINEL$1 = "@@__IMMUTABLE_KEYED__@@";
const IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
const IS_ORDERED_SENTINEL$1 = "@@__IMMUTABLE_ORDERED__@@";
const IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
const IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
const IS_SET_SENTINEL$1 = "@@__IMMUTABLE_SET__@@";
const IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
const getImmutableName = (name) => `Immutable.${name}`;
const printAsLeaf = (name) => `[${name}]`;
const SPACE = " ";
const LAZY = "…";
function printImmutableEntries(val, config$1, indentation, depth, refs, printer$1, type$1) {
	return ++depth > config$1.maxDepth ? printAsLeaf(getImmutableName(type$1)) : `${getImmutableName(type$1) + SPACE}{${printIteratorEntries(val.entries(), config$1, indentation, depth, refs, printer$1)}}`;
}
function getRecordEntries(val) {
	let i = 0;
	return { next() {
		if (i < val._keys.length) {
			const key = val._keys[i++];
			return {
				done: false,
				value: [key, val.get(key)]
			};
		}
		return {
			done: true,
			value: void 0
		};
	} };
}
function printImmutableRecord(val, config$1, indentation, depth, refs, printer$1) {
	const name = getImmutableName(val._name || "Record");
	return ++depth > config$1.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config$1, indentation, depth, refs, printer$1)}}`;
}
function printImmutableSeq(val, config$1, indentation, depth, refs, printer$1) {
	const name = getImmutableName("Seq");
	if (++depth > config$1.maxDepth) return printAsLeaf(name);
	if (val[IS_KEYED_SENTINEL$1]) return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config$1, indentation, depth, refs, printer$1) : LAZY}}`;
	return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config$1, indentation, depth, refs, printer$1) : LAZY}]`;
}
function printImmutableValues(val, config$1, indentation, depth, refs, printer$1, type$1) {
	return ++depth > config$1.maxDepth ? printAsLeaf(getImmutableName(type$1)) : `${getImmutableName(type$1) + SPACE}[${printIteratorValues(val.values(), config$1, indentation, depth, refs, printer$1)}]`;
}
const serialize$2 = (val, config$1, indentation, depth, refs, printer$1) => {
	if (val[IS_MAP_SENTINEL]) return printImmutableEntries(val, config$1, indentation, depth, refs, printer$1, val[IS_ORDERED_SENTINEL$1] ? "OrderedMap" : "Map");
	if (val[IS_LIST_SENTINEL$1]) return printImmutableValues(val, config$1, indentation, depth, refs, printer$1, "List");
	if (val[IS_SET_SENTINEL$1]) return printImmutableValues(val, config$1, indentation, depth, refs, printer$1, val[IS_ORDERED_SENTINEL$1] ? "OrderedSet" : "Set");
	if (val[IS_STACK_SENTINEL]) return printImmutableValues(val, config$1, indentation, depth, refs, printer$1, "Stack");
	if (val[IS_SEQ_SENTINEL]) return printImmutableSeq(val, config$1, indentation, depth, refs, printer$1);
	return printImmutableRecord(val, config$1, indentation, depth, refs, printer$1);
};
const test$2$1 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
const plugin$2 = {
	serialize: serialize$2,
	test: test$2$1
};
function getDefaultExportFromCjs$3(x$1) {
	return x$1 && x$1.__esModule && Object.prototype.hasOwnProperty.call(x$1, "default") ? x$1["default"] : x$1;
}
var reactIs$1 = { exports: {} };
var reactIs_production = {};
/**
* @license React
* react-is.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var hasRequiredReactIs_production;
function requireReactIs_production() {
	if (hasRequiredReactIs_production) return reactIs_production;
	hasRequiredReactIs_production = 1;
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
	var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
	function typeOf$1(object$1) {
		if ("object" === typeof object$1 && null !== object$1) {
			var $$typeof = object$1.$$typeof;
			switch ($$typeof) {
				case REACT_ELEMENT_TYPE: switch (object$1 = object$1.type, object$1) {
					case REACT_FRAGMENT_TYPE:
					case REACT_PROFILER_TYPE:
					case REACT_STRICT_MODE_TYPE:
					case REACT_SUSPENSE_TYPE:
					case REACT_SUSPENSE_LIST_TYPE:
					case REACT_VIEW_TRANSITION_TYPE: return object$1;
					default: switch (object$1 = object$1 && object$1.$$typeof, object$1) {
						case REACT_CONTEXT_TYPE:
						case REACT_FORWARD_REF_TYPE:
						case REACT_LAZY_TYPE:
						case REACT_MEMO_TYPE: return object$1;
						case REACT_CONSUMER_TYPE: return object$1;
						default: return $$typeof;
					}
				}
				case REACT_PORTAL_TYPE: return $$typeof;
			}
		}
	}
	reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
	reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
	reactIs_production.Element = REACT_ELEMENT_TYPE;
	reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
	reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
	reactIs_production.Lazy = REACT_LAZY_TYPE;
	reactIs_production.Memo = REACT_MEMO_TYPE;
	reactIs_production.Portal = REACT_PORTAL_TYPE;
	reactIs_production.Profiler = REACT_PROFILER_TYPE;
	reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
	reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
	reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
	reactIs_production.isContextConsumer = function(object$1) {
		return typeOf$1(object$1) === REACT_CONSUMER_TYPE;
	};
	reactIs_production.isContextProvider = function(object$1) {
		return typeOf$1(object$1) === REACT_CONTEXT_TYPE;
	};
	reactIs_production.isElement = function(object$1) {
		return "object" === typeof object$1 && null !== object$1 && object$1.$$typeof === REACT_ELEMENT_TYPE;
	};
	reactIs_production.isForwardRef = function(object$1) {
		return typeOf$1(object$1) === REACT_FORWARD_REF_TYPE;
	};
	reactIs_production.isFragment = function(object$1) {
		return typeOf$1(object$1) === REACT_FRAGMENT_TYPE;
	};
	reactIs_production.isLazy = function(object$1) {
		return typeOf$1(object$1) === REACT_LAZY_TYPE;
	};
	reactIs_production.isMemo = function(object$1) {
		return typeOf$1(object$1) === REACT_MEMO_TYPE;
	};
	reactIs_production.isPortal = function(object$1) {
		return typeOf$1(object$1) === REACT_PORTAL_TYPE;
	};
	reactIs_production.isProfiler = function(object$1) {
		return typeOf$1(object$1) === REACT_PROFILER_TYPE;
	};
	reactIs_production.isStrictMode = function(object$1) {
		return typeOf$1(object$1) === REACT_STRICT_MODE_TYPE;
	};
	reactIs_production.isSuspense = function(object$1) {
		return typeOf$1(object$1) === REACT_SUSPENSE_TYPE;
	};
	reactIs_production.isSuspenseList = function(object$1) {
		return typeOf$1(object$1) === REACT_SUSPENSE_LIST_TYPE;
	};
	reactIs_production.isValidElementType = function(type$1) {
		return "string" === typeof type$1 || "function" === typeof type$1 || type$1 === REACT_FRAGMENT_TYPE || type$1 === REACT_PROFILER_TYPE || type$1 === REACT_STRICT_MODE_TYPE || type$1 === REACT_SUSPENSE_TYPE || type$1 === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type$1 && null !== type$1 && (type$1.$$typeof === REACT_LAZY_TYPE || type$1.$$typeof === REACT_MEMO_TYPE || type$1.$$typeof === REACT_CONTEXT_TYPE || type$1.$$typeof === REACT_CONSUMER_TYPE || type$1.$$typeof === REACT_FORWARD_REF_TYPE || type$1.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type$1.getModuleId) ? true : false;
	};
	reactIs_production.typeOf = typeOf$1;
	return reactIs_production;
}
var reactIs_development$1 = {};
/**
* @license React
* react-is.development.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
	if (hasRequiredReactIs_development$1) return reactIs_development$1;
	hasRequiredReactIs_development$1 = 1;
	"production" !== process.env.NODE_ENV && (function() {
		function typeOf$1(object$1) {
			if ("object" === typeof object$1 && null !== object$1) {
				var $$typeof = object$1.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE: switch (object$1 = object$1.type, object$1) {
						case REACT_FRAGMENT_TYPE:
						case REACT_PROFILER_TYPE:
						case REACT_STRICT_MODE_TYPE:
						case REACT_SUSPENSE_TYPE:
						case REACT_SUSPENSE_LIST_TYPE:
						case REACT_VIEW_TRANSITION_TYPE: return object$1;
						default: switch (object$1 = object$1 && object$1.$$typeof, object$1) {
							case REACT_CONTEXT_TYPE:
							case REACT_FORWARD_REF_TYPE:
							case REACT_LAZY_TYPE:
							case REACT_MEMO_TYPE: return object$1;
							case REACT_CONSUMER_TYPE: return object$1;
							default: return $$typeof;
						}
					}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
		var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE;
		reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE;
		reactIs_development$1.Element = REACT_ELEMENT_TYPE;
		reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE;
		reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE;
		reactIs_development$1.Lazy = REACT_LAZY_TYPE;
		reactIs_development$1.Memo = REACT_MEMO_TYPE;
		reactIs_development$1.Portal = REACT_PORTAL_TYPE;
		reactIs_development$1.Profiler = REACT_PROFILER_TYPE;
		reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE;
		reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE;
		reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		reactIs_development$1.isContextConsumer = function(object$1) {
			return typeOf$1(object$1) === REACT_CONSUMER_TYPE;
		};
		reactIs_development$1.isContextProvider = function(object$1) {
			return typeOf$1(object$1) === REACT_CONTEXT_TYPE;
		};
		reactIs_development$1.isElement = function(object$1) {
			return "object" === typeof object$1 && null !== object$1 && object$1.$$typeof === REACT_ELEMENT_TYPE;
		};
		reactIs_development$1.isForwardRef = function(object$1) {
			return typeOf$1(object$1) === REACT_FORWARD_REF_TYPE;
		};
		reactIs_development$1.isFragment = function(object$1) {
			return typeOf$1(object$1) === REACT_FRAGMENT_TYPE;
		};
		reactIs_development$1.isLazy = function(object$1) {
			return typeOf$1(object$1) === REACT_LAZY_TYPE;
		};
		reactIs_development$1.isMemo = function(object$1) {
			return typeOf$1(object$1) === REACT_MEMO_TYPE;
		};
		reactIs_development$1.isPortal = function(object$1) {
			return typeOf$1(object$1) === REACT_PORTAL_TYPE;
		};
		reactIs_development$1.isProfiler = function(object$1) {
			return typeOf$1(object$1) === REACT_PROFILER_TYPE;
		};
		reactIs_development$1.isStrictMode = function(object$1) {
			return typeOf$1(object$1) === REACT_STRICT_MODE_TYPE;
		};
		reactIs_development$1.isSuspense = function(object$1) {
			return typeOf$1(object$1) === REACT_SUSPENSE_TYPE;
		};
		reactIs_development$1.isSuspenseList = function(object$1) {
			return typeOf$1(object$1) === REACT_SUSPENSE_LIST_TYPE;
		};
		reactIs_development$1.isValidElementType = function(type$1) {
			return "string" === typeof type$1 || "function" === typeof type$1 || type$1 === REACT_FRAGMENT_TYPE || type$1 === REACT_PROFILER_TYPE || type$1 === REACT_STRICT_MODE_TYPE || type$1 === REACT_SUSPENSE_TYPE || type$1 === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type$1 && null !== type$1 && (type$1.$$typeof === REACT_LAZY_TYPE || type$1.$$typeof === REACT_MEMO_TYPE || type$1.$$typeof === REACT_CONTEXT_TYPE || type$1.$$typeof === REACT_CONSUMER_TYPE || type$1.$$typeof === REACT_FORWARD_REF_TYPE || type$1.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type$1.getModuleId) ? true : false;
		};
		reactIs_development$1.typeOf = typeOf$1;
	})();
	return reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
	if (hasRequiredReactIs$1) return reactIs$1.exports;
	hasRequiredReactIs$1 = 1;
	if (process.env.NODE_ENV === "production") reactIs$1.exports = requireReactIs_production();
	else reactIs$1.exports = requireReactIs_development$1();
	return reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1();
var ReactIs19 = /* @__PURE__ */ _mergeNamespaces({
	__proto__: null,
	default: /* @__PURE__ */ getDefaultExportFromCjs$3(reactIsExports$1)
}, [reactIsExports$1]);
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
* @license React
* react-is.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
	var b$1 = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f$3 = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h$3 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u$2 = Symbol.for("react.module.reference");
	function v$1(a$2) {
		if ("object" === typeof a$2 && null !== a$2) {
			var r$1 = a$2.$$typeof;
			switch (r$1) {
				case b$1: switch (a$2 = a$2.type, a$2) {
					case d:
					case f$3:
					case e:
					case m$1:
					case n: return a$2;
					default: switch (a$2 = a$2 && a$2.$$typeof, a$2) {
						case k$1:
						case h$3:
						case l$1:
						case q:
						case p$2:
						case g: return a$2;
						default: return r$1;
					}
				}
				case c: return r$1;
			}
		}
	}
	reactIs_production_min.ContextConsumer = h$3;
	reactIs_production_min.ContextProvider = g;
	reactIs_production_min.Element = b$1;
	reactIs_production_min.ForwardRef = l$1;
	reactIs_production_min.Fragment = d;
	reactIs_production_min.Lazy = q;
	reactIs_production_min.Memo = p$2;
	reactIs_production_min.Portal = c;
	reactIs_production_min.Profiler = f$3;
	reactIs_production_min.StrictMode = e;
	reactIs_production_min.Suspense = m$1;
	reactIs_production_min.SuspenseList = n;
	reactIs_production_min.isAsyncMode = function() {
		return false;
	};
	reactIs_production_min.isConcurrentMode = function() {
		return false;
	};
	reactIs_production_min.isContextConsumer = function(a$2) {
		return v$1(a$2) === h$3;
	};
	reactIs_production_min.isContextProvider = function(a$2) {
		return v$1(a$2) === g;
	};
	reactIs_production_min.isElement = function(a$2) {
		return "object" === typeof a$2 && null !== a$2 && a$2.$$typeof === b$1;
	};
	reactIs_production_min.isForwardRef = function(a$2) {
		return v$1(a$2) === l$1;
	};
	reactIs_production_min.isFragment = function(a$2) {
		return v$1(a$2) === d;
	};
	reactIs_production_min.isLazy = function(a$2) {
		return v$1(a$2) === q;
	};
	reactIs_production_min.isMemo = function(a$2) {
		return v$1(a$2) === p$2;
	};
	reactIs_production_min.isPortal = function(a$2) {
		return v$1(a$2) === c;
	};
	reactIs_production_min.isProfiler = function(a$2) {
		return v$1(a$2) === f$3;
	};
	reactIs_production_min.isStrictMode = function(a$2) {
		return v$1(a$2) === e;
	};
	reactIs_production_min.isSuspense = function(a$2) {
		return v$1(a$2) === m$1;
	};
	reactIs_production_min.isSuspenseList = function(a$2) {
		return v$1(a$2) === n;
	};
	reactIs_production_min.isValidElementType = function(a$2) {
		return "string" === typeof a$2 || "function" === typeof a$2 || a$2 === d || a$2 === f$3 || a$2 === e || a$2 === m$1 || a$2 === n || a$2 === t || "object" === typeof a$2 && null !== a$2 && (a$2.$$typeof === q || a$2.$$typeof === p$2 || a$2.$$typeof === g || a$2.$$typeof === h$3 || a$2.$$typeof === l$1 || a$2.$$typeof === u$2 || void 0 !== a$2.getModuleId) ? true : false;
	};
	reactIs_production_min.typeOf = v$1;
	return reactIs_production_min;
}
var reactIs_development = {};
/**
* @license React
* react-is.development.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var hasRequiredReactIs_development;
function requireReactIs_development() {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;
	if (process.env.NODE_ENV !== "production") (function() {
		var REACT_ELEMENT_TYPE = Symbol.for("react.element");
		var REACT_PORTAL_TYPE = Symbol.for("react.portal");
		var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
		var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
		var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
		var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
		var REACT_CONTEXT_TYPE = Symbol.for("react.context");
		var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
		var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
		var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
		var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
		var REACT_MEMO_TYPE = Symbol.for("react.memo");
		var REACT_LAZY_TYPE = Symbol.for("react.lazy");
		var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
		var enableScopeAPI = false;
		var enableCacheElement = false;
		var enableTransitionTracing = false;
		var enableLegacyHidden = false;
		var enableDebugTracing = false;
		var REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
		function isValidElementType(type$1) {
			if (typeof type$1 === "string" || typeof type$1 === "function") return true;
			if (type$1 === REACT_FRAGMENT_TYPE || type$1 === REACT_PROFILER_TYPE || enableDebugTracing || type$1 === REACT_STRICT_MODE_TYPE || type$1 === REACT_SUSPENSE_TYPE || type$1 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type$1 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) return true;
			if (typeof type$1 === "object" && type$1 !== null) {
				if (type$1.$$typeof === REACT_LAZY_TYPE || type$1.$$typeof === REACT_MEMO_TYPE || type$1.$$typeof === REACT_PROVIDER_TYPE || type$1.$$typeof === REACT_CONTEXT_TYPE || type$1.$$typeof === REACT_FORWARD_REF_TYPE || type$1.$$typeof === REACT_MODULE_REFERENCE || type$1.getModuleId !== void 0) return true;
			}
			return false;
		}
		function typeOf$1(object$1) {
			if (typeof object$1 === "object" && object$1 !== null) {
				var $$typeof = object$1.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type$1 = object$1.type;
						switch (type$1) {
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE:
							case REACT_SUSPENSE_LIST_TYPE: return type$1;
							default:
								var $$typeofType = type$1 && type$1.$$typeof;
								switch ($$typeofType) {
									case REACT_SERVER_CONTEXT_TYPE:
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element$1 = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		var hasWarnedAboutDeprecatedIsConcurrentMode = false;
		function isAsyncMode(object$1) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
			}
			return false;
		}
		function isConcurrentMode(object$1) {
			if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
				hasWarnedAboutDeprecatedIsConcurrentMode = true;
				console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
			}
			return false;
		}
		function isContextConsumer(object$1) {
			return typeOf$1(object$1) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object$1) {
			return typeOf$1(object$1) === REACT_PROVIDER_TYPE;
		}
		function isElement(object$1) {
			return typeof object$1 === "object" && object$1 !== null && object$1.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object$1) {
			return typeOf$1(object$1) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment(object$1) {
			return typeOf$1(object$1) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object$1) {
			return typeOf$1(object$1) === REACT_LAZY_TYPE;
		}
		function isMemo(object$1) {
			return typeOf$1(object$1) === REACT_MEMO_TYPE;
		}
		function isPortal(object$1) {
			return typeOf$1(object$1) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object$1) {
			return typeOf$1(object$1) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object$1) {
			return typeOf$1(object$1) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object$1) {
			return typeOf$1(object$1) === REACT_SUSPENSE_TYPE;
		}
		function isSuspenseList(object$1) {
			return typeOf$1(object$1) === REACT_SUSPENSE_LIST_TYPE;
		}
		reactIs_development.ContextConsumer = ContextConsumer;
		reactIs_development.ContextProvider = ContextProvider;
		reactIs_development.Element = Element$1;
		reactIs_development.ForwardRef = ForwardRef;
		reactIs_development.Fragment = Fragment;
		reactIs_development.Lazy = Lazy;
		reactIs_development.Memo = Memo;
		reactIs_development.Portal = Portal;
		reactIs_development.Profiler = Profiler;
		reactIs_development.StrictMode = StrictMode;
		reactIs_development.Suspense = Suspense;
		reactIs_development.SuspenseList = SuspenseList;
		reactIs_development.isAsyncMode = isAsyncMode;
		reactIs_development.isConcurrentMode = isConcurrentMode;
		reactIs_development.isContextConsumer = isContextConsumer;
		reactIs_development.isContextProvider = isContextProvider;
		reactIs_development.isElement = isElement;
		reactIs_development.isForwardRef = isForwardRef;
		reactIs_development.isFragment = isFragment;
		reactIs_development.isLazy = isLazy;
		reactIs_development.isMemo = isMemo;
		reactIs_development.isPortal = isPortal;
		reactIs_development.isProfiler = isProfiler;
		reactIs_development.isStrictMode = isStrictMode;
		reactIs_development.isSuspense = isSuspense;
		reactIs_development.isSuspenseList = isSuspenseList;
		reactIs_development.isValidElementType = isValidElementType;
		reactIs_development.typeOf = typeOf$1;
	})();
	return reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
	if (hasRequiredReactIs) return reactIs.exports;
	hasRequiredReactIs = 1;
	if (process.env.NODE_ENV === "production") reactIs.exports = requireReactIs_production_min();
	else reactIs.exports = requireReactIs_development();
	return reactIs.exports;
}
var reactIsExports = requireReactIs();
var ReactIs18 = /* @__PURE__ */ _mergeNamespaces({
	__proto__: null,
	default: /* @__PURE__ */ getDefaultExportFromCjs$3(reactIsExports)
}, [reactIsExports]);
const ReactIs = Object.fromEntries([
	"isAsyncMode",
	"isConcurrentMode",
	"isContextConsumer",
	"isContextProvider",
	"isElement",
	"isForwardRef",
	"isFragment",
	"isLazy",
	"isMemo",
	"isPortal",
	"isProfiler",
	"isStrictMode",
	"isSuspense",
	"isSuspenseList",
	"isValidElementType"
].map((m$1) => [m$1, (v$1) => ReactIs18[m$1](v$1) || ReactIs19[m$1](v$1)]));
function getChildren(arg, children = []) {
	if (Array.isArray(arg)) for (const item of arg) getChildren(item, children);
	else if (arg != null && arg !== false && arg !== "") children.push(arg);
	return children;
}
function getType$2(element) {
	const type$1 = element.type;
	if (typeof type$1 === "string") return type$1;
	if (typeof type$1 === "function") return type$1.displayName || type$1.name || "Unknown";
	if (ReactIs.isFragment(element)) return "React.Fragment";
	if (ReactIs.isSuspense(element)) return "React.Suspense";
	if (typeof type$1 === "object" && type$1 !== null) {
		if (ReactIs.isContextProvider(element)) return "Context.Provider";
		if (ReactIs.isContextConsumer(element)) return "Context.Consumer";
		if (ReactIs.isForwardRef(element)) {
			if (type$1.displayName) return type$1.displayName;
			const functionName$1 = type$1.render.displayName || type$1.render.name || "";
			return functionName$1 === "" ? "ForwardRef" : `ForwardRef(${functionName$1})`;
		}
		if (ReactIs.isMemo(element)) {
			const functionName$1 = type$1.displayName || type$1.type.displayName || type$1.type.name || "";
			return functionName$1 === "" ? "Memo" : `Memo(${functionName$1})`;
		}
	}
	return "UNDEFINED";
}
function getPropKeys$1(element) {
	const { props } = element;
	return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
const serialize$1$1 = (element, config$1, indentation, depth, refs, printer$1) => ++depth > config$1.maxDepth ? printElementAsLeaf(getType$2(element), config$1) : printElement(getType$2(element), printProps(getPropKeys$1(element), element.props, config$1, indentation + config$1.indent, depth, refs, printer$1), printChildren(getChildren(element.props.children), config$1, indentation + config$1.indent, depth, refs, printer$1), config$1, indentation);
const test$1$1 = (val) => val != null && ReactIs.isElement(val);
const plugin$1 = {
	serialize: serialize$1$1,
	test: test$1$1
};
const testSymbol = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object$1) {
	const { props } = object$1;
	return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
const serialize$6 = (object$1, config$1, indentation, depth, refs, printer$1) => ++depth > config$1.maxDepth ? printElementAsLeaf(object$1.type, config$1) : printElement(object$1.type, object$1.props ? printProps(getPropKeys(object$1), object$1.props, config$1, indentation + config$1.indent, depth, refs, printer$1) : "", object$1.children ? printChildren(object$1.children, config$1, indentation + config$1.indent, depth, refs, printer$1) : "", config$1, indentation);
const test$6 = (val) => val && val.$$typeof === testSymbol;
const plugin$6 = {
	serialize: serialize$6,
	test: test$6
};
const toString$2 = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
/**
* Explicitly comparing typeof constructor to function avoids undefined as name
* when mock identity-obj-proxy returns the key as the value for any key.
*/
function getConstructorName$1(val) {
	return typeof val.constructor === "function" && val.constructor.name || "Object";
}
/** Is val is equal to global window object? Works even if it does not exist :) */
function isWindow(val) {
	return typeof window !== "undefined" && val === window;
}
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/g;
var PrettyFormatPluginError = class extends Error {
	constructor(message, stack) {
		super(message);
		this.stack = stack;
		this.name = this.constructor.name;
	}
};
function isToStringedArrayType(toStringed) {
	return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
	return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
	return String(`${val}n`);
}
function printFunction(val, printFunctionName$1) {
	if (!printFunctionName$1) return "[Function]";
	return `[Function ${val.name || "anonymous"}]`;
}
function printSymbol(val) {
	return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
	return `[${errorToString.call(val)}]`;
}
/**
* The first port of call for printing an object, handles most of the
* data-types in JS.
*/
function printBasicValue(val, printFunctionName$1, escapeRegex$1, escapeString) {
	if (val === true || val === false) return `${val}`;
	if (val === void 0) return "undefined";
	if (val === null) return "null";
	const typeOf$1 = typeof val;
	if (typeOf$1 === "number") return printNumber(val);
	if (typeOf$1 === "bigint") return printBigInt(val);
	if (typeOf$1 === "string") {
		if (escapeString) return `"${val.replaceAll(/"|\\/g, "\\$&")}"`;
		return `"${val}"`;
	}
	if (typeOf$1 === "function") return printFunction(val, printFunctionName$1);
	if (typeOf$1 === "symbol") return printSymbol(val);
	const toStringed = toString$2.call(val);
	if (toStringed === "[object WeakMap]") return "WeakMap {}";
	if (toStringed === "[object WeakSet]") return "WeakSet {}";
	if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") return printFunction(val, printFunctionName$1);
	if (toStringed === "[object Symbol]") return printSymbol(val);
	if (toStringed === "[object Date]") return Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
	if (toStringed === "[object Error]") return printError(val);
	if (toStringed === "[object RegExp]") {
		if (escapeRegex$1) return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");
		return regExpToString.call(val);
	}
	if (val instanceof Error) return printError(val);
	return null;
}
/**
* Handles more complex objects ( such as objects with circular references.
* maps and sets etc )
*/
function printComplexValue(val, config$1, indentation, depth, refs, hasCalledToJSON) {
	if (refs.includes(val)) return "[Circular]";
	refs = [...refs];
	refs.push(val);
	const hitMaxDepth = ++depth > config$1.maxDepth;
	const min = config$1.min;
	if (config$1.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) return printer(val.toJSON(), config$1, indentation, depth, refs, true);
	const toStringed = toString$2.call(val);
	if (toStringed === "[object Arguments]") return hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config$1, indentation, depth, refs, printer)}]`;
	if (isToStringedArrayType(toStringed)) return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? "" : !config$1.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config$1, indentation, depth, refs, printer)}]`;
	if (toStringed === "[object Map]") return hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config$1, indentation, depth, refs, printer, " => ")}}`;
	if (toStringed === "[object Set]") return hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config$1, indentation, depth, refs, printer)}}`;
	return hitMaxDepth || isWindow(val) ? `[${getConstructorName$1(val)}]` : `${min ? "" : !config$1.printBasicPrototype && getConstructorName$1(val) === "Object" ? "" : `${getConstructorName$1(val)} `}{${printObjectProperties(val, config$1, indentation, depth, refs, printer)}}`;
}
const ErrorPlugin = {
	test: (val) => val && val instanceof Error,
	serialize(val, config$1, indentation, depth, refs, printer$1) {
		if (refs.includes(val)) return "[Circular]";
		refs = [...refs, val];
		const hitMaxDepth = ++depth > config$1.maxDepth;
		const { message, cause,...rest } = val;
		const entries = {
			message,
			...typeof cause !== "undefined" ? { cause } : {},
			...val instanceof AggregateError ? { errors: val.errors } : {},
			...rest
		};
		const name = val.name !== "Error" ? val.name : getConstructorName$1(val);
		return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config$1, indentation, depth, refs, printer$1)}}`;
	}
};
function isNewPlugin(plugin$7) {
	return plugin$7.serialize != null;
}
function printPlugin(plugin$7, val, config$1, indentation, depth, refs) {
	let printed;
	try {
		printed = isNewPlugin(plugin$7) ? plugin$7.serialize(val, config$1, indentation, depth, refs, printer) : plugin$7.print(val, (valChild) => printer(valChild, config$1, indentation, depth, refs), (str) => {
			const indentationNext = indentation + config$1.indent;
			return indentationNext + str.replaceAll(NEWLINE_REGEXP, `\n${indentationNext}`);
		}, {
			edgeSpacing: config$1.spacingOuter,
			min: config$1.min,
			spacing: config$1.spacingInner
		}, config$1.colors);
	} catch (error) {
		throw new PrettyFormatPluginError(error.message, error.stack);
	}
	if (typeof printed !== "string") throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
	return printed;
}
function findPlugin(plugins$1, val) {
	for (const plugin$7 of plugins$1) try {
		if (plugin$7.test(val)) return plugin$7;
	} catch (error) {
		throw new PrettyFormatPluginError(error.message, error.stack);
	}
	return null;
}
function printer(val, config$1, indentation, depth, refs, hasCalledToJSON) {
	const plugin$7 = findPlugin(config$1.plugins, val);
	if (plugin$7 !== null) return printPlugin(plugin$7, val, config$1, indentation, depth, refs);
	const basicResult = printBasicValue(val, config$1.printFunctionName, config$1.escapeRegex, config$1.escapeString);
	if (basicResult !== null) return basicResult;
	return printComplexValue(val, config$1, indentation, depth, refs, hasCalledToJSON);
}
const DEFAULT_THEME = {
	comment: "gray",
	content: "reset",
	prop: "yellow",
	tag: "cyan",
	value: "green"
};
const DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
const DEFAULT_OPTIONS = {
	callToJSON: true,
	compareKeys: void 0,
	escapeRegex: false,
	escapeString: true,
	highlight: false,
	indent: 2,
	maxDepth: Number.POSITIVE_INFINITY,
	maxWidth: Number.POSITIVE_INFINITY,
	min: false,
	plugins: [],
	printBasicPrototype: true,
	printFunctionName: true,
	theme: DEFAULT_THEME
};
function validateOptions(options) {
	for (const key of Object.keys(options)) if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) throw new Error(`pretty-format: Unknown option "${key}".`);
	if (options.min && options.indent !== void 0 && options.indent !== 0) throw new Error("pretty-format: Options \"min\" and \"indent\" cannot be used together.");
}
function getColorsHighlight() {
	return DEFAULT_THEME_KEYS.reduce((colors, key) => {
		const value = DEFAULT_THEME[key];
		const color = value && u[value];
		if (color && typeof color.close === "string" && typeof color.open === "string") colors[key] = color;
		else throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
		return colors;
	}, Object.create(null));
}
function getColorsEmpty() {
	return DEFAULT_THEME_KEYS.reduce((colors, key) => {
		colors[key] = {
			close: "",
			open: ""
		};
		return colors;
	}, Object.create(null));
}
function getPrintFunctionName(options) {
	return (options === null || options === void 0 ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options) {
	return (options === null || options === void 0 ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options) {
	return (options === null || options === void 0 ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS.escapeString;
}
function getConfig(options) {
	return {
		callToJSON: (options === null || options === void 0 ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS.callToJSON,
		colors: (options === null || options === void 0 ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),
		compareKeys: typeof (options === null || options === void 0 ? void 0 : options.compareKeys) === "function" || (options === null || options === void 0 ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
		escapeRegex: getEscapeRegex(options),
		escapeString: getEscapeString(options),
		indent: (options === null || options === void 0 ? void 0 : options.min) ? "" : createIndent((options === null || options === void 0 ? void 0 : options.indent) ?? DEFAULT_OPTIONS.indent),
		maxDepth: (options === null || options === void 0 ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS.maxDepth,
		maxWidth: (options === null || options === void 0 ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS.maxWidth,
		min: (options === null || options === void 0 ? void 0 : options.min) ?? DEFAULT_OPTIONS.min,
		plugins: (options === null || options === void 0 ? void 0 : options.plugins) ?? DEFAULT_OPTIONS.plugins,
		printBasicPrototype: (options === null || options === void 0 ? void 0 : options.printBasicPrototype) ?? true,
		printFunctionName: getPrintFunctionName(options),
		spacingInner: (options === null || options === void 0 ? void 0 : options.min) ? " " : "\n",
		spacingOuter: (options === null || options === void 0 ? void 0 : options.min) ? "" : "\n"
	};
}
function createIndent(indent) {
	return Array.from({ length: indent + 1 }).join(" ");
}
/**
* Returns a presentation string of your `val` object
* @param val any potential JavaScript object
* @param options Custom settings
*/
function format(val, options) {
	if (options) {
		validateOptions(options);
		if (options.plugins) {
			const plugin$7 = findPlugin(options.plugins, val);
			if (plugin$7 !== null) return printPlugin(plugin$7, val, getConfig(options), "", 0, []);
		}
	}
	const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
	if (basicResult !== null) return basicResult;
	return printComplexValue(val, getConfig(options), "", 0, []);
}
const plugins = {
	AsymmetricMatcher: plugin$5,
	DOMCollection: plugin$4,
	DOMElement: plugin$3,
	Immutable: plugin$2,
	ReactElement: plugin$1,
	ReactTestComponent: plugin$6,
	Error: ErrorPlugin
};

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/helpers.js
const ansiColors$1 = {
	bold: ["1", "22"],
	dim: ["2", "22"],
	italic: ["3", "23"],
	underline: ["4", "24"],
	inverse: ["7", "27"],
	hidden: ["8", "28"],
	strike: ["9", "29"],
	black: ["30", "39"],
	red: ["31", "39"],
	green: ["32", "39"],
	yellow: ["33", "39"],
	blue: ["34", "39"],
	magenta: ["35", "39"],
	cyan: ["36", "39"],
	white: ["37", "39"],
	brightblack: ["30;1", "39"],
	brightred: ["31;1", "39"],
	brightgreen: ["32;1", "39"],
	brightyellow: ["33;1", "39"],
	brightblue: ["34;1", "39"],
	brightmagenta: ["35;1", "39"],
	brightcyan: ["36;1", "39"],
	brightwhite: ["37;1", "39"],
	grey: ["90", "39"]
};
const styles$1 = {
	special: "cyan",
	number: "yellow",
	bigint: "yellow",
	boolean: "yellow",
	undefined: "grey",
	null: "bold",
	string: "green",
	symbol: "green",
	date: "magenta",
	regexp: "red"
};
const truncator$1 = "…";
function colorise$1(value, styleType) {
	const color = ansiColors$1[styles$1[styleType]] || ansiColors$1[styleType] || "";
	if (!color) return String(value);
	return `\u001b[${color[0]}m${String(value)}\u001b[${color[1]}m`;
}
function normaliseOptions$1({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = Infinity, breakLength = Infinity, seen = [], truncate: truncate$2 = Infinity, stylize = String } = {}, inspect$3) {
	const options = {
		showHidden: Boolean(showHidden),
		depth: Number(depth),
		colors: Boolean(colors),
		customInspect: Boolean(customInspect),
		showProxy: Boolean(showProxy),
		maxArrayLength: Number(maxArrayLength),
		breakLength: Number(breakLength),
		truncate: Number(truncate$2),
		seen,
		inspect: inspect$3,
		stylize
	};
	if (options.colors) options.stylize = colorise$1;
	return options;
}
function isHighSurrogate$1(char) {
	return char >= "\ud800" && char <= "\udbff";
}
function truncate$1(string$1, length, tail = truncator$1) {
	string$1 = String(string$1);
	const tailLength = tail.length;
	const stringLength = string$1.length;
	if (tailLength > length && stringLength > tailLength) return tail;
	if (stringLength > length && stringLength > tailLength) {
		let end = length - tailLength;
		if (end > 0 && isHighSurrogate$1(string$1[end - 1])) end = end - 1;
		return `${string$1.slice(0, end)}${tail}`;
	}
	return string$1;
}
function inspectList$1(list, options, inspectItem, separator = ", ") {
	inspectItem = inspectItem || options.inspect;
	const size = list.length;
	if (size === 0) return "";
	const originalLength = options.truncate;
	let output = "";
	let peek = "";
	let truncated = "";
	for (let i = 0; i < size; i += 1) {
		const last = i + 1 === list.length;
		const secondToLast = i + 2 === list.length;
		truncated = `${truncator$1}(${list.length - i})`;
		const value = list[i];
		options.truncate = originalLength - output.length - (last ? 0 : separator.length);
		const string$1 = peek || inspectItem(value, options) + (last ? "" : separator);
		const nextLength = output.length + string$1.length;
		const truncatedLength = nextLength + truncated.length;
		if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) break;
		if (!last && !secondToLast && truncatedLength > originalLength) break;
		peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
		if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) break;
		output += string$1;
		if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
			truncated = `${truncator$1}(${list.length - i - 1})`;
			break;
		}
		truncated = "";
	}
	return `${output}${truncated}`;
}
function quoteComplexKey$1(key) {
	if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) return key;
	return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, "\"").replace(/(^"|"$)/g, "'");
}
function inspectProperty$1([key, value], options) {
	options.truncate -= 2;
	if (typeof key === "string") key = quoteComplexKey$1(key);
	else if (typeof key !== "number") key = `[${options.inspect(key, options)}]`;
	options.truncate -= key.length;
	value = options.inspect(value, options);
	return `${key}: ${value}`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/array.js
function inspectArray$1(array$1, options) {
	const nonIndexProperties = Object.keys(array$1).slice(array$1.length);
	if (!array$1.length && !nonIndexProperties.length) return "[]";
	options.truncate -= 4;
	const listContents = inspectList$1(array$1, options);
	options.truncate -= listContents.length;
	let propertyContents = "";
	if (nonIndexProperties.length) propertyContents = inspectList$1(nonIndexProperties.map((key) => [key, array$1[key]]), options, inspectProperty$1);
	return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/typedarray.js
const getArrayName$1 = (array$1) => {
	if (typeof Buffer === "function" && array$1 instanceof Buffer) return "Buffer";
	if (array$1[Symbol.toStringTag]) return array$1[Symbol.toStringTag];
	return array$1.constructor.name;
};
function inspectTypedArray$1(array$1, options) {
	const name = getArrayName$1(array$1);
	options.truncate -= name.length + 4;
	const nonIndexProperties = Object.keys(array$1).slice(array$1.length);
	if (!array$1.length && !nonIndexProperties.length) return `${name}[]`;
	let output = "";
	for (let i = 0; i < array$1.length; i++) {
		const string$1 = `${options.stylize(truncate$1(array$1[i], options.truncate), "number")}${i === array$1.length - 1 ? "" : ", "}`;
		options.truncate -= string$1.length;
		if (array$1[i] !== array$1.length && options.truncate <= 3) {
			output += `${truncator$1}(${array$1.length - array$1[i] + 1})`;
			break;
		}
		output += string$1;
	}
	let propertyContents = "";
	if (nonIndexProperties.length) propertyContents = inspectList$1(nonIndexProperties.map((key) => [key, array$1[key]]), options, inspectProperty$1);
	return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/date.js
function inspectDate$1(dateObject, options) {
	const stringRepresentation = dateObject.toJSON();
	if (stringRepresentation === null) return "Invalid Date";
	const split = stringRepresentation.split("T");
	const date = split[0];
	return options.stylize(`${date}T${truncate$1(split[1], options.truncate - date.length - 1)}`, "date");
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/function.js
function inspectFunction$1(func, options) {
	const functionType = func[Symbol.toStringTag] || "Function";
	const name = func.name;
	if (!name) return options.stylize(`[${functionType}]`, "special");
	return options.stylize(`[${functionType} ${truncate$1(name, options.truncate - 11)}]`, "special");
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/map.js
function inspectMapEntry$1([key, value], options) {
	options.truncate -= 4;
	key = options.inspect(key, options);
	options.truncate -= key.length;
	value = options.inspect(value, options);
	return `${key} => ${value}`;
}
function mapToEntries$1(map$1) {
	const entries = [];
	map$1.forEach((value, key) => {
		entries.push([key, value]);
	});
	return entries;
}
function inspectMap$1(map$1, options) {
	if (map$1.size === 0) return "Map{}";
	options.truncate -= 7;
	return `Map{ ${inspectList$1(mapToEntries$1(map$1), options, inspectMapEntry$1)} }`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/number.js
const isNaN$1 = Number.isNaN || ((i) => i !== i);
function inspectNumber$1(number, options) {
	if (isNaN$1(number)) return options.stylize("NaN", "number");
	if (number === Infinity) return options.stylize("Infinity", "number");
	if (number === -Infinity) return options.stylize("-Infinity", "number");
	if (number === 0) return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
	return options.stylize(truncate$1(String(number), options.truncate), "number");
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/bigint.js
function inspectBigInt$1(number, options) {
	let nums = truncate$1(number.toString(), options.truncate - 1);
	if (nums !== truncator$1) nums += "n";
	return options.stylize(nums, "bigint");
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/regexp.js
function inspectRegExp$1(value, options) {
	const flags = value.toString().split("/")[2];
	const sourceLength = options.truncate - (2 + flags.length);
	const source = value.source;
	return options.stylize(`/${truncate$1(source, sourceLength)}/${flags}`, "regexp");
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/set.js
function arrayFromSet$1(set$1) {
	const values = [];
	set$1.forEach((value) => {
		values.push(value);
	});
	return values;
}
function inspectSet$1(set$1, options) {
	if (set$1.size === 0) return "Set{}";
	options.truncate -= 7;
	return `Set{ ${inspectList$1(arrayFromSet$1(set$1), options)} }`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/string.js
const stringEscapeChars$1 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
const escapeCharacters$1 = {
	"\b": "\\b",
	"	": "\\t",
	"\n": "\\n",
	"\f": "\\f",
	"\r": "\\r",
	"'": "\\'",
	"\\": "\\\\"
};
const hex$1 = 16;
const unicodeLength$1 = 4;
function escape$1(char) {
	return escapeCharacters$1[char] || `\\u${`0000${char.charCodeAt(0).toString(hex$1)}`.slice(-unicodeLength$1)}`;
}
function inspectString$1(string$1, options) {
	if (stringEscapeChars$1.test(string$1)) string$1 = string$1.replace(stringEscapeChars$1, escape$1);
	return options.stylize(`'${truncate$1(string$1, options.truncate - 2)}'`, "string");
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/symbol.js
function inspectSymbol$1(value) {
	if ("description" in Symbol.prototype) return value.description ? `Symbol(${value.description})` : "Symbol()";
	return value.toString();
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/promise.js
const getPromiseValue = () => "Promise{…}";
var promise_default$1 = getPromiseValue;

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/object.js
function inspectObject$1(object$1, options) {
	const properties = Object.getOwnPropertyNames(object$1);
	const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object$1) : [];
	if (properties.length === 0 && symbols.length === 0) return "{}";
	options.truncate -= 4;
	options.seen = options.seen || [];
	if (options.seen.includes(object$1)) return "[Circular]";
	options.seen.push(object$1);
	const propertyContents = inspectList$1(properties.map((key) => [key, object$1[key]]), options, inspectProperty$1);
	const symbolContents = inspectList$1(symbols.map((key) => [key, object$1[key]]), options, inspectProperty$1);
	options.seen.pop();
	let sep = "";
	if (propertyContents && symbolContents) sep = ", ";
	return `{ ${propertyContents}${sep}${symbolContents} }`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/class.js
const toStringTag$1 = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass$1(value, options) {
	let name = "";
	if (toStringTag$1 && toStringTag$1 in value) name = value[toStringTag$1];
	name = name || value.constructor.name;
	if (!name || name === "_class") name = "<Anonymous Class>";
	options.truncate -= name.length;
	return `${name}${inspectObject$1(value, options)}`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/arguments.js
function inspectArguments$1(args, options) {
	if (args.length === 0) return "Arguments[]";
	options.truncate -= 13;
	return `Arguments[ ${inspectList$1(args, options)} ]`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/error.js
const errorKeys$1 = [
	"stack",
	"line",
	"column",
	"name",
	"message",
	"fileName",
	"lineNumber",
	"columnNumber",
	"number",
	"description",
	"cause"
];
function inspectObject$2(error, options) {
	const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys$1.indexOf(key) === -1);
	const name = error.name;
	options.truncate -= name.length;
	let message = "";
	if (typeof error.message === "string") message = truncate$1(error.message, options.truncate);
	else properties.unshift("message");
	message = message ? `: ${message}` : "";
	options.truncate -= message.length + 5;
	options.seen = options.seen || [];
	if (options.seen.includes(error)) return "[Circular]";
	options.seen.push(error);
	const propertyContents = inspectList$1(properties.map((key) => [key, error[key]]), options, inspectProperty$1);
	return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/html.js
function inspectAttribute$1([key, value], options) {
	options.truncate -= 3;
	if (!value) return `${options.stylize(String(key), "yellow")}`;
	return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
function inspectNodeCollection$1(collection, options) {
	return inspectList$1(collection, options, inspectNode$1, "\n");
}
function inspectNode$1(node, options) {
	switch (node.nodeType) {
		case 1: return inspectHTML$1(node, options);
		case 3: return options.inspect(node.data, options);
		default: return options.inspect(node, options);
	}
}
function inspectHTML$1(element, options) {
	const properties = element.getAttributeNames();
	const name = element.tagName.toLowerCase();
	const head = options.stylize(`<${name}`, "special");
	const headClose = options.stylize(`>`, "special");
	const tail = options.stylize(`</${name}>`, "special");
	options.truncate -= name.length * 2 + 5;
	let propertyContents = "";
	if (properties.length > 0) {
		propertyContents += " ";
		propertyContents += inspectList$1(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute$1, " ");
	}
	options.truncate -= propertyContents.length;
	const truncate$2 = options.truncate;
	let children = inspectNodeCollection$1(element.children, options);
	if (children && children.length > truncate$2) children = `${truncator$1}(${element.children.length})`;
	return `${head}${propertyContents}${headClose}${children}${tail}`;
}

//#endregion
//#region node_modules/.pnpm/loupe@3.2.1/node_modules/loupe/lib/index.js
const chaiInspect$1 = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("chai/inspect") : "@@chai/inspect";
const nodeInspect$1 = Symbol.for("nodejs.util.inspect.custom");
const constructorMap$1 = /* @__PURE__ */ new WeakMap();
const stringTagMap$1 = {};
const baseTypesMap$1 = {
	undefined: (value, options) => options.stylize("undefined", "undefined"),
	null: (value, options) => options.stylize("null", "null"),
	boolean: (value, options) => options.stylize(String(value), "boolean"),
	Boolean: (value, options) => options.stylize(String(value), "boolean"),
	number: inspectNumber$1,
	Number: inspectNumber$1,
	bigint: inspectBigInt$1,
	BigInt: inspectBigInt$1,
	string: inspectString$1,
	String: inspectString$1,
	function: inspectFunction$1,
	Function: inspectFunction$1,
	symbol: inspectSymbol$1,
	Symbol: inspectSymbol$1,
	Array: inspectArray$1,
	Date: inspectDate$1,
	Map: inspectMap$1,
	Set: inspectSet$1,
	RegExp: inspectRegExp$1,
	Promise: promise_default$1,
	WeakSet: (value, options) => options.stylize("WeakSet{…}", "special"),
	WeakMap: (value, options) => options.stylize("WeakMap{…}", "special"),
	Arguments: inspectArguments$1,
	Int8Array: inspectTypedArray$1,
	Uint8Array: inspectTypedArray$1,
	Uint8ClampedArray: inspectTypedArray$1,
	Int16Array: inspectTypedArray$1,
	Uint16Array: inspectTypedArray$1,
	Int32Array: inspectTypedArray$1,
	Uint32Array: inspectTypedArray$1,
	Float32Array: inspectTypedArray$1,
	Float64Array: inspectTypedArray$1,
	Generator: () => "",
	DataView: () => "",
	ArrayBuffer: () => "",
	Error: inspectObject$2,
	HTMLCollection: inspectNodeCollection$1,
	NodeList: inspectNodeCollection$1
};
const inspectCustom$1 = (value, options, type$1, inspectFn) => {
	if (chaiInspect$1 in value && typeof value[chaiInspect$1] === "function") return value[chaiInspect$1](options);
	if (nodeInspect$1 in value && typeof value[nodeInspect$1] === "function") return value[nodeInspect$1](options.depth, options, inspectFn);
	if ("inspect" in value && typeof value.inspect === "function") return value.inspect(options.depth, options);
	if ("constructor" in value && constructorMap$1.has(value.constructor)) return constructorMap$1.get(value.constructor)(value, options);
	if (stringTagMap$1[type$1]) return stringTagMap$1[type$1](value, options);
	return "";
};
const toString$1 = Object.prototype.toString;
function inspect$2(value, opts = {}) {
	const options = normaliseOptions$1(opts, inspect$2);
	const { customInspect } = options;
	let type$1 = value === null ? "null" : typeof value;
	if (type$1 === "object") type$1 = toString$1.call(value).slice(8, -1);
	if (type$1 in baseTypesMap$1) return baseTypesMap$1[type$1](value, options);
	if (customInspect && value) {
		const output = inspectCustom$1(value, options, type$1, inspect$2);
		if (output) {
			if (typeof output === "string") return output;
			return inspect$2(output, options);
		}
	}
	const proto = value ? Object.getPrototypeOf(value) : false;
	if (proto === Object.prototype || proto === null) return inspectObject$1(value, options);
	if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) return inspectHTML$1(value, options);
	if ("constructor" in value) {
		if (value.constructor !== Object) return inspectClass$1(value, options);
		return inspectObject$1(value, options);
	}
	if (value === Object(value)) return inspectObject$1(value, options);
	return options.stylize(String(value), type$1);
}

//#endregion
//#region node_modules/.pnpm/@vitest+utils@3.2.4/node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js
const { AsymmetricMatcher: AsymmetricMatcher$4, DOMCollection: DOMCollection$3, DOMElement: DOMElement$3, Immutable: Immutable$3, ReactElement: ReactElement$3, ReactTestComponent: ReactTestComponent$3 } = plugins;
const PLUGINS$2 = [
	ReactTestComponent$3,
	ReactElement$3,
	DOMElement$3,
	DOMCollection$3,
	Immutable$3,
	AsymmetricMatcher$4
];
function stringify(object$1, maxDepth = 10, { maxLength,...options } = {}) {
	const MAX_LENGTH = maxLength ?? 1e4;
	let result;
	try {
		result = format(object$1, {
			maxDepth,
			escapeString: false,
			plugins: PLUGINS$2,
			...options
		});
	} catch {
		result = format(object$1, {
			callToJSON: false,
			maxDepth,
			escapeString: false,
			plugins: PLUGINS$2,
			...options
		});
	}
	return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object$1, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
		maxLength,
		...options
	}) : result;
}
const formatRegExp = /%[sdjifoOc%]/g;
function format$1(...args) {
	if (typeof args[0] !== "string") {
		const objects = [];
		for (let i$1 = 0; i$1 < args.length; i$1++) objects.push(inspect$1(args[i$1], {
			depth: 0,
			colors: false
		}));
		return objects.join(" ");
	}
	const len = args.length;
	let i = 1;
	const template = args[0];
	let str = String(template).replace(formatRegExp, (x$1) => {
		if (x$1 === "%%") return "%";
		if (i >= len) return x$1;
		switch (x$1) {
			case "%s": {
				const value = args[i++];
				if (typeof value === "bigint") return `${value.toString()}n`;
				if (typeof value === "number" && value === 0 && 1 / value < 0) return "-0";
				if (typeof value === "object" && value !== null) {
					if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) return value.toString();
					return inspect$1(value, {
						depth: 0,
						colors: false
					});
				}
				return String(value);
			}
			case "%d": {
				const value = args[i++];
				if (typeof value === "bigint") return `${value.toString()}n`;
				return Number(value).toString();
			}
			case "%i": {
				const value = args[i++];
				if (typeof value === "bigint") return `${value.toString()}n`;
				return Number.parseInt(String(value)).toString();
			}
			case "%f": return Number.parseFloat(String(args[i++])).toString();
			case "%o": return inspect$1(args[i++], {
				showHidden: true,
				showProxy: true
			});
			case "%O": return inspect$1(args[i++]);
			case "%c":
				i++;
				return "";
			case "%j": try {
				return JSON.stringify(args[i++]);
			} catch (err) {
				const m$1 = err.message;
				if (m$1.includes("circular structure") || m$1.includes("cyclic structures") || m$1.includes("cyclic object")) return "[Circular]";
				throw err;
			}
			default: return x$1;
		}
	});
	for (let x$1 = args[i]; i < len; x$1 = args[++i]) if (x$1 === null || typeof x$1 !== "object") str += ` ${x$1}`;
	else str += ` ${inspect$1(x$1)}`;
	return str;
}
function inspect$1(obj, options = {}) {
	if (options.truncate === 0) options.truncate = Number.POSITIVE_INFINITY;
	return inspect$2(obj, options);
}
function objDisplay(obj, options = {}) {
	if (typeof options.truncate === "undefined") options.truncate = 40;
	const str = inspect$1(obj, options);
	const type$1 = Object.prototype.toString.call(obj);
	if (options.truncate && str.length >= options.truncate) if (type$1 === "[object Function]") {
		const fn$1 = obj;
		return !fn$1.name ? "[Function]" : `[Function: ${fn$1.name}]`;
	} else if (type$1 === "[object Array]") return `[ Array(${obj.length}) ]`;
	else if (type$1 === "[object Object]") {
		const keys$1 = Object.keys(obj);
		return `{ Object (${keys$1.length > 2 ? `${keys$1.splice(0, 2).join(", ")}, ...` : keys$1.join(", ")}) }`;
	} else return str;
	return str;
}
function getDefaultExportFromCjs$2(x$1) {
	return x$1 && x$1.__esModule && Object.prototype.hasOwnProperty.call(x$1, "default") ? x$1["default"] : x$1;
}

//#endregion
//#region node_modules/.pnpm/@vitest+utils@3.2.4/node_modules/@vitest/utils/dist/helpers.js
/**
* Get original stacktrace without source map support the most performant way.
* - Create only 1 stack frame.
* - Rewrite prepareStackTrace to bypass "support-stack-trace" (usually takes ~250ms).
*/
function createSimpleStackTrace(options) {
	const { message = "$$stack trace error", stackTraceLimit = 1 } = options || {};
	const limit = Error.stackTraceLimit;
	const prepareStackTrace = Error.prepareStackTrace;
	Error.stackTraceLimit = stackTraceLimit;
	Error.prepareStackTrace = (e) => e.stack;
	const stackTrace = new Error(message).stack || "";
	Error.prepareStackTrace = prepareStackTrace;
	Error.stackTraceLimit = limit;
	return stackTrace;
}
function assertTypes(value, name, types) {
	const receivedType = typeof value;
	if (!types.includes(receivedType)) throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
}
function toArray(array$1) {
	if (array$1 === null || array$1 === void 0) array$1 = [];
	if (Array.isArray(array$1)) return array$1;
	return [array$1];
}
function isObject$1(item) {
	return item != null && typeof item === "object" && !Array.isArray(item);
}
function isFinalObj(obj) {
	return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType(value) {
	return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
	const collect = typeof collector === "function" ? collector : (key) => collector.add(key);
	Object.getOwnPropertyNames(obj).forEach(collect);
	Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
	const ownProps = /* @__PURE__ */ new Set();
	if (isFinalObj(obj)) return [];
	collectOwnProperties(obj, ownProps);
	return Array.from(ownProps);
}
const defaultCloneOptions = { forceWritable: false };
function deepClone(val, options = defaultCloneOptions) {
	return clone(val, /* @__PURE__ */ new WeakMap(), options);
}
function clone(val, seen, options = defaultCloneOptions) {
	let k$1, out;
	if (seen.has(val)) return seen.get(val);
	if (Array.isArray(val)) {
		out = Array.from({ length: k$1 = val.length });
		seen.set(val, out);
		while (k$1--) out[k$1] = clone(val[k$1], seen, options);
		return out;
	}
	if (Object.prototype.toString.call(val) === "[object Object]") {
		out = Object.create(Object.getPrototypeOf(val));
		seen.set(val, out);
		const props = getOwnProperties(val);
		for (const k$2 of props) {
			const descriptor = Object.getOwnPropertyDescriptor(val, k$2);
			if (!descriptor) continue;
			const cloned = clone(val[k$2], seen, options);
			if (options.forceWritable) Object.defineProperty(out, k$2, {
				enumerable: descriptor.enumerable,
				configurable: true,
				writable: true,
				value: cloned
			});
			else if ("get" in descriptor) Object.defineProperty(out, k$2, {
				...descriptor,
				get() {
					return cloned;
				}
			});
			else Object.defineProperty(out, k$2, {
				...descriptor,
				value: cloned
			});
		}
		return out;
	}
	return val;
}
function noop() {}
function objectAttr(source, path, defaultValue = void 0) {
	const paths = path.replace(/\[(\d+)\]/g, ".$1").split(".");
	let result = source;
	for (const p$2 of paths) {
		result = new Object(result)[p$2];
		if (result === void 0) return defaultValue;
	}
	return result;
}
function createDefer() {
	let resolve$4 = null;
	let reject = null;
	const p$2 = new Promise((_resolve, _reject) => {
		resolve$4 = _resolve;
		reject = _reject;
	});
	p$2.resolve = resolve$4;
	p$2.reject = reject;
	return p$2;
}
function isNegativeNaN(val) {
	if (!Number.isNaN(val)) return false;
	const f64 = new Float64Array(1);
	f64[0] = val;
	return new Uint32Array(f64.buffer)[1] >>> 31 === 1;
}

//#endregion
//#region node_modules/.pnpm/@vitest+utils@3.2.4/node_modules/@vitest/utils/dist/index.js
var jsTokens_1$1;
var hasRequiredJsTokens$1;
function requireJsTokens$1() {
	if (hasRequiredJsTokens$1) return jsTokens_1$1;
	hasRequiredJsTokens$1 = 1;
	var Identifier$1, JSXIdentifier$1, JSXPunctuator$1, JSXString$1, JSXText$1, KeywordsWithExpressionAfter$1, KeywordsWithNoLineTerminatorAfter$1, LineTerminatorSequence$1, MultiLineComment$1, Newline$1, NumericLiteral$1, Punctuator$1, RegularExpressionLiteral$1 = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy, SingleLineComment$1, StringLiteral$1, Template$1, TokensNotPrecedingObjectLiteral$1, TokensPrecedingExpression$1, WhiteSpace$1;
	Punctuator$1 = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
	Identifier$1 = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy;
	StringLiteral$1 = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y;
	NumericLiteral$1 = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
	Template$1 = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y;
	WhiteSpace$1 = /[\t\v\f\ufeff\p{Zs}]+/uy;
	LineTerminatorSequence$1 = /\r?\n|[\r\u2028\u2029]/y;
	MultiLineComment$1 = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y;
	SingleLineComment$1 = /\/\/.*/y;
	JSXPunctuator$1 = /[<>.:={}]|\/(?![\/*])/y;
	JSXIdentifier$1 = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy;
	JSXString$1 = /(['"])(?:(?!\1)[^])*(\1)?/y;
	JSXText$1 = /[^<>{}]+/y;
	TokensPrecedingExpression$1 = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
	TokensNotPrecedingObjectLiteral$1 = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
	KeywordsWithExpressionAfter$1 = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
	KeywordsWithNoLineTerminatorAfter$1 = /^(?:return|throw|yield)$/;
	Newline$1 = RegExp(LineTerminatorSequence$1.source);
	jsTokens_1$1 = function* (input, { jsx = false } = {}) {
		var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
		({length} = input);
		lastIndex = 0;
		lastSignificantToken = "";
		stack = [{ tag: "JS" }];
		braces = [];
		parenNesting = 0;
		postfixIncDec = false;
		while (lastIndex < length) {
			mode = stack[stack.length - 1];
			switch (mode.tag) {
				case "JS":
				case "JSNonExpressionParen":
				case "InterpolationInTemplate":
				case "InterpolationInJSX":
					if (input[lastIndex] === "/" && (TokensPrecedingExpression$1.test(lastSignificantToken) || KeywordsWithExpressionAfter$1.test(lastSignificantToken))) {
						RegularExpressionLiteral$1.lastIndex = lastIndex;
						if (match = RegularExpressionLiteral$1.exec(input)) {
							lastIndex = RegularExpressionLiteral$1.lastIndex;
							lastSignificantToken = match[0];
							postfixIncDec = true;
							yield {
								type: "RegularExpressionLiteral",
								value: match[0],
								closed: match[1] !== void 0 && match[1] !== "\\"
							};
							continue;
						}
					}
					Punctuator$1.lastIndex = lastIndex;
					if (match = Punctuator$1.exec(input)) {
						punctuator = match[0];
						nextLastIndex = Punctuator$1.lastIndex;
						nextLastSignificantToken = punctuator;
						switch (punctuator) {
							case "(":
								if (lastSignificantToken === "?NonExpressionParenKeyword") stack.push({
									tag: "JSNonExpressionParen",
									nesting: parenNesting
								});
								parenNesting++;
								postfixIncDec = false;
								break;
							case ")":
								parenNesting--;
								postfixIncDec = true;
								if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
									stack.pop();
									nextLastSignificantToken = "?NonExpressionParenEnd";
									postfixIncDec = false;
								}
								break;
							case "{":
								Punctuator$1.lastIndex = 0;
								isExpression = !TokensNotPrecedingObjectLiteral$1.test(lastSignificantToken) && (TokensPrecedingExpression$1.test(lastSignificantToken) || KeywordsWithExpressionAfter$1.test(lastSignificantToken));
								braces.push(isExpression);
								postfixIncDec = false;
								break;
							case "}":
								switch (mode.tag) {
									case "InterpolationInTemplate":
										if (braces.length === mode.nesting) {
											Template$1.lastIndex = lastIndex;
											match = Template$1.exec(input);
											lastIndex = Template$1.lastIndex;
											lastSignificantToken = match[0];
											if (match[1] === "${") {
												lastSignificantToken = "?InterpolationInTemplate";
												postfixIncDec = false;
												yield {
													type: "TemplateMiddle",
													value: match[0]
												};
											} else {
												stack.pop();
												postfixIncDec = true;
												yield {
													type: "TemplateTail",
													value: match[0],
													closed: match[1] === "`"
												};
											}
											continue;
										}
										break;
									case "InterpolationInJSX": if (braces.length === mode.nesting) {
										stack.pop();
										lastIndex += 1;
										lastSignificantToken = "}";
										yield {
											type: "JSXPunctuator",
											value: "}"
										};
										continue;
									}
								}
								postfixIncDec = braces.pop();
								nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
								break;
							case "]":
								postfixIncDec = true;
								break;
							case "++":
							case "--":
								nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
								break;
							case "<":
								if (jsx && (TokensPrecedingExpression$1.test(lastSignificantToken) || KeywordsWithExpressionAfter$1.test(lastSignificantToken))) {
									stack.push({ tag: "JSXTag" });
									lastIndex += 1;
									lastSignificantToken = "<";
									yield {
										type: "JSXPunctuator",
										value: punctuator
									};
									continue;
								}
								postfixIncDec = false;
								break;
							default: postfixIncDec = false;
						}
						lastIndex = nextLastIndex;
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "Punctuator",
							value: punctuator
						};
						continue;
					}
					Identifier$1.lastIndex = lastIndex;
					if (match = Identifier$1.exec(input)) {
						lastIndex = Identifier$1.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "for":
							case "if":
							case "while":
							case "with": if (lastSignificantToken !== "." && lastSignificantToken !== "?.") nextLastSignificantToken = "?NonExpressionParenKeyword";
						}
						lastSignificantToken = nextLastSignificantToken;
						postfixIncDec = !KeywordsWithExpressionAfter$1.test(match[0]);
						yield {
							type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
							value: match[0]
						};
						continue;
					}
					StringLiteral$1.lastIndex = lastIndex;
					if (match = StringLiteral$1.exec(input)) {
						lastIndex = StringLiteral$1.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "StringLiteral",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					NumericLiteral$1.lastIndex = lastIndex;
					if (match = NumericLiteral$1.exec(input)) {
						lastIndex = NumericLiteral$1.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "NumericLiteral",
							value: match[0]
						};
						continue;
					}
					Template$1.lastIndex = lastIndex;
					if (match = Template$1.exec(input)) {
						lastIndex = Template$1.lastIndex;
						lastSignificantToken = match[0];
						if (match[1] === "${") {
							lastSignificantToken = "?InterpolationInTemplate";
							stack.push({
								tag: "InterpolationInTemplate",
								nesting: braces.length
							});
							postfixIncDec = false;
							yield {
								type: "TemplateHead",
								value: match[0]
							};
						} else {
							postfixIncDec = true;
							yield {
								type: "NoSubstitutionTemplate",
								value: match[0],
								closed: match[1] === "`"
							};
						}
						continue;
					}
					break;
				case "JSXTag":
				case "JSXTagEnd":
					JSXPunctuator$1.lastIndex = lastIndex;
					if (match = JSXPunctuator$1.exec(input)) {
						lastIndex = JSXPunctuator$1.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "<":
								stack.push({ tag: "JSXTag" });
								break;
							case ">":
								stack.pop();
								if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
									nextLastSignificantToken = "?JSX";
									postfixIncDec = true;
								} else stack.push({ tag: "JSXChildren" });
								break;
							case "{":
								stack.push({
									tag: "InterpolationInJSX",
									nesting: braces.length
								});
								nextLastSignificantToken = "?InterpolationInJSX";
								postfixIncDec = false;
								break;
							case "/": if (lastSignificantToken === "<") {
								stack.pop();
								if (stack[stack.length - 1].tag === "JSXChildren") stack.pop();
								stack.push({ tag: "JSXTagEnd" });
							}
						}
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "JSXPunctuator",
							value: match[0]
						};
						continue;
					}
					JSXIdentifier$1.lastIndex = lastIndex;
					if (match = JSXIdentifier$1.exec(input)) {
						lastIndex = JSXIdentifier$1.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXIdentifier",
							value: match[0]
						};
						continue;
					}
					JSXString$1.lastIndex = lastIndex;
					if (match = JSXString$1.exec(input)) {
						lastIndex = JSXString$1.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXString",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					break;
				case "JSXChildren":
					JSXText$1.lastIndex = lastIndex;
					if (match = JSXText$1.exec(input)) {
						lastIndex = JSXText$1.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXText",
							value: match[0]
						};
						continue;
					}
					switch (input[lastIndex]) {
						case "<":
							stack.push({ tag: "JSXTag" });
							lastIndex++;
							lastSignificantToken = "<";
							yield {
								type: "JSXPunctuator",
								value: "<"
							};
							continue;
						case "{":
							stack.push({
								tag: "InterpolationInJSX",
								nesting: braces.length
							});
							lastIndex++;
							lastSignificantToken = "?InterpolationInJSX";
							postfixIncDec = false;
							yield {
								type: "JSXPunctuator",
								value: "{"
							};
							continue;
					}
			}
			WhiteSpace$1.lastIndex = lastIndex;
			if (match = WhiteSpace$1.exec(input)) {
				lastIndex = WhiteSpace$1.lastIndex;
				yield {
					type: "WhiteSpace",
					value: match[0]
				};
				continue;
			}
			LineTerminatorSequence$1.lastIndex = lastIndex;
			if (match = LineTerminatorSequence$1.exec(input)) {
				lastIndex = LineTerminatorSequence$1.lastIndex;
				postfixIncDec = false;
				if (KeywordsWithNoLineTerminatorAfter$1.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				yield {
					type: "LineTerminatorSequence",
					value: match[0]
				};
				continue;
			}
			MultiLineComment$1.lastIndex = lastIndex;
			if (match = MultiLineComment$1.exec(input)) {
				lastIndex = MultiLineComment$1.lastIndex;
				if (Newline$1.test(match[0])) {
					postfixIncDec = false;
					if (KeywordsWithNoLineTerminatorAfter$1.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				}
				yield {
					type: "MultiLineComment",
					value: match[0],
					closed: match[1] !== void 0
				};
				continue;
			}
			SingleLineComment$1.lastIndex = lastIndex;
			if (match = SingleLineComment$1.exec(input)) {
				lastIndex = SingleLineComment$1.lastIndex;
				postfixIncDec = false;
				yield {
					type: "SingleLineComment",
					value: match[0]
				};
				continue;
			}
			firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
			lastIndex += firstCodePoint.length;
			lastSignificantToken = firstCodePoint;
			postfixIncDec = false;
			yield {
				type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
				value: firstCodePoint
			};
		}
	};
	return jsTokens_1$1;
}
var jsTokensExports = requireJsTokens$1();
var reservedWords$1 = {
	keyword: [
		"break",
		"case",
		"catch",
		"continue",
		"debugger",
		"default",
		"do",
		"else",
		"finally",
		"for",
		"function",
		"if",
		"return",
		"switch",
		"throw",
		"try",
		"var",
		"const",
		"while",
		"with",
		"new",
		"this",
		"super",
		"class",
		"extends",
		"export",
		"import",
		"null",
		"true",
		"false",
		"in",
		"instanceof",
		"typeof",
		"void",
		"delete"
	],
	strict: [
		"implements",
		"interface",
		"let",
		"package",
		"private",
		"protected",
		"public",
		"static",
		"yield"
	]
}, keywords = new Set(reservedWords$1.keyword), reservedWordsStrictSet = new Set(reservedWords$1.strict), sometimesKeywords = /* @__PURE__ */ new Set([
	"as",
	"async",
	"from",
	"get",
	"of",
	"set"
]);
const SAFE_TIMERS_SYMBOL = Symbol("vitest:SAFE_TIMERS");
function getSafeTimers() {
	const { setTimeout: safeSetTimeout, setInterval: safeSetInterval, clearInterval: safeClearInterval, clearTimeout: safeClearTimeout, setImmediate: safeSetImmediate, clearImmediate: safeClearImmediate, queueMicrotask: safeQueueMicrotask } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis;
	const { nextTick: safeNextTick } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis.process || { nextTick: (cb) => cb() };
	return {
		nextTick: safeNextTick,
		setTimeout: safeSetTimeout,
		setInterval: safeSetInterval,
		clearInterval: safeClearInterval,
		clearTimeout: safeClearTimeout,
		setImmediate: safeSetImmediate,
		clearImmediate: safeClearImmediate,
		queueMicrotask: safeQueueMicrotask
	};
}

//#endregion
//#region node_modules/.pnpm/@vitest+utils@3.2.4/node_modules/@vitest/utils/dist/diff.js
/**
* Diff Match and Patch
* Copyright 2018 The diff-match-patch Authors.
* https://github.com/google/diff-match-patch
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @fileoverview Computes the difference between two texts to create a patch.
* Applies the patch onto another text, allowing for errors.
* @author fraser@google.com (Neil Fraser)
*/
/**
* CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:
*
* 1. Delete anything not needed to use diff_cleanupSemantic method
* 2. Convert from prototype properties to var declarations
* 3. Convert Diff to class from constructor and prototype
* 4. Add type annotations for arguments and return values
* 5. Add exports
*/
/**
* The data structure representing a diff is an array of tuples:
* [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
* which means: delete 'Hello', add 'Goodbye' and keep ' world.'
*/
const DIFF_DELETE = -1;
const DIFF_INSERT = 1;
const DIFF_EQUAL = 0;
/**
* Class representing one diff tuple.
* Attempts to look like a two-element array (which is what this used to be).
* @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
* @param {string} text Text to be deleted, inserted, or retained.
* @constructor
*/
var Diff = class {
	0;
	1;
	constructor(op, text) {
		this[0] = op;
		this[1] = text;
	}
};
/**
* Determine the common prefix of two strings.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the start of each
*     string.
*/
function diff_commonPrefix(text1, text2) {
	if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) return 0;
	let pointermin = 0;
	let pointermax = Math.min(text1.length, text2.length);
	let pointermid = pointermax;
	let pointerstart = 0;
	while (pointermin < pointermid) {
		if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
			pointermin = pointermid;
			pointerstart = pointermin;
		} else pointermax = pointermid;
		pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	}
	return pointermid;
}
/**
* Determine the common suffix of two strings.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the end of each string.
*/
function diff_commonSuffix(text1, text2) {
	if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) return 0;
	let pointermin = 0;
	let pointermax = Math.min(text1.length, text2.length);
	let pointermid = pointermax;
	let pointerend = 0;
	while (pointermin < pointermid) {
		if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
			pointermin = pointermid;
			pointerend = pointermin;
		} else pointermax = pointermid;
		pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	}
	return pointermid;
}
/**
* Determine if the suffix of one string is the prefix of another.
* @param {string} text1 First string.
* @param {string} text2 Second string.
* @return {number} The number of characters common to the end of the first
*     string and the start of the second string.
* @private
*/
function diff_commonOverlap_(text1, text2) {
	const text1_length = text1.length;
	const text2_length = text2.length;
	if (text1_length === 0 || text2_length === 0) return 0;
	if (text1_length > text2_length) text1 = text1.substring(text1_length - text2_length);
	else if (text1_length < text2_length) text2 = text2.substring(0, text1_length);
	const text_length = Math.min(text1_length, text2_length);
	if (text1 === text2) return text_length;
	let best = 0;
	let length = 1;
	while (true) {
		const pattern = text1.substring(text_length - length);
		const found$1 = text2.indexOf(pattern);
		if (found$1 === -1) return best;
		length += found$1;
		if (found$1 === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
			best = length;
			length++;
		}
	}
}
/**
* Reduce the number of edits by eliminating semantically trivial equalities.
* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
*/
function diff_cleanupSemantic(diffs) {
	let changes = false;
	const equalities = [];
	let equalitiesLength = 0;
	/** @type {?string} */
	let lastEquality = null;
	let pointer = 0;
	let length_insertions1 = 0;
	let length_deletions1 = 0;
	let length_insertions2 = 0;
	let length_deletions2 = 0;
	while (pointer < diffs.length) {
		if (diffs[pointer][0] === DIFF_EQUAL) {
			equalities[equalitiesLength++] = pointer;
			length_insertions1 = length_insertions2;
			length_deletions1 = length_deletions2;
			length_insertions2 = 0;
			length_deletions2 = 0;
			lastEquality = diffs[pointer][1];
		} else {
			if (diffs[pointer][0] === DIFF_INSERT) length_insertions2 += diffs[pointer][1].length;
			else length_deletions2 += diffs[pointer][1].length;
			if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
				diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
				diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
				equalitiesLength--;
				equalitiesLength--;
				pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
				length_insertions1 = 0;
				length_deletions1 = 0;
				length_insertions2 = 0;
				length_deletions2 = 0;
				lastEquality = null;
				changes = true;
			}
		}
		pointer++;
	}
	if (changes) diff_cleanupMerge(diffs);
	diff_cleanupSemanticLossless(diffs);
	pointer = 1;
	while (pointer < diffs.length) {
		if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
			const deletion = diffs[pointer - 1][1];
			const insertion = diffs[pointer][1];
			const overlap_length1 = diff_commonOverlap_(deletion, insertion);
			const overlap_length2 = diff_commonOverlap_(insertion, deletion);
			if (overlap_length1 >= overlap_length2) {
				if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
					diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
					diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
					diffs[pointer + 1][1] = insertion.substring(overlap_length1);
					pointer++;
				}
			} else if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
				diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
				diffs[pointer - 1][0] = DIFF_INSERT;
				diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
				diffs[pointer + 1][0] = DIFF_DELETE;
				diffs[pointer + 1][1] = deletion.substring(overlap_length2);
				pointer++;
			}
			pointer++;
		}
		pointer++;
	}
}
const nonAlphaNumericRegex_ = /[^a-z0-9]/i;
const whitespaceRegex_ = /\s/;
const linebreakRegex_ = /[\r\n]/;
const blanklineEndRegex_ = /\n\r?\n$/;
const blanklineStartRegex_ = /^\r?\n\r?\n/;
/**
* Look for single edits surrounded on both sides by equalities
* which can be shifted sideways to align the edit to a word boundary.
* e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
*/
function diff_cleanupSemanticLossless(diffs) {
	let pointer = 1;
	while (pointer < diffs.length - 1) {
		if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
			let equality1 = diffs[pointer - 1][1];
			let edit = diffs[pointer][1];
			let equality2 = diffs[pointer + 1][1];
			const commonOffset = diff_commonSuffix(equality1, edit);
			if (commonOffset) {
				const commonString = edit.substring(edit.length - commonOffset);
				equality1 = equality1.substring(0, equality1.length - commonOffset);
				edit = commonString + edit.substring(0, edit.length - commonOffset);
				equality2 = commonString + equality2;
			}
			let bestEquality1 = equality1;
			let bestEdit = edit;
			let bestEquality2 = equality2;
			let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
			while (edit.charAt(0) === equality2.charAt(0)) {
				equality1 += edit.charAt(0);
				edit = edit.substring(1) + equality2.charAt(0);
				equality2 = equality2.substring(1);
				const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
				if (score >= bestScore) {
					bestScore = score;
					bestEquality1 = equality1;
					bestEdit = edit;
					bestEquality2 = equality2;
				}
			}
			if (diffs[pointer - 1][1] !== bestEquality1) {
				if (bestEquality1) diffs[pointer - 1][1] = bestEquality1;
				else {
					diffs.splice(pointer - 1, 1);
					pointer--;
				}
				diffs[pointer][1] = bestEdit;
				if (bestEquality2) diffs[pointer + 1][1] = bestEquality2;
				else {
					diffs.splice(pointer + 1, 1);
					pointer--;
				}
			}
		}
		pointer++;
	}
}
/**
* Reorder and merge like edit sections.  Merge equalities.
* Any edit section can move as long as it doesn't cross an equality.
* @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
*/
function diff_cleanupMerge(diffs) {
	diffs.push(new Diff(DIFF_EQUAL, ""));
	let pointer = 0;
	let count_delete = 0;
	let count_insert = 0;
	let text_delete = "";
	let text_insert = "";
	let commonlength;
	while (pointer < diffs.length) switch (diffs[pointer][0]) {
		case DIFF_INSERT:
			count_insert++;
			text_insert += diffs[pointer][1];
			pointer++;
			break;
		case DIFF_DELETE:
			count_delete++;
			text_delete += diffs[pointer][1];
			pointer++;
			break;
		case DIFF_EQUAL:
			if (count_delete + count_insert > 1) {
				if (count_delete !== 0 && count_insert !== 0) {
					commonlength = diff_commonPrefix(text_insert, text_delete);
					if (commonlength !== 0) {
						if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
						else {
							diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
							pointer++;
						}
						text_insert = text_insert.substring(commonlength);
						text_delete = text_delete.substring(commonlength);
					}
					commonlength = diff_commonSuffix(text_insert, text_delete);
					if (commonlength !== 0) {
						diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
						text_insert = text_insert.substring(0, text_insert.length - commonlength);
						text_delete = text_delete.substring(0, text_delete.length - commonlength);
					}
				}
				pointer -= count_delete + count_insert;
				diffs.splice(pointer, count_delete + count_insert);
				if (text_delete.length) {
					diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
					pointer++;
				}
				if (text_insert.length) {
					diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
					pointer++;
				}
				pointer++;
			} else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
				diffs[pointer - 1][1] += diffs[pointer][1];
				diffs.splice(pointer, 1);
			} else pointer++;
			count_insert = 0;
			count_delete = 0;
			text_delete = "";
			text_insert = "";
			break;
	}
	if (diffs[diffs.length - 1][1] === "") diffs.pop();
	let changes = false;
	pointer = 1;
	while (pointer < diffs.length - 1) {
		if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
			if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
				diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
				diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
				diffs.splice(pointer - 1, 1);
				changes = true;
			} else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
				diffs[pointer - 1][1] += diffs[pointer + 1][1];
				diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
				diffs.splice(pointer + 1, 1);
				changes = true;
			}
		}
		pointer++;
	}
	if (changes) diff_cleanupMerge(diffs);
}
/**
* Given two strings, compute a score representing whether the internal
* boundary falls on logical boundaries.
* Scores range from 6 (best) to 0 (worst).
* Closure, but does not reference any external variables.
* @param {string} one First string.
* @param {string} two Second string.
* @return {number} The score.
* @private
*/
function diff_cleanupSemanticScore_(one, two) {
	if (!one || !two) return 6;
	const char1 = one.charAt(one.length - 1);
	const char2 = two.charAt(0);
	const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
	const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
	const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
	const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
	const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
	const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
	const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
	const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
	if (blankLine1 || blankLine2) return 5;
	else if (lineBreak1 || lineBreak2) return 4;
	else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) return 3;
	else if (whitespace1 || whitespace2) return 2;
	else if (nonAlphaNumeric1 || nonAlphaNumeric2) return 1;
	return 0;
}
/**
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
const NO_DIFF_MESSAGE = "Compared values have no visual difference.";
const SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
	if (hasRequiredBuild) return build;
	hasRequiredBuild = 1;
	Object.defineProperty(build, "__esModule", { value: true });
	build.default = diffSequence;
	/**
	* Copyright (c) Meta Platforms, Inc. and affiliates.
	*
	* This source code is licensed under the MIT license found in the
	* LICENSE file in the root directory of this source tree.
	*
	*/
	const pkg = "diff-sequences";
	const NOT_YET_SET = 0;
	const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
		let nCommon = 0;
		while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
			aIndex += 1;
			bIndex += 1;
			nCommon += 1;
		}
		return nCommon;
	};
	const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
		let nCommon = 0;
		while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
			aIndex -= 1;
			bIndex -= 1;
			nCommon += 1;
		}
		return nCommon;
	};
	const extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
		let iF = 0;
		let kF = -d;
		let aFirst = aIndexesF[iF];
		let aIndexPrev1 = aFirst;
		aIndexesF[iF] += countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
		const nF = d < iMaxF ? d : iMaxF;
		for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
			if (iF !== d && aIndexPrev1 < aIndexesF[iF]) aFirst = aIndexesF[iF];
			else {
				aFirst = aIndexPrev1 + 1;
				if (aEnd <= aFirst) return iF - 1;
			}
			aIndexPrev1 = aIndexesF[iF];
			aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
		}
		return iMaxF;
	};
	const extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
		let iR = 0;
		let kR = d;
		let aFirst = aIndexesR[iR];
		let aIndexPrev1 = aFirst;
		aIndexesR[iR] -= countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
		const nR = d < iMaxR ? d : iMaxR;
		for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
			if (iR !== d && aIndexesR[iR] < aIndexPrev1) aFirst = aIndexesR[iR];
			else {
				aFirst = aIndexPrev1 - 1;
				if (aFirst < aStart) return iR - 1;
			}
			aIndexPrev1 = aIndexesR[iR];
			aIndexesR[iR] = aFirst - countCommonItemsR(aStart, aFirst - 1, bStart, bR + aFirst - kR - 1, isCommon);
		}
		return iMaxR;
	};
	const extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
		const bF = bStart - aStart;
		const aLength = aEnd - aStart;
		const baDeltaLength = bEnd - bStart - aLength;
		const kMinOverlapF = -baDeltaLength - (d - 1);
		const kMaxOverlapF = -baDeltaLength + (d - 1);
		let aIndexPrev1 = NOT_YET_SET;
		const nF = d < iMaxF ? d : iMaxF;
		for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
			const insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF];
			const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
			const aFirst = insert ? aLastPrev : aLastPrev + 1;
			const bFirst = bF + aFirst - kF;
			const nCommonF = countCommonItemsF(aFirst + 1, aEnd, bFirst + 1, bEnd, isCommon);
			const aLast = aFirst + nCommonF;
			aIndexPrev1 = aIndexesF[iF];
			aIndexesF[iF] = aLast;
			if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
				const iR = (d - 1 - (kF + baDeltaLength)) / 2;
				if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
					const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
					const nCommonR = countCommonItemsR(aStart, aLastPrev, bStart, bLastPrev, isCommon);
					const aIndexPrevFirst = aLastPrev - nCommonR;
					const bIndexPrevFirst = bLastPrev - nCommonR;
					const aEndPreceding = aIndexPrevFirst + 1;
					const bEndPreceding = bIndexPrevFirst + 1;
					division.nChangePreceding = d - 1;
					if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
						division.aEndPreceding = aStart;
						division.bEndPreceding = bStart;
					} else {
						division.aEndPreceding = aEndPreceding;
						division.bEndPreceding = bEndPreceding;
					}
					division.nCommonPreceding = nCommonR;
					if (nCommonR !== 0) {
						division.aCommonPreceding = aEndPreceding;
						division.bCommonPreceding = bEndPreceding;
					}
					division.nCommonFollowing = nCommonF;
					if (nCommonF !== 0) {
						division.aCommonFollowing = aFirst + 1;
						division.bCommonFollowing = bFirst + 1;
					}
					const aStartFollowing = aLast + 1;
					const bStartFollowing = bFirst + nCommonF + 1;
					division.nChangeFollowing = d - 1;
					if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
						division.aStartFollowing = aEnd;
						division.bStartFollowing = bEnd;
					} else {
						division.aStartFollowing = aStartFollowing;
						division.bStartFollowing = bStartFollowing;
					}
					return true;
				}
			}
		}
		return false;
	};
	const extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
		const bR = bEnd - aEnd;
		const aLength = aEnd - aStart;
		const baDeltaLength = bEnd - bStart - aLength;
		const kMinOverlapR = baDeltaLength - d;
		const kMaxOverlapR = baDeltaLength + d;
		let aIndexPrev1 = NOT_YET_SET;
		const nR = d < iMaxR ? d : iMaxR;
		for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
			const insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1;
			const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
			const aFirst = insert ? aLastPrev : aLastPrev - 1;
			const bFirst = bR + aFirst - kR;
			const nCommonR = countCommonItemsR(aStart, aFirst - 1, bStart, bFirst - 1, isCommon);
			const aLast = aFirst - nCommonR;
			aIndexPrev1 = aIndexesR[iR];
			aIndexesR[iR] = aLast;
			if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
				const iF = (d + (kR - baDeltaLength)) / 2;
				if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
					const bLast = bFirst - nCommonR;
					division.nChangePreceding = d;
					if (d === aLast + bLast - aStart - bStart) {
						division.aEndPreceding = aStart;
						division.bEndPreceding = bStart;
					} else {
						division.aEndPreceding = aLast;
						division.bEndPreceding = bLast;
					}
					division.nCommonPreceding = nCommonR;
					if (nCommonR !== 0) {
						division.aCommonPreceding = aLast;
						division.bCommonPreceding = bLast;
					}
					division.nChangeFollowing = d - 1;
					if (d === 1) {
						division.nCommonFollowing = 0;
						division.aStartFollowing = aEnd;
						division.bStartFollowing = bEnd;
					} else {
						const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
						const nCommonF = countCommonItemsF(aLastPrev, aEnd, bLastPrev, bEnd, isCommon);
						division.nCommonFollowing = nCommonF;
						if (nCommonF !== 0) {
							division.aCommonFollowing = aLastPrev;
							division.bCommonFollowing = bLastPrev;
						}
						const aStartFollowing = aLastPrev + nCommonF;
						const bStartFollowing = bLastPrev + nCommonF;
						if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
							division.aStartFollowing = aEnd;
							division.bStartFollowing = bEnd;
						} else {
							division.aStartFollowing = aStartFollowing;
							division.bStartFollowing = bStartFollowing;
						}
					}
					return true;
				}
			}
		}
		return false;
	};
	const divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
		const bF = bStart - aStart;
		const bR = bEnd - aEnd;
		const aLength = aEnd - aStart;
		const bLength = bEnd - bStart;
		const baDeltaLength = bLength - aLength;
		let iMaxF = aLength;
		let iMaxR = aLength;
		aIndexesF[0] = aStart - 1;
		aIndexesR[0] = aEnd;
		if (baDeltaLength % 2 === 0) {
			const dMin = (nChange || baDeltaLength) / 2;
			const dMax = (aLength + bLength) / 2;
			for (let d = 1; d <= dMax; d += 1) {
				iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
				if (d < dMin) iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
				else if (extendOverlappablePathsR(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
			}
		} else {
			const dMin = ((nChange || baDeltaLength) + 1) / 2;
			const dMax = (aLength + bLength + 1) / 2;
			let d = 1;
			iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
			for (d += 1; d <= dMax; d += 1) {
				iMaxR = extendPathsR(d - 1, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
				if (d < dMin) iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
				else if (extendOverlappablePathsF(d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division)) return;
			}
		}
		/* istanbul ignore next */
		throw new Error(`${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`);
	};
	const findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
		if (bEnd - bStart < aEnd - aStart) {
			transposed = !transposed;
			if (transposed && callbacks.length === 1) {
				const { foundSubsequence: foundSubsequence$1, isCommon: isCommon$1 } = callbacks[0];
				callbacks[1] = {
					foundSubsequence: (nCommon, bCommon, aCommon) => {
						foundSubsequence$1(nCommon, aCommon, bCommon);
					},
					isCommon: (bIndex, aIndex) => isCommon$1(aIndex, bIndex)
				};
			}
			const tStart = aStart;
			const tEnd = aEnd;
			aStart = bStart;
			aEnd = bEnd;
			bStart = tStart;
			bEnd = tEnd;
		}
		const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
		divide(nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division);
		const { nChangePreceding, aEndPreceding, bEndPreceding, nCommonPreceding, aCommonPreceding, bCommonPreceding, nCommonFollowing, aCommonFollowing, bCommonFollowing, nChangeFollowing, aStartFollowing, bStartFollowing } = division;
		if (aStart < aEndPreceding && bStart < bEndPreceding) findSubsequences(nChangePreceding, aStart, aEndPreceding, bStart, bEndPreceding, transposed, callbacks, aIndexesF, aIndexesR, division);
		if (nCommonPreceding !== 0) foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
		if (nCommonFollowing !== 0) foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
		if (aStartFollowing < aEnd && bStartFollowing < bEnd) findSubsequences(nChangeFollowing, aStartFollowing, aEnd, bStartFollowing, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division);
	};
	const validateLength = (name, arg) => {
		if (typeof arg !== "number") throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
		if (!Number.isSafeInteger(arg)) throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
		if (arg < 0) throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
	};
	const validateCallback = (name, arg) => {
		const type$1 = typeof arg;
		if (type$1 !== "function") throw new TypeError(`${pkg}: ${name} typeof ${type$1} is not a function`);
	};
	function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
		validateLength("aLength", aLength);
		validateLength("bLength", bLength);
		validateCallback("isCommon", isCommon);
		validateCallback("foundSubsequence", foundSubsequence);
		const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
		if (nCommonF !== 0) foundSubsequence(nCommonF, 0, 0);
		if (aLength !== nCommonF || bLength !== nCommonF) {
			const aStart = nCommonF;
			const bStart = nCommonF;
			const nCommonR = countCommonItemsR(aStart, aLength - 1, bStart, bLength - 1, isCommon);
			const aEnd = aLength - nCommonR;
			const bEnd = bLength - nCommonR;
			const nCommonFR = nCommonF + nCommonR;
			if (aLength !== nCommonFR && bLength !== nCommonFR) findSubsequences(0, aStart, aEnd, bStart, bEnd, false, [{
				foundSubsequence,
				isCommon
			}], [NOT_YET_SET], [NOT_YET_SET], {
				aCommonFollowing: NOT_YET_SET,
				aCommonPreceding: NOT_YET_SET,
				aEndPreceding: NOT_YET_SET,
				aStartFollowing: NOT_YET_SET,
				bCommonFollowing: NOT_YET_SET,
				bCommonPreceding: NOT_YET_SET,
				bEndPreceding: NOT_YET_SET,
				bStartFollowing: NOT_YET_SET,
				nChangeFollowing: NOT_YET_SET,
				nChangePreceding: NOT_YET_SET,
				nCommonFollowing: NOT_YET_SET,
				nCommonPreceding: NOT_YET_SET
			});
			if (nCommonR !== 0) foundSubsequence(nCommonR, aEnd, bEnd);
		}
	}
	return build;
}
var buildExports = requireBuild();
var diffSequences = /* @__PURE__ */ getDefaultExportFromCjs$2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
	return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
	return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
	return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
	return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
	return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
	return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options) {
	const iLength = diffs.length;
	const nContextLines = options.contextLines;
	const nContextLines2 = nContextLines + nContextLines;
	let jLength = iLength;
	let hasExcessAtStartOrEnd = false;
	let nExcessesBetweenChanges = 0;
	let i = 0;
	while (i !== iLength) {
		const iStart = i;
		while (i !== iLength && diffs[i][0] === DIFF_EQUAL) i += 1;
		if (iStart !== i) if (iStart === 0) {
			if (i > nContextLines) {
				jLength -= i - nContextLines;
				hasExcessAtStartOrEnd = true;
			}
		} else if (i === iLength) {
			const n = i - iStart;
			if (n > nContextLines) {
				jLength -= n - nContextLines;
				hasExcessAtStartOrEnd = true;
			}
		} else {
			const n = i - iStart;
			if (n > nContextLines2) {
				jLength -= n - nContextLines2;
				nExcessesBetweenChanges += 1;
			}
		}
		while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) i += 1;
	}
	const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
	if (nExcessesBetweenChanges !== 0) jLength += nExcessesBetweenChanges + 1;
	else if (hasExcessAtStartOrEnd) jLength += 1;
	const jLast = jLength - 1;
	const lines = [];
	let jPatchMark = 0;
	if (hasPatch) lines.push("");
	let aStart = 0;
	let bStart = 0;
	let aEnd = 0;
	let bEnd = 0;
	const pushCommonLine = (line) => {
		const j$1 = lines.length;
		lines.push(printCommonLine(line, j$1 === 0 || j$1 === jLast, options));
		aEnd += 1;
		bEnd += 1;
	};
	const pushDeleteLine = (line) => {
		const j$1 = lines.length;
		lines.push(printDeleteLine(line, j$1 === 0 || j$1 === jLast, options));
		aEnd += 1;
	};
	const pushInsertLine = (line) => {
		const j$1 = lines.length;
		lines.push(printInsertLine(line, j$1 === 0 || j$1 === jLast, options));
		bEnd += 1;
	};
	i = 0;
	while (i !== iLength) {
		let iStart = i;
		while (i !== iLength && diffs[i][0] === DIFF_EQUAL) i += 1;
		if (iStart !== i) if (iStart === 0) {
			if (i > nContextLines) {
				iStart = i - nContextLines;
				aStart = iStart;
				bStart = iStart;
				aEnd = aStart;
				bEnd = bStart;
			}
			for (let iCommon = iStart; iCommon !== i; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
		} else if (i === iLength) {
			const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
			for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
		} else {
			const nCommon = i - iStart;
			if (nCommon > nContextLines2) {
				const iEnd = iStart + nContextLines;
				for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
				lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
				jPatchMark = lines.length;
				lines.push("");
				const nOmit = nCommon - nContextLines2;
				aStart = aEnd + nOmit;
				bStart = bEnd + nOmit;
				aEnd = aStart;
				bEnd = bStart;
				for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
			} else for (let iCommon = iStart; iCommon !== i; iCommon += 1) pushCommonLine(diffs[iCommon][1]);
		}
		while (i !== iLength && diffs[i][0] === DIFF_DELETE) {
			pushDeleteLine(diffs[i][1]);
			i += 1;
		}
		while (i !== iLength && diffs[i][0] === DIFF_INSERT) {
			pushInsertLine(diffs[i][1]);
			i += 1;
		}
	}
	if (hasPatch) lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
	return lines.join("\n");
}
function joinAlignedDiffsExpand(diffs, options) {
	return diffs.map((diff$1, i, diffs$1) => {
		const line = diff$1[1];
		const isFirstOrLast = i === 0 || i === diffs$1.length - 1;
		switch (diff$1[0]) {
			case DIFF_DELETE: return printDeleteLine(line, isFirstOrLast, options);
			case DIFF_INSERT: return printInsertLine(line, isFirstOrLast, options);
			default: return printCommonLine(line, isFirstOrLast, options);
		}
	}).join("\n");
}
const noColor = (string$1) => string$1;
const DIFF_CONTEXT_DEFAULT = 5;
const DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
	return {
		aAnnotation: "Expected",
		aColor: u.green,
		aIndicator: "-",
		bAnnotation: "Received",
		bColor: u.red,
		bIndicator: "+",
		changeColor: u.inverse,
		changeLineTrailingSpaceColor: noColor,
		commonColor: u.dim,
		commonIndicator: " ",
		commonLineTrailingSpaceColor: noColor,
		compareKeys: void 0,
		contextLines: DIFF_CONTEXT_DEFAULT,
		emptyFirstOrLastLinePlaceholder: "",
		expand: false,
		includeChangeCounts: false,
		omitAnnotationLines: false,
		patchColor: u.yellow,
		printBasicPrototype: false,
		truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
		truncateAnnotation: "... Diff result is truncated",
		truncateAnnotationColor: noColor
	};
}
function getCompareKeys(compareKeys) {
	return compareKeys && typeof compareKeys === "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
	return typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
	return {
		...getDefaultOptions(),
		...options,
		compareKeys: getCompareKeys(options.compareKeys),
		contextLines: getContextLines(options.contextLines)
	};
}
function isEmptyString(lines) {
	return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
	let a$2 = 0;
	let b$1 = 0;
	diffs.forEach((diff$1) => {
		switch (diff$1[0]) {
			case DIFF_DELETE:
				a$2 += 1;
				break;
			case DIFF_INSERT:
				b$1 += 1;
				break;
		}
	});
	return {
		a: a$2,
		b: b$1
	};
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
	if (omitAnnotationLines) return "";
	let aRest = "";
	let bRest = "";
	if (includeChangeCounts) {
		const aCount = String(changeCounts.a);
		const bCount = String(changeCounts.b);
		const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
		const aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
		const bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
		const baCountLengthDiff = bCount.length - aCount.length;
		const aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
		const bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
		aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
		bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
	}
	const a$2 = `${aIndicator} ${aAnnotation}${aRest}`;
	const b$1 = `${bIndicator} ${bAnnotation}${bRest}`;
	return `${aColor(a$2)}\n${bColor(b$1)}\n\n`;
}
function printDiffLines(diffs, truncated, options) {
	return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`\n${options.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options) {
	const normalizedOptions = normalizeDiffOptions(options);
	const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
	return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
	if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
		aLinesDisplay = [];
		aLinesCompare = [];
	}
	if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
		bLinesDisplay = [];
		bLinesCompare = [];
	}
	if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
	const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);
	let aIndex = 0;
	let bIndex = 0;
	diffs.forEach((diff$1) => {
		switch (diff$1[0]) {
			case DIFF_DELETE:
				diff$1[1] = aLinesDisplay[aIndex];
				aIndex += 1;
				break;
			case DIFF_INSERT:
				diff$1[1] = bLinesDisplay[bIndex];
				bIndex += 1;
				break;
			default:
				diff$1[1] = bLinesDisplay[bIndex];
				aIndex += 1;
				bIndex += 1;
		}
	});
	return printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
function diffLinesRaw(aLines, bLines, options) {
	const truncate$2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
	const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
	const aLength = truncate$2 ? Math.min(aLines.length, truncateThreshold) : aLines.length;
	const bLength = truncate$2 ? Math.min(bLines.length, truncateThreshold) : bLines.length;
	const truncated = aLength !== aLines.length || bLength !== bLines.length;
	const isCommon = (aIndex$1, bIndex$1) => aLines[aIndex$1] === bLines[bIndex$1];
	const diffs = [];
	let aIndex = 0;
	let bIndex = 0;
	const foundSubsequence = (nCommon, aCommon, bCommon) => {
		for (; aIndex !== aCommon; aIndex += 1) diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
		for (; bIndex !== bCommon; bIndex += 1) diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
		for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
	};
	diffSequences(aLength, bLength, isCommon, foundSubsequence);
	for (; aIndex !== aLength; aIndex += 1) diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
	for (; bIndex !== bLength; bIndex += 1) diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
	return [diffs, truncated];
}
function getType$1(value) {
	if (value === void 0) return "undefined";
	else if (value === null) return "null";
	else if (Array.isArray(value)) return "array";
	else if (typeof value === "boolean") return "boolean";
	else if (typeof value === "function") return "function";
	else if (typeof value === "number") return "number";
	else if (typeof value === "string") return "string";
	else if (typeof value === "bigint") return "bigint";
	else if (typeof value === "object") {
		if (value != null) {
			if (value.constructor === RegExp) return "regexp";
			else if (value.constructor === Map) return "map";
			else if (value.constructor === Set) return "set";
			else if (value.constructor === Date) return "date";
		}
		return "object";
	} else if (typeof value === "symbol") return "symbol";
	throw new Error(`value of unknown type: ${value}`);
}
function getNewLineSymbol(string$1) {
	return string$1.includes("\r\n") ? "\r\n" : "\n";
}
function diffStrings(a$2, b$1, options) {
	const truncate$2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
	const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
	let aLength = a$2.length;
	let bLength = b$1.length;
	if (truncate$2) {
		const aMultipleLines = a$2.includes("\n");
		const bMultipleLines = b$1.includes("\n");
		const aNewLineSymbol = getNewLineSymbol(a$2);
		const bNewLineSymbol = getNewLineSymbol(b$1);
		const _a = aMultipleLines ? `${a$2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}\n` : a$2;
		const _b = bMultipleLines ? `${b$1.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}\n` : b$1;
		aLength = _a.length;
		bLength = _b.length;
	}
	const truncated = aLength !== a$2.length || bLength !== b$1.length;
	const isCommon = (aIndex$1, bIndex$1) => a$2[aIndex$1] === b$1[bIndex$1];
	let aIndex = 0;
	let bIndex = 0;
	const diffs = [];
	const foundSubsequence = (nCommon, aCommon, bCommon) => {
		if (aIndex !== aCommon) diffs.push(new Diff(DIFF_DELETE, a$2.slice(aIndex, aCommon)));
		if (bIndex !== bCommon) diffs.push(new Diff(DIFF_INSERT, b$1.slice(bIndex, bCommon)));
		aIndex = aCommon + nCommon;
		bIndex = bCommon + nCommon;
		diffs.push(new Diff(DIFF_EQUAL, b$1.slice(bCommon, bIndex)));
	};
	diffSequences(aLength, bLength, isCommon, foundSubsequence);
	if (aIndex !== aLength) diffs.push(new Diff(DIFF_DELETE, a$2.slice(aIndex)));
	if (bIndex !== bLength) diffs.push(new Diff(DIFF_INSERT, b$1.slice(bIndex)));
	return [diffs, truncated];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
	return diffs.reduce((reduced, diff$1) => reduced + (diff$1[0] === DIFF_EQUAL ? diff$1[1] : diff$1[0] === op && diff$1[1].length !== 0 ? changeColor(diff$1[1]) : ""), "");
}
var ChangeBuffer = class {
	op;
	line;
	lines;
	changeColor;
	constructor(op, changeColor) {
		this.op = op;
		this.line = [];
		this.lines = [];
		this.changeColor = changeColor;
	}
	pushSubstring(substring) {
		this.pushDiff(new Diff(this.op, substring));
	}
	pushLine() {
		this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));
		this.line.length = 0;
	}
	isLineEmpty() {
		return this.line.length === 0;
	}
	pushDiff(diff$1) {
		this.line.push(diff$1);
	}
	align(diff$1) {
		const string$1 = diff$1[1];
		if (string$1.includes("\n")) {
			const substrings = string$1.split("\n");
			const iLast = substrings.length - 1;
			substrings.forEach((substring, i) => {
				if (i < iLast) {
					this.pushSubstring(substring);
					this.pushLine();
				} else if (substring.length !== 0) this.pushSubstring(substring);
			});
		} else this.pushDiff(diff$1);
	}
	moveLinesTo(lines) {
		if (!this.isLineEmpty()) this.pushLine();
		lines.push(...this.lines);
		this.lines.length = 0;
	}
};
var CommonBuffer = class {
	deleteBuffer;
	insertBuffer;
	lines;
	constructor(deleteBuffer, insertBuffer) {
		this.deleteBuffer = deleteBuffer;
		this.insertBuffer = insertBuffer;
		this.lines = [];
	}
	pushDiffCommonLine(diff$1) {
		this.lines.push(diff$1);
	}
	pushDiffChangeLines(diff$1) {
		const isDiffEmpty = diff$1[1].length === 0;
		if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) this.deleteBuffer.pushDiff(diff$1);
		if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) this.insertBuffer.pushDiff(diff$1);
	}
	flushChangeLines() {
		this.deleteBuffer.moveLinesTo(this.lines);
		this.insertBuffer.moveLinesTo(this.lines);
	}
	align(diff$1) {
		const op = diff$1[0];
		const string$1 = diff$1[1];
		if (string$1.includes("\n")) {
			const substrings = string$1.split("\n");
			const iLast = substrings.length - 1;
			substrings.forEach((substring, i) => {
				if (i === 0) {
					const subdiff = new Diff(op, substring);
					if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
						this.flushChangeLines();
						this.pushDiffCommonLine(subdiff);
					} else {
						this.pushDiffChangeLines(subdiff);
						this.flushChangeLines();
					}
				} else if (i < iLast) this.pushDiffCommonLine(new Diff(op, substring));
				else if (substring.length !== 0) this.pushDiffChangeLines(new Diff(op, substring));
			});
		} else this.pushDiffChangeLines(diff$1);
	}
	getLines() {
		this.flushChangeLines();
		return this.lines;
	}
};
function getAlignedDiffs(diffs, changeColor) {
	const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
	const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
	const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
	diffs.forEach((diff$1) => {
		switch (diff$1[0]) {
			case DIFF_DELETE:
				deleteBuffer.align(diff$1);
				break;
			case DIFF_INSERT:
				insertBuffer.align(diff$1);
				break;
			default: commonBuffer.align(diff$1);
		}
	});
	return commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
	if (isMultiline) {
		const iLast = diffs.length - 1;
		return diffs.some((diff$1, i) => diff$1[0] === DIFF_EQUAL && (i !== iLast || diff$1[1] !== "\n"));
	}
	return diffs.some((diff$1) => diff$1[0] === DIFF_EQUAL);
}
function diffStringsUnified(a$2, b$1, options) {
	if (a$2 !== b$1 && a$2.length !== 0 && b$1.length !== 0) {
		const isMultiline = a$2.includes("\n") || b$1.includes("\n");
		const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a$2}\n` : a$2, isMultiline ? `${b$1}\n` : b$1, true, options);
		if (hasCommonDiff(diffs, isMultiline)) {
			const optionsNormalized = normalizeDiffOptions(options);
			const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
			return printDiffLines(lines, truncated, optionsNormalized);
		}
	}
	return diffLinesUnified(a$2.split("\n"), b$1.split("\n"), options);
}
function diffStringsRaw(a$2, b$1, cleanup, options) {
	const [diffs, truncated] = diffStrings(a$2, b$1, options);
	if (cleanup) diff_cleanupSemantic(diffs);
	return [diffs, truncated];
}
function getCommonMessage(message, options) {
	const { commonColor } = normalizeDiffOptions(options);
	return commonColor(message);
}
const { AsymmetricMatcher: AsymmetricMatcher$3, DOMCollection: DOMCollection$2, DOMElement: DOMElement$2, Immutable: Immutable$2, ReactElement: ReactElement$2, ReactTestComponent: ReactTestComponent$2 } = plugins;
const PLUGINS$1 = [
	ReactTestComponent$2,
	ReactElement$2,
	DOMElement$2,
	DOMCollection$2,
	Immutable$2,
	AsymmetricMatcher$3,
	plugins.Error
];
const FORMAT_OPTIONS = {
	maxDepth: 20,
	plugins: PLUGINS$1
};
const FALLBACK_FORMAT_OPTIONS = {
	callToJSON: false,
	maxDepth: 8,
	plugins: PLUGINS$1
};
/**
* @param a Expected value
* @param b Received value
* @param options Diff options
* @returns {string | null} a string diff
*/
function diff(a$2, b$1, options) {
	if (Object.is(a$2, b$1)) return "";
	const aType = getType$1(a$2);
	let expectedType = aType;
	let omitDifference = false;
	if (aType === "object" && typeof a$2.asymmetricMatch === "function") {
		if (a$2.$$typeof !== Symbol.for("jest.asymmetricMatcher")) return;
		if (typeof a$2.getExpectedType !== "function") return;
		expectedType = a$2.getExpectedType();
		omitDifference = expectedType === "string";
	}
	if (expectedType !== getType$1(b$1)) {
		const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);
		const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
		let aDisplay = format(a$2, formatOptions);
		let bDisplay = format(b$1, formatOptions);
		const MAX_LENGTH = 1e5;
		function truncate$2(s) {
			return s.length <= MAX_LENGTH ? s : `${s.slice(0, MAX_LENGTH)}...`;
		}
		aDisplay = truncate$2(aDisplay);
		bDisplay = truncate$2(bDisplay);
		const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} \n${aDisplay}`;
		const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} \n${bDisplay}`;
		return `${aDiff}\n\n${bDiff}`;
	}
	if (omitDifference) return;
	switch (aType) {
		case "string": return diffLinesUnified(a$2.split("\n"), b$1.split("\n"), options);
		case "boolean":
		case "number": return comparePrimitive(a$2, b$1, options);
		case "map": return compareObjects(sortMap(a$2), sortMap(b$1), options);
		case "set": return compareObjects(sortSet(a$2), sortSet(b$1), options);
		default: return compareObjects(a$2, b$1, options);
	}
}
function comparePrimitive(a$2, b$1, options) {
	const aFormat = format(a$2, FORMAT_OPTIONS);
	const bFormat = format(b$1, FORMAT_OPTIONS);
	return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split("\n"), bFormat.split("\n"), options);
}
function sortMap(map$1) {
	return new Map(Array.from(map$1.entries()).sort());
}
function sortSet(set$1) {
	return new Set(Array.from(set$1.values()).sort());
}
function compareObjects(a$2, b$1, options) {
	let difference;
	let hasThrown = false;
	try {
		const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
		difference = getObjectsDifference(a$2, b$1, formatOptions, options);
	} catch {
		hasThrown = true;
	}
	const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
	if (difference === void 0 || difference === noDiffMessage) {
		const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
		difference = getObjectsDifference(a$2, b$1, formatOptions, options);
		if (difference !== noDiffMessage && !hasThrown) difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}\n\n${difference}`;
	}
	return difference;
}
function getFormatOptions(formatOptions, options) {
	const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
	return {
		...formatOptions,
		compareKeys,
		printBasicPrototype,
		maxDepth: maxDepth ?? formatOptions.maxDepth
	};
}
function getObjectsDifference(a$2, b$1, formatOptions, options) {
	const formatOptionsZeroIndent = {
		...formatOptions,
		indent: 0
	};
	const aCompare = format(a$2, formatOptionsZeroIndent);
	const bCompare = format(b$1, formatOptionsZeroIndent);
	if (aCompare === bCompare) return getCommonMessage(NO_DIFF_MESSAGE, options);
	else {
		const aDisplay = format(a$2, formatOptions);
		const bDisplay = format(b$1, formatOptions);
		return diffLinesUnified2(aDisplay.split("\n"), bDisplay.split("\n"), aCompare.split("\n"), bCompare.split("\n"), options);
	}
}
const MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
	return getType(data) === "Object" && typeof data.asymmetricMatch === "function";
}
function isReplaceable(obj1, obj2) {
	const obj1Type = getType(obj1);
	const obj2Type = getType(obj2);
	return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(received, expected, options) {
	const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
	if (typeof expected === "string" && typeof received === "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
		if (expected.includes("\n") || received.includes("\n")) return diffStringsUnified(expected, received, options);
		const [diffs] = diffStringsRaw(expected, received, true);
		const hasCommonDiff$1 = diffs.some((diff$1) => diff$1[0] === DIFF_EQUAL);
		const printLabel = getLabelPrinter(aAnnotation, bAnnotation);
		const expectedLine = printLabel(aAnnotation) + printExpected$1(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff$1));
		const receivedLine = printLabel(bAnnotation) + printReceived$1(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff$1));
		return `${expectedLine}\n${receivedLine}`;
	}
	const clonedExpected = deepClone(expected, { forceWritable: true });
	const clonedReceived = deepClone(received, { forceWritable: true });
	const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
	return diff(replacedExpected, replacedActual, options);
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
	if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== "undefined" && typeof expected.cause === "undefined") {
		delete actual.cause;
		return {
			replacedActual: actual,
			replacedExpected: expected
		};
	}
	if (!isReplaceable(actual, expected)) return {
		replacedActual: actual,
		replacedExpected: expected
	};
	if (actualReplaced.has(actual) || expectedReplaced.has(expected)) return {
		replacedActual: actual,
		replacedExpected: expected
	};
	actualReplaced.add(actual);
	expectedReplaced.add(expected);
	getOwnProperties(expected).forEach((key) => {
		const expectedValue = expected[key];
		const actualValue = actual[key];
		if (isAsymmetricMatcher(expectedValue)) {
			if (expectedValue.asymmetricMatch(actualValue)) actual[key] = expectedValue;
		} else if (isAsymmetricMatcher(actualValue)) {
			if (actualValue.asymmetricMatch(expectedValue)) expected[key] = actualValue;
		} else if (isReplaceable(actualValue, expectedValue)) {
			const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
			actual[key] = replaced.replacedActual;
			expected[key] = replaced.replacedExpected;
		}
	});
	return {
		replacedActual: actual,
		replacedExpected: expected
	};
}
function getLabelPrinter(...strings) {
	const maxLength = strings.reduce((max, string$1) => string$1.length > max ? string$1.length : max, 0);
	return (string$1) => `${string$1}: ${" ".repeat(maxLength - string$1.length)}`;
}
const SPACE_SYMBOL$1 = "·";
function replaceTrailingSpaces$1(text) {
	return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL$1.repeat(spaces.length));
}
function printReceived$1(object$1) {
	return u.red(replaceTrailingSpaces$1(stringify(object$1)));
}
function printExpected$1(value) {
	return u.green(replaceTrailingSpaces$1(stringify(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff$1) {
	return diffs.reduce((reduced, diff$1) => reduced + (diff$1[0] === DIFF_EQUAL ? diff$1[1] : diff$1[0] === op ? hasCommonDiff$1 ? u.inverse(diff$1[1]) : diff$1[1] : ""), "");
}

//#endregion
//#region node_modules/.pnpm/tinyspy@4.0.4/node_modules/tinyspy/dist/index.js
function S(e, t) {
	if (!e) throw new Error(t);
}
function f$1(e, t) {
	return typeof t === e;
}
function w(e) {
	return e instanceof Promise;
}
function u$1(e, t, r$1) {
	Object.defineProperty(e, t, r$1);
}
function l(e, t, r$1) {
	u$1(e, t, {
		value: r$1,
		configurable: !0,
		writable: !0
	});
}
var y = Symbol.for("tinyspy:spy");
var x = /* @__PURE__ */ new Set(), h$1 = (e) => {
	e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.resolves = [], e.next = [];
}, k = (e) => (u$1(e, y, { value: { reset: () => h$1(e[y]) } }), e[y]), T = (e) => e[y] || k(e);
function R(e) {
	S(f$1("function", e) || f$1("undefined", e), "cannot spy on a non-function value");
	let t = function(...s) {
		let n = T(t);
		n.called = !0, n.callCount++, n.calls.push(s);
		let d = n.next.shift();
		if (d) {
			n.results.push(d);
			let [a$2, i] = d;
			if (a$2 === "ok") return i;
			throw i;
		}
		let o, c = "ok", p$2 = n.results.length;
		if (n.impl) try {
			new.target ? o = Reflect.construct(n.impl, s, new.target) : o = n.impl.apply(this, s), c = "ok";
		} catch (a$2) {
			throw o = a$2, c = "error", n.results.push([c, a$2]), a$2;
		}
		let g = [c, o];
		return w(o) && o.then((a$2) => n.resolves[p$2] = ["ok", a$2], (a$2) => n.resolves[p$2] = ["error", a$2]), n.results.push(g), o;
	};
	l(t, "_isMockFunction", !0), l(t, "length", e ? e.length : 0), l(t, "name", e && e.name || "spy");
	let r$1 = T(t);
	return r$1.reset(), r$1.impl = e, t;
}
function v(e) {
	return !!e && e._isMockFunction === !0;
}
var b = (e, t) => {
	let r$1 = Object.getOwnPropertyDescriptor(e, t);
	if (r$1) return [e, r$1];
	let s = Object.getPrototypeOf(e);
	for (; s !== null;) {
		let n = Object.getOwnPropertyDescriptor(s, t);
		if (n) return [s, n];
		s = Object.getPrototypeOf(s);
	}
}, P = (e, t) => {
	t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
};
function M(e, t, r$1) {
	S(!f$1("undefined", e), "spyOn could not find an object to spy upon"), S(f$1("object", e) || f$1("function", e), "cannot spyOn on a primitive value");
	let [s, n] = (() => {
		if (!f$1("object", t)) return [t, "value"];
		if ("getter" in t && "setter" in t) throw new Error("cannot spy on both getter and setter");
		if ("getter" in t) return [t.getter, "get"];
		if ("setter" in t) return [t.setter, "set"];
		throw new Error("specify getter or setter to spy on");
	})(), [d, o] = b(e, s) || [];
	S(o || s in e, `${String(s)} does not exist`);
	let c = !1;
	n === "value" && o && !o.value && o.get && (n = "get", c = !0, r$1 = o.get());
	let p$2;
	o ? p$2 = o[n] : n !== "value" ? p$2 = () => e[s] : p$2 = e[s], p$2 && j(p$2) && (p$2 = p$2[y].getOriginal());
	let g = (I) => {
		let { value: F,...O } = o || {
			configurable: !0,
			writable: !0
		};
		n !== "value" && delete O.writable, O[n] = I, u$1(e, s, O);
	}, a$2 = () => {
		d !== e ? Reflect.deleteProperty(e, s) : o && !p$2 ? u$1(e, s, o) : g(p$2);
	};
	r$1 || (r$1 = p$2);
	let i = E(R(r$1), r$1);
	n === "value" && P(i, p$2);
	let m$1 = i[y];
	return l(m$1, "restore", a$2), l(m$1, "getOriginal", () => c ? p$2() : p$2), l(m$1, "willCall", (I) => (m$1.impl = I, i)), g(c ? () => (P(i, r$1), i) : i), x.add(i), i;
}
var K = /* @__PURE__ */ new Set([
	"length",
	"name",
	"prototype"
]);
function D(e) {
	let t = /* @__PURE__ */ new Set(), r$1 = {};
	for (; e && e !== Object.prototype && e !== Function.prototype;) {
		let s = [...Object.getOwnPropertyNames(e), ...Object.getOwnPropertySymbols(e)];
		for (let n of s) r$1[n] || K.has(n) || (t.add(n), r$1[n] = Object.getOwnPropertyDescriptor(e, n));
		e = Object.getPrototypeOf(e);
	}
	return {
		properties: t,
		descriptors: r$1
	};
}
function E(e, t) {
	if (!t || y in t) return e;
	let { properties: r$1, descriptors: s } = D(t);
	for (let n of r$1) {
		let d = s[n];
		b(e, n) || u$1(e, n, d);
	}
	return e;
}
function j(e) {
	return v(e) && "getOriginal" in e[y];
}

//#endregion
//#region node_modules/.pnpm/@vitest+spy@3.2.4/node_modules/@vitest/spy/dist/index.js
const mocks = /* @__PURE__ */ new Set();
function isMockFunction(fn$1) {
	return typeof fn$1 === "function" && "_isMockFunction" in fn$1 && fn$1._isMockFunction;
}
function spyOn(obj, method, accessType) {
	const objMethod = accessType ? { [{
		get: "getter",
		set: "setter"
	}[accessType]]: method } : method;
	let state;
	const descriptor = getDescriptor(obj, method);
	const fn$1 = descriptor && descriptor[accessType || "value"];
	if (isMockFunction(fn$1)) state = fn$1.mock._state();
	try {
		const stub = M(obj, objMethod);
		const spy = enhanceSpy(stub);
		if (state) spy.mock._state(state);
		return spy;
	} catch (error) {
		if (error instanceof TypeError && Symbol.toStringTag && obj[Symbol.toStringTag] === "Module" && (error.message.includes("Cannot redefine property") || error.message.includes("Cannot replace module namespace") || error.message.includes("can't redefine non-configurable property"))) throw new TypeError(`Cannot spy on export "${String(objMethod)}". Module namespace is not configurable in ESM. See: https://vitest.dev/guide/browser/#limitations`, { cause: error });
		throw error;
	}
}
let callOrder = 0;
function enhanceSpy(spy) {
	const stub = spy;
	let implementation;
	let onceImplementations = [];
	let implementationChangedTemporarily = false;
	let instances = [];
	let contexts = [];
	let invocations = [];
	const state = T(spy);
	const mockContext = {
		get calls() {
			return state.calls;
		},
		get contexts() {
			return contexts;
		},
		get instances() {
			return instances;
		},
		get invocationCallOrder() {
			return invocations;
		},
		get results() {
			return state.results.map(([callType, value]) => {
				return {
					type: callType === "error" ? "throw" : "return",
					value
				};
			});
		},
		get settledResults() {
			return state.resolves.map(([callType, value]) => {
				return {
					type: callType === "error" ? "rejected" : "fulfilled",
					value
				};
			});
		},
		get lastCall() {
			return state.calls[state.calls.length - 1];
		},
		_state(state$1) {
			if (state$1) {
				implementation = state$1.implementation;
				onceImplementations = state$1.onceImplementations;
				implementationChangedTemporarily = state$1.implementationChangedTemporarily;
			}
			return {
				implementation,
				onceImplementations,
				implementationChangedTemporarily
			};
		}
	};
	function mockCall(...args) {
		instances.push(this);
		contexts.push(this);
		invocations.push(++callOrder);
		return (implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state.getOriginal() || (() => {})).apply(this, args);
	}
	let name = stub.name;
	stub.getMockName = () => name || "vi.fn()";
	stub.mockName = (n) => {
		name = n;
		return stub;
	};
	stub.mockClear = () => {
		state.reset();
		instances = [];
		contexts = [];
		invocations = [];
		return stub;
	};
	stub.mockReset = () => {
		stub.mockClear();
		implementation = void 0;
		onceImplementations = [];
		return stub;
	};
	stub.mockRestore = () => {
		stub.mockReset();
		state.restore();
		return stub;
	};
	if (Symbol.dispose) stub[Symbol.dispose] = () => stub.mockRestore();
	stub.getMockImplementation = () => implementationChangedTemporarily ? implementation : onceImplementations.at(0) || implementation;
	stub.mockImplementation = (fn$1) => {
		implementation = fn$1;
		state.willCall(mockCall);
		return stub;
	};
	stub.mockImplementationOnce = (fn$1) => {
		onceImplementations.push(fn$1);
		return stub;
	};
	function withImplementation(fn$1, cb) {
		const originalImplementation = implementation;
		implementation = fn$1;
		state.willCall(mockCall);
		implementationChangedTemporarily = true;
		const reset = () => {
			implementation = originalImplementation;
			implementationChangedTemporarily = false;
		};
		const result = cb();
		if (typeof result === "object" && result && typeof result.then === "function") return result.then(() => {
			reset();
			return stub;
		});
		reset();
		return stub;
	}
	stub.withImplementation = withImplementation;
	stub.mockReturnThis = () => stub.mockImplementation(function() {
		return this;
	});
	stub.mockReturnValue = (val) => stub.mockImplementation(() => val);
	stub.mockReturnValueOnce = (val) => stub.mockImplementationOnce(() => val);
	stub.mockResolvedValue = (val) => stub.mockImplementation(() => Promise.resolve(val));
	stub.mockResolvedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.resolve(val));
	stub.mockRejectedValue = (val) => stub.mockImplementation(() => Promise.reject(val));
	stub.mockRejectedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.reject(val));
	Object.defineProperty(stub, "mock", { get: () => mockContext });
	state.willCall(mockCall);
	mocks.add(stub);
	return stub;
}
function fn(implementation) {
	const enhancedSpy = enhanceSpy(M({ spy: implementation || function() {} }, "spy"));
	if (implementation) enhancedSpy.mockImplementation(implementation);
	return enhancedSpy;
}
function getDescriptor(obj, method) {
	const objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
	if (objDescriptor) return objDescriptor;
	let currentProto = Object.getPrototypeOf(obj);
	while (currentProto !== null) {
		const descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
		if (descriptor) return descriptor;
		currentProto = Object.getPrototypeOf(currentProto);
	}
}

//#endregion
//#region node_modules/.pnpm/@vitest+utils@3.2.4/node_modules/@vitest/utils/dist/error.js
const IS_RECORD_SYMBOL$1 = "@@__IMMUTABLE_RECORD__@@";
const IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v$1) {
	return v$1 && (v$1[IS_COLLECTION_SYMBOL] || v$1[IS_RECORD_SYMBOL$1]);
}
const OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
	if (err instanceof Error) return `<unserializable>: ${err.message}`;
	if (typeof err === "string") return `<unserializable>: ${err}`;
	return "<unserializable>";
}
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
	if (!val || typeof val === "string") return val;
	if (val instanceof Error && "toJSON" in val && typeof val.toJSON === "function") {
		const jsonValue = val.toJSON();
		if (jsonValue && jsonValue !== val && typeof jsonValue === "object") {
			if (typeof val.message === "string") safe(() => jsonValue.message ?? (jsonValue.message = val.message));
			if (typeof val.stack === "string") safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));
			if (typeof val.name === "string") safe(() => jsonValue.name ?? (jsonValue.name = val.name));
			if (val.cause != null) safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));
		}
		return serializeValue(jsonValue, seen);
	}
	if (typeof val === "function") return `Function<${val.name || "anonymous"}>`;
	if (typeof val === "symbol") return val.toString();
	if (typeof val !== "object") return val;
	if (typeof Buffer !== "undefined" && val instanceof Buffer) return `<Buffer(${val.length}) ...>`;
	if (typeof Uint8Array !== "undefined" && val instanceof Uint8Array) return `<Uint8Array(${val.length}) ...>`;
	if (isImmutable(val)) return serializeValue(val.toJSON(), seen);
	if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") return "Promise";
	if (typeof Element !== "undefined" && val instanceof Element) return val.tagName;
	if (typeof val.asymmetricMatch === "function") return `${val.toString()} ${format$1(val.sample)}`;
	if (typeof val.toJSON === "function") return serializeValue(val.toJSON(), seen);
	if (seen.has(val)) return seen.get(val);
	if (Array.isArray(val)) {
		const clone$1 = new Array(val.length);
		seen.set(val, clone$1);
		val.forEach((e, i) => {
			try {
				clone$1[i] = serializeValue(e, seen);
			} catch (err) {
				clone$1[i] = getUnserializableMessage(err);
			}
		});
		return clone$1;
	} else {
		const clone$1 = Object.create(null);
		seen.set(val, clone$1);
		let obj = val;
		while (obj && obj !== OBJECT_PROTO) {
			Object.getOwnPropertyNames(obj).forEach((key) => {
				if (key in clone$1) return;
				try {
					clone$1[key] = serializeValue(val[key], seen);
				} catch (err) {
					delete clone$1[key];
					clone$1[key] = getUnserializableMessage(err);
				}
			});
			obj = Object.getPrototypeOf(obj);
		}
		return clone$1;
	}
}
function safe(fn$1) {
	try {
		return fn$1();
	} catch {}
}
function normalizeErrorMessage(message) {
	return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
	if (!_err || typeof _err !== "object") return { message: String(_err) };
	const err = _err;
	if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) err.diff = printDiffOrStringify(err.actual, err.expected, {
		...diffOptions,
		...err.diffOptions
	});
	if ("expected" in err && typeof err.expected !== "string") err.expected = stringify(err.expected, 10);
	if ("actual" in err && typeof err.actual !== "string") err.actual = stringify(err.actual, 10);
	try {
		if (typeof err.message === "string") err.message = normalizeErrorMessage(err.message);
	} catch {}
	try {
		if (!seen.has(err) && typeof err.cause === "object") {
			seen.add(err);
			err.cause = processError(err.cause, diffOptions, seen);
		}
	} catch {}
	try {
		return serializeValue(err);
	} catch (e) {
		return serializeValue(/* @__PURE__ */ new Error(`Failed to fully serialize error: ${e === null || e === void 0 ? void 0 : e.message}\nInner error message: ${err === null || err === void 0 ? void 0 : err.message}`));
	}
}

//#endregion
//#region node_modules/.pnpm/chai@5.3.3/node_modules/chai/index.js
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", {
	value,
	configurable: true
});
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
};
var utils_exports = {};
__export(utils_exports, {
	addChainableMethod: () => addChainableMethod,
	addLengthGuard: () => addLengthGuard,
	addMethod: () => addMethod,
	addProperty: () => addProperty,
	checkError: () => check_error_exports,
	compareByInspect: () => compareByInspect,
	eql: () => deep_eql_default,
	expectTypes: () => expectTypes,
	flag: () => flag,
	getActual: () => getActual,
	getMessage: () => getMessage2,
	getName: () => getName,
	getOperator: () => getOperator,
	getOwnEnumerableProperties: () => getOwnEnumerableProperties,
	getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
	getPathInfo: () => getPathInfo,
	hasProperty: () => hasProperty,
	inspect: () => inspect2,
	isNaN: () => isNaN2,
	isNumeric: () => isNumeric,
	isProxyEnabled: () => isProxyEnabled,
	isRegExp: () => isRegExp2,
	objDisplay: () => objDisplay$1,
	overwriteChainableMethod: () => overwriteChainableMethod,
	overwriteMethod: () => overwriteMethod,
	overwriteProperty: () => overwriteProperty,
	proxify: () => proxify,
	test: () => test$2,
	transferFlags: () => transferFlags,
	type: () => type
});
var check_error_exports = {};
__export(check_error_exports, {
	compatibleConstructor: () => compatibleConstructor,
	compatibleInstance: () => compatibleInstance,
	compatibleMessage: () => compatibleMessage,
	getConstructorName: () => getConstructorName,
	getMessage: () => getMessage
});
function isErrorInstance(obj) {
	return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
	return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
	return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
	if (isErrorInstance(errorLike)) return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
	else if ((typeof errorLike === "object" || typeof errorLike === "function") && errorLike.prototype) return thrown.constructor === errorLike || thrown instanceof errorLike;
	return false;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
	const comparisonString = typeof thrown === "string" ? thrown : thrown.message;
	if (isRegExp(errMatcher)) return errMatcher.test(comparisonString);
	else if (typeof errMatcher === "string") return comparisonString.indexOf(errMatcher) !== -1;
	return false;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName(errorLike) {
	let constructorName = errorLike;
	if (isErrorInstance(errorLike)) constructorName = errorLike.constructor.name;
	else if (typeof errorLike === "function") {
		constructorName = errorLike.name;
		if (constructorName === "") constructorName = new errorLike().name || constructorName;
	}
	return constructorName;
}
__name(getConstructorName, "getConstructorName");
function getMessage(errorLike) {
	let msg = "";
	if (errorLike && errorLike.message) msg = errorLike.message;
	else if (typeof errorLike === "string") msg = errorLike;
	return msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value) {
	let flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
	if (arguments.length === 3) flags[key] = value;
	else return flags[key];
}
__name(flag, "flag");
function test$2(obj, args) {
	let negate = flag(obj, "negate"), expr = args[0];
	return negate ? !expr : expr;
}
__name(test$2, "test");
function type(obj) {
	if (typeof obj === "undefined") return "undefined";
	if (obj === null) return "null";
	const stringTag = obj[Symbol.toStringTag];
	if (typeof stringTag === "string") return stringTag;
	return Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type, "type");
var canElideFrames = "captureStackTrace" in Error;
var AssertionError = class _AssertionError extends Error {
	static {
		__name(this, "AssertionError");
	}
	message;
	get name() {
		return "AssertionError";
	}
	get ok() {
		return false;
	}
	constructor(message = "Unspecified AssertionError", props, ssf) {
		super(message);
		this.message = message;
		if (canElideFrames) Error.captureStackTrace(this, ssf || _AssertionError);
		for (const key in props) if (!(key in this)) this[key] = props[key];
	}
	toJSON(stack) {
		return {
			...this,
			name: this.name,
			message: this.message,
			ok: false,
			stack: stack !== false ? this.stack : void 0
		};
	}
};
function expectTypes(obj, types) {
	let flagMsg = flag(obj, "message");
	let ssfi = flag(obj, "ssfi");
	flagMsg = flagMsg ? flagMsg + ": " : "";
	obj = flag(obj, "object");
	types = types.map(function(t) {
		return t.toLowerCase();
	});
	types.sort();
	let str = types.map(function(t, index) {
		let art = ~[
			"a",
			"e",
			"i",
			"o",
			"u"
		].indexOf(t.charAt(0)) ? "an" : "a";
		return (types.length > 1 && index === types.length - 1 ? "or " : "") + art + " " + t;
	}).join(", ");
	let objType = type(obj).toLowerCase();
	if (!types.some(function(expected) {
		return objType === expected;
	})) throw new AssertionError(flagMsg + "object tested must be " + str + ", but " + objType + " given", void 0, ssfi);
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
	return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors = {
	bold: ["1", "22"],
	dim: ["2", "22"],
	italic: ["3", "23"],
	underline: ["4", "24"],
	inverse: ["7", "27"],
	hidden: ["8", "28"],
	strike: ["9", "29"],
	black: ["30", "39"],
	red: ["31", "39"],
	green: ["32", "39"],
	yellow: ["33", "39"],
	blue: ["34", "39"],
	magenta: ["35", "39"],
	cyan: ["36", "39"],
	white: ["37", "39"],
	brightblack: ["30;1", "39"],
	brightred: ["31;1", "39"],
	brightgreen: ["32;1", "39"],
	brightyellow: ["33;1", "39"],
	brightblue: ["34;1", "39"],
	brightmagenta: ["35;1", "39"],
	brightcyan: ["36;1", "39"],
	brightwhite: ["37;1", "39"],
	grey: ["90", "39"]
};
var styles = {
	special: "cyan",
	number: "yellow",
	bigint: "yellow",
	boolean: "yellow",
	undefined: "grey",
	null: "bold",
	string: "green",
	symbol: "green",
	date: "magenta",
	regexp: "red"
};
var truncator = "…";
function colorise(value, styleType) {
	const color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
	if (!color) return String(value);
	return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
}
__name(colorise, "colorise");
function normaliseOptions({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = Infinity, breakLength = Infinity, seen = [], truncate: truncate2 = Infinity, stylize = String } = {}, inspect3) {
	const options = {
		showHidden: Boolean(showHidden),
		depth: Number(depth),
		colors: Boolean(colors),
		customInspect: Boolean(customInspect),
		showProxy: Boolean(showProxy),
		maxArrayLength: Number(maxArrayLength),
		breakLength: Number(breakLength),
		truncate: Number(truncate2),
		seen,
		inspect: inspect3,
		stylize
	};
	if (options.colors) options.stylize = colorise;
	return options;
}
__name(normaliseOptions, "normaliseOptions");
function isHighSurrogate(char) {
	return char >= "\ud800" && char <= "\udbff";
}
__name(isHighSurrogate, "isHighSurrogate");
function truncate(string$1, length, tail = truncator) {
	string$1 = String(string$1);
	const tailLength = tail.length;
	const stringLength = string$1.length;
	if (tailLength > length && stringLength > tailLength) return tail;
	if (stringLength > length && stringLength > tailLength) {
		let end = length - tailLength;
		if (end > 0 && isHighSurrogate(string$1[end - 1])) end = end - 1;
		return `${string$1.slice(0, end)}${tail}`;
	}
	return string$1;
}
__name(truncate, "truncate");
function inspectList(list, options, inspectItem, separator = ", ") {
	inspectItem = inspectItem || options.inspect;
	const size = list.length;
	if (size === 0) return "";
	const originalLength = options.truncate;
	let output = "";
	let peek = "";
	let truncated = "";
	for (let i = 0; i < size; i += 1) {
		const last = i + 1 === list.length;
		const secondToLast = i + 2 === list.length;
		truncated = `${truncator}(${list.length - i})`;
		const value = list[i];
		options.truncate = originalLength - output.length - (last ? 0 : separator.length);
		const string$1 = peek || inspectItem(value, options) + (last ? "" : separator);
		const nextLength = output.length + string$1.length;
		const truncatedLength = nextLength + truncated.length;
		if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) break;
		if (!last && !secondToLast && truncatedLength > originalLength) break;
		peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);
		if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) break;
		output += string$1;
		if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
			truncated = `${truncator}(${list.length - i - 1})`;
			break;
		}
		truncated = "";
	}
	return `${output}${truncated}`;
}
__name(inspectList, "inspectList");
function quoteComplexKey(key) {
	if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) return key;
	return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, "\"").replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey, "quoteComplexKey");
function inspectProperty([key, value], options) {
	options.truncate -= 2;
	if (typeof key === "string") key = quoteComplexKey(key);
	else if (typeof key !== "number") key = `[${options.inspect(key, options)}]`;
	options.truncate -= key.length;
	value = options.inspect(value, options);
	return `${key}: ${value}`;
}
__name(inspectProperty, "inspectProperty");
function inspectArray(array$1, options) {
	const nonIndexProperties = Object.keys(array$1).slice(array$1.length);
	if (!array$1.length && !nonIndexProperties.length) return "[]";
	options.truncate -= 4;
	const listContents = inspectList(array$1, options);
	options.truncate -= listContents.length;
	let propertyContents = "";
	if (nonIndexProperties.length) propertyContents = inspectList(nonIndexProperties.map((key) => [key, array$1[key]]), options, inspectProperty);
	return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray, "inspectArray");
var getArrayName = /* @__PURE__ */ __name((array$1) => {
	if (typeof Buffer === "function" && array$1 instanceof Buffer) return "Buffer";
	if (array$1[Symbol.toStringTag]) return array$1[Symbol.toStringTag];
	return array$1.constructor.name;
}, "getArrayName");
function inspectTypedArray(array$1, options) {
	const name = getArrayName(array$1);
	options.truncate -= name.length + 4;
	const nonIndexProperties = Object.keys(array$1).slice(array$1.length);
	if (!array$1.length && !nonIndexProperties.length) return `${name}[]`;
	let output = "";
	for (let i = 0; i < array$1.length; i++) {
		const string$1 = `${options.stylize(truncate(array$1[i], options.truncate), "number")}${i === array$1.length - 1 ? "" : ", "}`;
		options.truncate -= string$1.length;
		if (array$1[i] !== array$1.length && options.truncate <= 3) {
			output += `${truncator}(${array$1.length - array$1[i] + 1})`;
			break;
		}
		output += string$1;
	}
	let propertyContents = "";
	if (nonIndexProperties.length) propertyContents = inspectList(nonIndexProperties.map((key) => [key, array$1[key]]), options, inspectProperty);
	return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray, "inspectTypedArray");
function inspectDate(dateObject, options) {
	const stringRepresentation = dateObject.toJSON();
	if (stringRepresentation === null) return "Invalid Date";
	const split = stringRepresentation.split("T");
	const date = split[0];
	return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate, "inspectDate");
function inspectFunction(func, options) {
	const functionType = func[Symbol.toStringTag] || "Function";
	const name = func.name;
	if (!name) return options.stylize(`[${functionType}]`, "special");
	return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
}
__name(inspectFunction, "inspectFunction");
function inspectMapEntry([key, value], options) {
	options.truncate -= 4;
	key = options.inspect(key, options);
	options.truncate -= key.length;
	value = options.inspect(value, options);
	return `${key} => ${value}`;
}
__name(inspectMapEntry, "inspectMapEntry");
function mapToEntries(map$1) {
	const entries = [];
	map$1.forEach((value, key) => {
		entries.push([key, value]);
	});
	return entries;
}
__name(mapToEntries, "mapToEntries");
function inspectMap(map$1, options) {
	if (map$1.size === 0) return "Map{}";
	options.truncate -= 7;
	return `Map{ ${inspectList(mapToEntries(map$1), options, inspectMapEntry)} }`;
}
__name(inspectMap, "inspectMap");
var isNaN = Number.isNaN || ((i) => i !== i);
function inspectNumber(number, options) {
	if (isNaN(number)) return options.stylize("NaN", "number");
	if (number === Infinity) return options.stylize("Infinity", "number");
	if (number === -Infinity) return options.stylize("-Infinity", "number");
	if (number === 0) return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
	return options.stylize(truncate(String(number), options.truncate), "number");
}
__name(inspectNumber, "inspectNumber");
function inspectBigInt(number, options) {
	let nums = truncate(number.toString(), options.truncate - 1);
	if (nums !== truncator) nums += "n";
	return options.stylize(nums, "bigint");
}
__name(inspectBigInt, "inspectBigInt");
function inspectRegExp(value, options) {
	const flags = value.toString().split("/")[2];
	const sourceLength = options.truncate - (2 + flags.length);
	const source = value.source;
	return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp, "inspectRegExp");
function arrayFromSet(set2) {
	const values = [];
	set2.forEach((value) => {
		values.push(value);
	});
	return values;
}
__name(arrayFromSet, "arrayFromSet");
function inspectSet(set2, options) {
	if (set2.size === 0) return "Set{}";
	options.truncate -= 7;
	return `Set{ ${inspectList(arrayFromSet(set2), options)} }`;
}
__name(inspectSet, "inspectSet");
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
	"\b": "\\b",
	"	": "\\t",
	"\n": "\\n",
	"\f": "\\f",
	"\r": "\\r",
	"'": "\\'",
	"\\": "\\\\"
};
var hex = 16;
var unicodeLength = 4;
function escape(char) {
	return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
__name(escape, "escape");
function inspectString(string$1, options) {
	if (stringEscapeChars.test(string$1)) string$1 = string$1.replace(stringEscapeChars, escape);
	return options.stylize(`'${truncate(string$1, options.truncate - 2)}'`, "string");
}
__name(inspectString, "inspectString");
function inspectSymbol(value) {
	if ("description" in Symbol.prototype) return value.description ? `Symbol(${value.description})` : "Symbol()";
	return value.toString();
}
__name(inspectSymbol, "inspectSymbol");
var promise_default = /* @__PURE__ */ __name(() => "Promise{…}", "getPromiseValue");
function inspectObject(object$1, options) {
	const properties = Object.getOwnPropertyNames(object$1);
	const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object$1) : [];
	if (properties.length === 0 && symbols.length === 0) return "{}";
	options.truncate -= 4;
	options.seen = options.seen || [];
	if (options.seen.includes(object$1)) return "[Circular]";
	options.seen.push(object$1);
	const propertyContents = inspectList(properties.map((key) => [key, object$1[key]]), options, inspectProperty);
	const symbolContents = inspectList(symbols.map((key) => [key, object$1[key]]), options, inspectProperty);
	options.seen.pop();
	let sep = "";
	if (propertyContents && symbolContents) sep = ", ";
	return `{ ${propertyContents}${sep}${symbolContents} }`;
}
__name(inspectObject, "inspectObject");
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
	let name = "";
	if (toStringTag && toStringTag in value) name = value[toStringTag];
	name = name || value.constructor.name;
	if (!name || name === "_class") name = "<Anonymous Class>";
	options.truncate -= name.length;
	return `${name}${inspectObject(value, options)}`;
}
__name(inspectClass, "inspectClass");
function inspectArguments(args, options) {
	if (args.length === 0) return "Arguments[]";
	options.truncate -= 13;
	return `Arguments[ ${inspectList(args, options)} ]`;
}
__name(inspectArguments, "inspectArguments");
var errorKeys = [
	"stack",
	"line",
	"column",
	"name",
	"message",
	"fileName",
	"lineNumber",
	"columnNumber",
	"number",
	"description",
	"cause"
];
function inspectObject2(error, options) {
	const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
	const name = error.name;
	options.truncate -= name.length;
	let message = "";
	if (typeof error.message === "string") message = truncate(error.message, options.truncate);
	else properties.unshift("message");
	message = message ? `: ${message}` : "";
	options.truncate -= message.length + 5;
	options.seen = options.seen || [];
	if (options.seen.includes(error)) return "[Circular]";
	options.seen.push(error);
	const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
	return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject2, "inspectObject");
function inspectAttribute([key, value], options) {
	options.truncate -= 3;
	if (!value) return `${options.stylize(String(key), "yellow")}`;
	return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
__name(inspectAttribute, "inspectAttribute");
function inspectNodeCollection(collection, options) {
	return inspectList(collection, options, inspectNode, "\n");
}
__name(inspectNodeCollection, "inspectNodeCollection");
function inspectNode(node, options) {
	switch (node.nodeType) {
		case 1: return inspectHTML(node, options);
		case 3: return options.inspect(node.data, options);
		default: return options.inspect(node, options);
	}
}
__name(inspectNode, "inspectNode");
function inspectHTML(element, options) {
	const properties = element.getAttributeNames();
	const name = element.tagName.toLowerCase();
	const head = options.stylize(`<${name}`, "special");
	const headClose = options.stylize(`>`, "special");
	const tail = options.stylize(`</${name}>`, "special");
	options.truncate -= name.length * 2 + 5;
	let propertyContents = "";
	if (properties.length > 0) {
		propertyContents += " ";
		propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
	}
	options.truncate -= propertyContents.length;
	const truncate2 = options.truncate;
	let children = inspectNodeCollection(element.children, options);
	if (children && children.length > truncate2) children = `${truncator}(${element.children.length})`;
	return `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML, "inspectHTML");
var chaiInspect = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = Symbol.for("nodejs.util.inspect.custom");
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
	undefined: /* @__PURE__ */ __name((value, options) => options.stylize("undefined", "undefined"), "undefined"),
	null: /* @__PURE__ */ __name((value, options) => options.stylize("null", "null"), "null"),
	boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), "boolean"), "boolean"),
	Boolean: /* @__PURE__ */ __name((value, options) => options.stylize(String(value), "boolean"), "Boolean"),
	number: inspectNumber,
	Number: inspectNumber,
	bigint: inspectBigInt,
	BigInt: inspectBigInt,
	string: inspectString,
	String: inspectString,
	function: inspectFunction,
	Function: inspectFunction,
	symbol: inspectSymbol,
	Symbol: inspectSymbol,
	Array: inspectArray,
	Date: inspectDate,
	Map: inspectMap,
	Set: inspectSet,
	RegExp: inspectRegExp,
	Promise: promise_default,
	WeakSet: /* @__PURE__ */ __name((value, options) => options.stylize("WeakSet{…}", "special"), "WeakSet"),
	WeakMap: /* @__PURE__ */ __name((value, options) => options.stylize("WeakMap{…}", "special"), "WeakMap"),
	Arguments: inspectArguments,
	Int8Array: inspectTypedArray,
	Uint8Array: inspectTypedArray,
	Uint8ClampedArray: inspectTypedArray,
	Int16Array: inspectTypedArray,
	Uint16Array: inspectTypedArray,
	Int32Array: inspectTypedArray,
	Uint32Array: inspectTypedArray,
	Float32Array: inspectTypedArray,
	Float64Array: inspectTypedArray,
	Generator: /* @__PURE__ */ __name(() => "", "Generator"),
	DataView: /* @__PURE__ */ __name(() => "", "DataView"),
	ArrayBuffer: /* @__PURE__ */ __name(() => "", "ArrayBuffer"),
	Error: inspectObject2,
	HTMLCollection: inspectNodeCollection,
	NodeList: inspectNodeCollection
};
var inspectCustom = /* @__PURE__ */ __name((value, options, type3) => {
	if (chaiInspect in value && typeof value[chaiInspect] === "function") return value[chaiInspect](options);
	if (nodeInspect in value && typeof value[nodeInspect] === "function") return value[nodeInspect](options.depth, options);
	if ("inspect" in value && typeof value.inspect === "function") return value.inspect(options.depth, options);
	if ("constructor" in value && constructorMap.has(value.constructor)) return constructorMap.get(value.constructor)(value, options);
	if (stringTagMap[type3]) return stringTagMap[type3](value, options);
	return "";
}, "inspectCustom");
var toString = Object.prototype.toString;
function inspect(value, opts = {}) {
	const options = normaliseOptions(opts, inspect);
	const { customInspect } = options;
	let type3 = value === null ? "null" : typeof value;
	if (type3 === "object") type3 = toString.call(value).slice(8, -1);
	if (type3 in baseTypesMap) return baseTypesMap[type3](value, options);
	if (customInspect && value) {
		const output = inspectCustom(value, options, type3);
		if (output) {
			if (typeof output === "string") return output;
			return inspect(output, options);
		}
	}
	const proto = value ? Object.getPrototypeOf(value) : false;
	if (proto === Object.prototype || proto === null) return inspectObject(value, options);
	if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) return inspectHTML(value, options);
	if ("constructor" in value) {
		if (value.constructor !== Object) return inspectClass(value, options);
		return inspectObject(value, options);
	}
	if (value === Object(value)) return inspectObject(value, options);
	return options.stylize(String(value), type3);
}
__name(inspect, "inspect");
var config = {
	includeStack: false,
	showDiff: true,
	truncateThreshold: 40,
	useProxy: true,
	proxyExcludedKeys: [
		"then",
		"catch",
		"inspect",
		"toJSON"
	],
	deepEqual: null
};
function inspect2(obj, showHidden, depth, colors) {
	let options = {
		colors,
		depth: typeof depth === "undefined" ? 2 : depth,
		showHidden,
		truncate: config.truncateThreshold ? config.truncateThreshold : Infinity
	};
	return inspect(obj, options);
}
__name(inspect2, "inspect");
function objDisplay$1(obj) {
	let str = inspect2(obj), type3 = Object.prototype.toString.call(obj);
	if (config.truncateThreshold && str.length >= config.truncateThreshold) if (type3 === "[object Function]") return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
	else if (type3 === "[object Array]") return "[ Array(" + obj.length + ") ]";
	else if (type3 === "[object Object]") {
		let keys$1 = Object.keys(obj);
		return "{ Object (" + (keys$1.length > 2 ? keys$1.splice(0, 2).join(", ") + ", ..." : keys$1.join(", ")) + ") }";
	} else return str;
	else return str;
}
__name(objDisplay$1, "objDisplay");
function getMessage2(obj, args) {
	let negate = flag(obj, "negate");
	let val = flag(obj, "object");
	let expected = args[3];
	let actual = getActual(obj, args);
	let msg = negate ? args[2] : args[1];
	let flagMsg = flag(obj, "message");
	if (typeof msg === "function") msg = msg();
	msg = msg || "";
	msg = msg.replace(/#\{this\}/g, function() {
		return objDisplay$1(val);
	}).replace(/#\{act\}/g, function() {
		return objDisplay$1(actual);
	}).replace(/#\{exp\}/g, function() {
		return objDisplay$1(expected);
	});
	return flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object$1, includeAll) {
	let flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
	if (!object$1.__flags) object$1.__flags = /* @__PURE__ */ Object.create(null);
	includeAll = arguments.length === 3 ? includeAll : true;
	for (let flag3 in flags) if (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") object$1.__flags[flag3] = flags[flag3];
}
__name(transferFlags, "transferFlags");
function type2(obj) {
	if (typeof obj === "undefined") return "undefined";
	if (obj === null) return "null";
	const stringTag = obj[Symbol.toStringTag];
	if (typeof stringTag === "string") return stringTag;
	return Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type2, "type");
function FakeMap() {
	this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
	get: /* @__PURE__ */ __name(function get(key) {
		return key[this._key];
	}, "get"),
	set: /* @__PURE__ */ __name(function set$1(key, value) {
		if (Object.isExtensible(key)) Object.defineProperty(key, this._key, {
			value,
			configurable: true
		});
	}, "set")
};
var MemoizeMap = typeof WeakMap === "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
	if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) return null;
	var leftHandMap = memoizeMap.get(leftHandOperand);
	if (leftHandMap) {
		var result = leftHandMap.get(rightHandOperand);
		if (typeof result === "boolean") return result;
	}
	return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
	if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) return;
	var leftHandMap = memoizeMap.get(leftHandOperand);
	if (leftHandMap) leftHandMap.set(rightHandOperand, result);
	else {
		leftHandMap = new MemoizeMap();
		leftHandMap.set(rightHandOperand, result);
		memoizeMap.set(leftHandOperand, leftHandMap);
	}
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
	if (options && options.comparator) return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
	var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
	if (simpleResult !== null) return simpleResult;
	return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
	if (leftHandOperand === rightHandOperand) return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
	if (leftHandOperand !== leftHandOperand && rightHandOperand !== rightHandOperand) return true;
	if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) return false;
	return null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
	options = options || {};
	options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
	var comparator = options && options.comparator;
	var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
	if (memoizeResultLeft !== null) return memoizeResultLeft;
	var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
	if (memoizeResultRight !== null) return memoizeResultRight;
	if (comparator) {
		var comparatorResult = comparator(leftHandOperand, rightHandOperand);
		if (comparatorResult === false || comparatorResult === true) {
			memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
			return comparatorResult;
		}
		var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
		if (simpleResult !== null) return simpleResult;
	}
	var leftHandType = type2(leftHandOperand);
	if (leftHandType !== type2(rightHandOperand)) {
		memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
		return false;
	}
	memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
	var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
	memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
	return result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
	switch (leftHandType) {
		case "String":
		case "Number":
		case "Boolean":
		case "Date": return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
		case "Promise":
		case "Symbol":
		case "function":
		case "WeakMap":
		case "WeakSet": return leftHandOperand === rightHandOperand;
		case "Error": return keysEqual(leftHandOperand, rightHandOperand, [
			"name",
			"message",
			"code"
		], options);
		case "Arguments":
		case "Int8Array":
		case "Uint8Array":
		case "Uint8ClampedArray":
		case "Int16Array":
		case "Uint16Array":
		case "Int32Array":
		case "Uint32Array":
		case "Float32Array":
		case "Float64Array":
		case "Array": return iterableEqual(leftHandOperand, rightHandOperand, options);
		case "RegExp": return regexpEqual(leftHandOperand, rightHandOperand);
		case "Generator": return generatorEqual(leftHandOperand, rightHandOperand, options);
		case "DataView": return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
		case "ArrayBuffer": return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
		case "Set": return entriesEqual(leftHandOperand, rightHandOperand, options);
		case "Map": return entriesEqual(leftHandOperand, rightHandOperand, options);
		case "Temporal.PlainDate":
		case "Temporal.PlainTime":
		case "Temporal.PlainDateTime":
		case "Temporal.Instant":
		case "Temporal.ZonedDateTime":
		case "Temporal.PlainYearMonth":
		case "Temporal.PlainMonthDay": return leftHandOperand.equals(rightHandOperand);
		case "Temporal.Duration": return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
		case "Temporal.TimeZone":
		case "Temporal.Calendar": return leftHandOperand.toString() === rightHandOperand.toString();
		default: return objectEqual(leftHandOperand, rightHandOperand, options);
	}
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
	return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
	try {
		if (leftHandOperand.size !== rightHandOperand.size) return false;
		if (leftHandOperand.size === 0) return true;
	} catch (sizeError) {
		return false;
	}
	var leftHandItems = [];
	var rightHandItems = [];
	leftHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
		leftHandItems.push([key, value]);
	}, "gatherEntries"));
	rightHandOperand.forEach(/* @__PURE__ */ __name(function gatherEntries(key, value) {
		rightHandItems.push([key, value]);
	}, "gatherEntries"));
	return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
	var length = leftHandOperand.length;
	if (length !== rightHandOperand.length) return false;
	if (length === 0) return true;
	var index = -1;
	while (++index < length) if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) return false;
	return true;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
	return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
	return typeof Symbol !== "undefined" && typeof target === "object" && typeof Symbol.iterator !== "undefined" && typeof target[Symbol.iterator] === "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
	if (hasIteratorFunction(target)) try {
		return getGeneratorEntries(target[Symbol.iterator]());
	} catch (iteratorError) {
		return [];
	}
	return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
	var generatorResult = generator.next();
	var accumulator = [generatorResult.value];
	while (generatorResult.done === false) {
		generatorResult = generator.next();
		accumulator.push(generatorResult.value);
	}
	return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
	var keys$1 = [];
	for (var key in target) keys$1.push(key);
	return keys$1;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
	var keys$1 = [];
	var allKeys = Object.getOwnPropertySymbols(target);
	for (var i = 0; i < allKeys.length; i += 1) {
		var key = allKeys[i];
		if (Object.getOwnPropertyDescriptor(target, key).enumerable) keys$1.push(key);
	}
	return keys$1;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys$1, options) {
	var length = keys$1.length;
	if (length === 0) return true;
	for (var i = 0; i < length; i += 1) if (deepEqual(leftHandOperand[keys$1[i]], rightHandOperand[keys$1[i]], options) === false) return false;
	return true;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
	var leftHandKeys = getEnumerableKeys(leftHandOperand);
	var rightHandKeys = getEnumerableKeys(rightHandOperand);
	var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
	var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
	leftHandKeys = leftHandKeys.concat(leftHandSymbols);
	rightHandKeys = rightHandKeys.concat(rightHandSymbols);
	if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
		if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) return false;
		return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
	}
	var leftHandEntries = getIteratorEntries(leftHandOperand);
	var rightHandEntries = getIteratorEntries(rightHandOperand);
	if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
		leftHandEntries.sort();
		rightHandEntries.sort();
		return iterableEqual(leftHandEntries, rightHandEntries, options);
	}
	if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) return true;
	return false;
}
__name(objectEqual, "objectEqual");
function isPrimitive$1(value) {
	return value === null || typeof value !== "object";
}
__name(isPrimitive$1, "isPrimitive");
function mapSymbols(arr) {
	return arr.map(/* @__PURE__ */ __name(function mapSymbol(entry) {
		if (typeof entry === "symbol") return entry.toString();
		return entry;
	}, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
	if (typeof obj === "undefined" || obj === null) return false;
	return name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path) {
	return path.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((value) => {
		if (value === "constructor" || value === "__proto__" || value === "prototype") return {};
		const mArr = /^\[(\d+)\]$/.exec(value);
		let parsed = null;
		if (mArr) parsed = { i: parseFloat(mArr[1]) };
		else parsed = { p: value.replace(/\\([.[\]])/g, "$1") };
		return parsed;
	});
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
	let temporaryValue = obj;
	let res = null;
	pathDepth = typeof pathDepth === "undefined" ? parsed.length : pathDepth;
	for (let i = 0; i < pathDepth; i++) {
		const part = parsed[i];
		if (temporaryValue) {
			if (typeof part.p === "undefined") temporaryValue = temporaryValue[part.i];
			else temporaryValue = temporaryValue[part.p];
			if (i === pathDepth - 1) res = temporaryValue;
		}
	}
	return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
	const parsed = parsePath(path);
	const last = parsed[parsed.length - 1];
	const info = {
		parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
		name: last.p || last.i,
		value: internalGetPathValue(obj, parsed)
	};
	info.exists = hasProperty(info.parent, info.name);
	return info;
}
__name(getPathInfo, "getPathInfo");
var Assertion = class _Assertion {
	static {
		__name(this, "Assertion");
	}
	/** @type {{}} */
	__flags = {};
	/**
	* Creates object for chaining.
	* `Assertion` objects contain metadata in the form of flags. Three flags can
	* be assigned during instantiation by passing arguments to this constructor:
	*
	* - `object`: This flag contains the target of the assertion. For example, in
	* the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
	* contain `numKittens` so that the `equal` assertion can reference it when
	* needed.
	*
	* - `message`: This flag contains an optional custom error message to be
	* prepended to the error message that's generated by the assertion when it
	* fails.
	*
	* - `ssfi`: This flag stands for "start stack function indicator". It
	* contains a function reference that serves as the starting point for
	* removing frames from the stack trace of the error that's created by the
	* assertion when it fails. The goal is to provide a cleaner stack trace to
	* end users by removing Chai's internal functions. Note that it only works
	* in environments that support `Error.captureStackTrace`, and only when
	* `Chai.config.includeStack` hasn't been set to `false`.
	*
	* - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
	* should retain its current value, even as assertions are chained off of
	* this object. This is usually set to `true` when creating a new assertion
	* from within another assertion. It's also temporarily set to `true` before
	* an overwritten assertion gets called by the overwriting assertion.
	*
	* - `eql`: This flag contains the deepEqual function to be used by the assertion.
	*
	* @param {unknown} obj target of the assertion
	* @param {string} [msg] (optional) custom error message
	* @param {Function} [ssfi] (optional) starting point for removing stack frames
	* @param {boolean} [lockSsfi] (optional) whether or not the ssfi flag is locked
	*/
	constructor(obj, msg, ssfi, lockSsfi) {
		flag(this, "ssfi", ssfi || _Assertion);
		flag(this, "lockSsfi", lockSsfi);
		flag(this, "object", obj);
		flag(this, "message", msg);
		flag(this, "eql", config.deepEqual || deep_eql_default);
		return proxify(this);
	}
	/** @returns {boolean} */
	static get includeStack() {
		console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
		return config.includeStack;
	}
	/** @param {boolean} value */
	static set includeStack(value) {
		console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead.");
		config.includeStack = value;
	}
	/** @returns {boolean} */
	static get showDiff() {
		console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
		return config.showDiff;
	}
	/** @param {boolean} value */
	static set showDiff(value) {
		console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead.");
		config.showDiff = value;
	}
	/**
	* @param {string} name
	* @param {Function} fn
	*/
	static addProperty(name, fn$1) {
		addProperty(this.prototype, name, fn$1);
	}
	/**
	* @param {string} name
	* @param {Function} fn
	*/
	static addMethod(name, fn$1) {
		addMethod(this.prototype, name, fn$1);
	}
	/**
	* @param {string} name
	* @param {Function} fn
	* @param {Function} chainingBehavior
	*/
	static addChainableMethod(name, fn$1, chainingBehavior) {
		addChainableMethod(this.prototype, name, fn$1, chainingBehavior);
	}
	/**
	* @param {string} name
	* @param {Function} fn
	*/
	static overwriteProperty(name, fn$1) {
		overwriteProperty(this.prototype, name, fn$1);
	}
	/**
	* @param {string} name
	* @param {Function} fn
	*/
	static overwriteMethod(name, fn$1) {
		overwriteMethod(this.prototype, name, fn$1);
	}
	/**
	* @param {string} name
	* @param {Function} fn
	* @param {Function} chainingBehavior
	*/
	static overwriteChainableMethod(name, fn$1, chainingBehavior) {
		overwriteChainableMethod(this.prototype, name, fn$1, chainingBehavior);
	}
	/**
	* ### .assert(expression, message, negateMessage, expected, actual, showDiff)
	*
	* Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
	*
	* @name assert
	* @param {unknown} _expr to be tested
	* @param {string | Function} msg or function that returns message to display if expression fails
	* @param {string | Function} _negateMsg or function that returns negatedMessage to display if negated expression fails
	* @param {unknown} expected value (remember to check for negation)
	* @param {unknown} _actual (optional) will default to `this.obj`
	* @param {boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
	* @returns {void}
	*/
	assert(_expr, msg, _negateMsg, expected, _actual, showDiff) {
		const ok = test$2(this, arguments);
		if (false !== showDiff) showDiff = true;
		if (void 0 === expected && void 0 === _actual) showDiff = false;
		if (true !== config.showDiff) showDiff = false;
		if (!ok) {
			msg = getMessage2(this, arguments);
			const assertionErrorObjectProperties = {
				actual: getActual(this, arguments),
				expected,
				showDiff
			};
			const operator = getOperator(this, arguments);
			if (operator) assertionErrorObjectProperties.operator = operator;
			throw new AssertionError(msg, assertionErrorObjectProperties, config.includeStack ? this.assert : flag(this, "ssfi"));
		}
	}
	/**
	* Quick reference to stored `actual` value for plugin developers.
	*
	* @returns {unknown}
	*/
	get _obj() {
		return flag(this, "object");
	}
	/**
	* Quick reference to stored `actual` value for plugin developers.
	*
	* @param {unknown} val
	*/
	set _obj(val) {
		flag(this, "object", val);
	}
};
function isProxyEnabled() {
	return config.useProxy && typeof Proxy !== "undefined" && typeof Reflect !== "undefined";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
	getter = getter === void 0 ? function() {} : getter;
	Object.defineProperty(ctx, name, {
		get: /* @__PURE__ */ __name(function propertyGetter() {
			if (!isProxyEnabled() && !flag(this, "lockSsfi")) flag(this, "ssfi", propertyGetter);
			let result = getter.call(this);
			if (result !== void 0) return result;
			let newAssertion = new Assertion();
			transferFlags(this, newAssertion);
			return newAssertion;
		}, "propertyGetter"),
		configurable: true
	});
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {}, "length");
function addLengthGuard(fn$1, assertionName, isChainable) {
	if (!fnLengthDesc.configurable) return fn$1;
	Object.defineProperty(fn$1, "length", { get: /* @__PURE__ */ __name(function() {
		if (isChainable) throw Error("Invalid Chai property: " + assertionName + ".length. Due to a compatibility issue, \"length\" cannot directly follow \"" + assertionName + "\". Use \"" + assertionName + ".lengthOf\" instead.");
		throw Error("Invalid Chai property: " + assertionName + ".length. See docs for proper usage of \"" + assertionName + "\".");
	}, "get") });
	return fn$1;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object$1) {
	let result = Object.getOwnPropertyNames(object$1);
	function addProperty2(property) {
		if (result.indexOf(property) === -1) result.push(property);
	}
	__name(addProperty2, "addProperty");
	let proto = Object.getPrototypeOf(object$1);
	while (proto !== null) {
		Object.getOwnPropertyNames(proto).forEach(addProperty2);
		proto = Object.getPrototypeOf(proto);
	}
	return result;
}
__name(getProperties, "getProperties");
var builtins = [
	"__flags",
	"__methods",
	"_obj",
	"assert"
];
function proxify(obj, nonChainableMethodName) {
	if (!isProxyEnabled()) return obj;
	return new Proxy(obj, { get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
		if (typeof property === "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
			if (nonChainableMethodName) throw Error("Invalid Chai property: " + nonChainableMethodName + "." + property + ". See docs for proper usage of \"" + nonChainableMethodName + "\".");
			let suggestion = null;
			let suggestionDistance = 4;
			getProperties(target).forEach(function(prop) {
				if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
					let dist = stringDistanceCapped(property, prop, suggestionDistance);
					if (dist < suggestionDistance) {
						suggestion = prop;
						suggestionDistance = dist;
					}
				}
			});
			if (suggestion !== null) throw Error("Invalid Chai property: " + property + ". Did you mean \"" + suggestion + "\"?");
			else throw Error("Invalid Chai property: " + property);
		}
		if (builtins.indexOf(property) === -1 && !flag(target, "lockSsfi")) flag(target, "ssfi", proxyGetter);
		return Reflect.get(target, property);
	}, "proxyGetter") });
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
	if (Math.abs(strA.length - strB.length) >= cap) return cap;
	let memo = [];
	for (let i = 0; i <= strA.length; i++) {
		memo[i] = Array(strB.length + 1).fill(0);
		memo[i][0] = i;
	}
	for (let j$1 = 0; j$1 < strB.length; j$1++) memo[0][j$1] = j$1;
	for (let i = 1; i <= strA.length; i++) {
		let ch = strA.charCodeAt(i - 1);
		for (let j$1 = 1; j$1 <= strB.length; j$1++) {
			if (Math.abs(i - j$1) >= cap) {
				memo[i][j$1] = cap;
				continue;
			}
			memo[i][j$1] = Math.min(memo[i - 1][j$1] + 1, memo[i][j$1 - 1] + 1, memo[i - 1][j$1 - 1] + (ch === strB.charCodeAt(j$1 - 1) ? 0 : 1));
		}
	}
	return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
	let methodWrapper = /* @__PURE__ */ __name(function() {
		if (!flag(this, "lockSsfi")) flag(this, "ssfi", methodWrapper);
		let result = method.apply(this, arguments);
		if (result !== void 0) return result;
		let newAssertion = new Assertion();
		transferFlags(this, newAssertion);
		return newAssertion;
	}, "methodWrapper");
	addLengthGuard(methodWrapper, name, false);
	ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
	let _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {}, "_super");
	if (_get && "function" === typeof _get.get) _super = _get.get;
	Object.defineProperty(ctx, name, {
		get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
			if (!isProxyEnabled() && !flag(this, "lockSsfi")) flag(this, "ssfi", overwritingPropertyGetter);
			let origLockSsfi = flag(this, "lockSsfi");
			flag(this, "lockSsfi", true);
			let result = getter(_super).call(this);
			flag(this, "lockSsfi", origLockSsfi);
			if (result !== void 0) return result;
			let newAssertion = new Assertion();
			transferFlags(this, newAssertion);
			return newAssertion;
		}, "overwritingPropertyGetter"),
		configurable: true
	});
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
	let _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
		throw new Error(name + " is not a function");
	}, "_super");
	if (_method && "function" === typeof _method) _super = _method;
	let overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
		if (!flag(this, "lockSsfi")) flag(this, "ssfi", overwritingMethodWrapper);
		let origLockSsfi = flag(this, "lockSsfi");
		flag(this, "lockSsfi", true);
		let result = method(_super).apply(this, arguments);
		flag(this, "lockSsfi", origLockSsfi);
		if (result !== void 0) return result;
		let newAssertion = new Assertion();
		transferFlags(this, newAssertion);
		return newAssertion;
	}, "overwritingMethodWrapper");
	addLengthGuard(overwritingMethodWrapper, name, false);
	ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf === "function";
var testFn = /* @__PURE__ */ __name(function() {}, "testFn");
var excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
	let propDesc = Object.getOwnPropertyDescriptor(testFn, name);
	if (typeof propDesc !== "object") return true;
	return !propDesc.configurable;
});
var call = Function.prototype.call;
var apply = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
	if (typeof chainingBehavior !== "function") chainingBehavior = /* @__PURE__ */ __name(function() {}, "chainingBehavior");
	let chainableBehavior = {
		method,
		chainingBehavior
	};
	if (!ctx.__methods) ctx.__methods = {};
	ctx.__methods[name] = chainableBehavior;
	Object.defineProperty(ctx, name, {
		get: /* @__PURE__ */ __name(function chainableMethodGetter() {
			chainableBehavior.chainingBehavior.call(this);
			let chainableMethodWrapper = /* @__PURE__ */ __name(function() {
				if (!flag(this, "lockSsfi")) flag(this, "ssfi", chainableMethodWrapper);
				let result = chainableBehavior.method.apply(this, arguments);
				if (result !== void 0) return result;
				let newAssertion = new Assertion();
				transferFlags(this, newAssertion);
				return newAssertion;
			}, "chainableMethodWrapper");
			addLengthGuard(chainableMethodWrapper, name, true);
			if (canSetPrototype) {
				let prototype = Object.create(this);
				prototype.call = call;
				prototype.apply = apply;
				Object.setPrototypeOf(chainableMethodWrapper, prototype);
			} else Object.getOwnPropertyNames(ctx).forEach(function(asserterName) {
				if (excludeNames.indexOf(asserterName) !== -1) return;
				let pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
				Object.defineProperty(chainableMethodWrapper, asserterName, pd);
			});
			transferFlags(this, chainableMethodWrapper);
			return proxify(chainableMethodWrapper);
		}, "chainableMethodGetter"),
		configurable: true
	});
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
	let chainableBehavior = ctx.__methods[name];
	let _chainingBehavior = chainableBehavior.chainingBehavior;
	chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function overwritingChainableMethodGetter() {
		let result = chainingBehavior(_chainingBehavior).call(this);
		if (result !== void 0) return result;
		let newAssertion = new Assertion();
		transferFlags(this, newAssertion);
		return newAssertion;
	}, "overwritingChainableMethodGetter");
	let _method = chainableBehavior.method;
	chainableBehavior.method = /* @__PURE__ */ __name(function overwritingChainableMethodWrapper() {
		let result = method(_method).apply(this, arguments);
		if (result !== void 0) return result;
		let newAssertion = new Assertion();
		transferFlags(this, newAssertion);
		return newAssertion;
	}, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a$2, b$1) {
	return inspect2(a$2) < inspect2(b$1) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
	if (typeof Object.getOwnPropertySymbols !== "function") return [];
	return Object.getOwnPropertySymbols(obj).filter(function(sym) {
		return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
	});
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
	return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
var isNaN2 = Number.isNaN;
function isObjectType(obj) {
	let objectType = type(obj);
	return [
		"Array",
		"Object",
		"Function"
	].indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
	let operator = flag(obj, "operator");
	let negate = flag(obj, "negate");
	let expected = args[3];
	let msg = negate ? args[2] : args[1];
	if (operator) return operator;
	if (typeof msg === "function") msg = msg();
	msg = msg || "";
	if (!msg) return;
	if (/\shave\s/.test(msg)) return;
	let isObject$2 = isObjectType(expected);
	if (/\snot\s/.test(msg)) return isObject$2 ? "notDeepStrictEqual" : "notStrictEqual";
	return isObject$2 ? "deepStrictEqual" : "strictEqual";
}
__name(getOperator, "getOperator");
function getName(fn$1) {
	return fn$1.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
	return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isNumeric(obj) {
	return ["Number", "BigInt"].includes(type(obj));
}
__name(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
	"to",
	"be",
	"been",
	"is",
	"and",
	"has",
	"have",
	"with",
	"that",
	"which",
	"at",
	"of",
	"same",
	"but",
	"does",
	"still",
	"also"
].forEach(function(chain) {
	Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
	flag2(this, "negate", true);
});
Assertion.addProperty("deep", function() {
	flag2(this, "deep", true);
});
Assertion.addProperty("nested", function() {
	flag2(this, "nested", true);
});
Assertion.addProperty("own", function() {
	flag2(this, "own", true);
});
Assertion.addProperty("ordered", function() {
	flag2(this, "ordered", true);
});
Assertion.addProperty("any", function() {
	flag2(this, "any", true);
	flag2(this, "all", false);
});
Assertion.addProperty("all", function() {
	flag2(this, "all", true);
	flag2(this, "any", false);
});
var functionTypes = {
	function: [
		"function",
		"asyncfunction",
		"generatorfunction",
		"asyncgeneratorfunction"
	],
	asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
	generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
	asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function an(type3, msg) {
	if (msg) flag2(this, "message", msg);
	type3 = type3.toLowerCase();
	let obj = flag2(this, "object"), article = ~[
		"a",
		"e",
		"i",
		"o",
		"u"
	].indexOf(type3.charAt(0)) ? "an " : "a ";
	const detectedType = type(obj).toLowerCase();
	if (functionTypes["function"].includes(type3)) this.assert(functionTypes[type3].includes(detectedType), "expected #{this} to be " + article + type3, "expected #{this} not to be " + article + type3);
	else this.assert(type3 === detectedType, "expected #{this} to be " + article + type3, "expected #{this} not to be " + article + type3);
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a$2, b$1) {
	return isNaN2(a$2) && isNaN2(b$1) || a$2 === b$1;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
	flag2(this, "contains", true);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
	flagMsg = flagMsg ? flagMsg + ": " : "";
	let included = false;
	switch (objType) {
		case "string":
			included = obj.indexOf(val) !== -1;
			break;
		case "weakset":
			if (isDeep) throw new AssertionError(flagMsg + "unable to use .deep.include with WeakSet", void 0, ssfi);
			included = obj.has(val);
			break;
		case "map":
			obj.forEach(function(item) {
				included = included || isEql(item, val);
			});
			break;
		case "set":
			if (isDeep) obj.forEach(function(item) {
				included = included || isEql(item, val);
			});
			else included = obj.has(val);
			break;
		case "array":
			if (isDeep) included = obj.some(function(item) {
				return isEql(item, val);
			});
			else included = obj.indexOf(val) !== -1;
			break;
		default: {
			if (val !== Object(val)) throw new AssertionError(flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(), void 0, ssfi);
			let props = Object.keys(val);
			let firstErr = null;
			let numErrs = 0;
			props.forEach(function(prop) {
				let propAssertion = new Assertion(obj);
				transferFlags(this, propAssertion, true);
				flag2(propAssertion, "lockSsfi", true);
				if (!negate || props.length === 1) {
					propAssertion.property(prop, val[prop]);
					return;
				}
				try {
					propAssertion.property(prop, val[prop]);
				} catch (err) {
					if (!check_error_exports.compatibleConstructor(err, AssertionError)) throw err;
					if (firstErr === null) firstErr = err;
					numErrs++;
				}
			}, this);
			if (negate && props.length > 1 && numErrs === props.length) throw firstErr;
			return;
		}
	}
	this.assert(included, "expected #{this} to " + descriptor + "include " + inspect2(val), "expected #{this} to not " + descriptor + "include " + inspect2(val));
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
	this.assert(flag2(this, "object"), "expected #{this} to be truthy", "expected #{this} to be falsy");
});
Assertion.addProperty("true", function() {
	this.assert(true === flag2(this, "object"), "expected #{this} to be true", "expected #{this} to be false", flag2(this, "negate") ? false : true);
});
Assertion.addProperty("numeric", function() {
	const object$1 = flag2(this, "object");
	this.assert(["Number", "BigInt"].includes(type(object$1)), "expected #{this} to be numeric", "expected #{this} to not be numeric", flag2(this, "negate") ? false : true);
});
Assertion.addProperty("callable", function() {
	const val = flag2(this, "object");
	const ssfi = flag2(this, "ssfi");
	const message = flag2(this, "message");
	const msg = message ? `${message}: ` : "";
	const negate = flag2(this, "negate");
	const assertionMessage = negate ? `${msg}expected ${inspect2(val)} not to be a callable function` : `${msg}expected ${inspect2(val)} to be a callable function`;
	const isCallable = [
		"Function",
		"AsyncFunction",
		"GeneratorFunction",
		"AsyncGeneratorFunction"
	].includes(type(val));
	if (isCallable && negate || !isCallable && !negate) throw new AssertionError(assertionMessage, void 0, ssfi);
});
Assertion.addProperty("false", function() {
	this.assert(false === flag2(this, "object"), "expected #{this} to be false", "expected #{this} to be true", flag2(this, "negate") ? true : false);
});
Assertion.addProperty("null", function() {
	this.assert(null === flag2(this, "object"), "expected #{this} to be null", "expected #{this} not to be null");
});
Assertion.addProperty("undefined", function() {
	this.assert(void 0 === flag2(this, "object"), "expected #{this} to be undefined", "expected #{this} not to be undefined");
});
Assertion.addProperty("NaN", function() {
	this.assert(isNaN2(flag2(this, "object")), "expected #{this} to be NaN", "expected #{this} not to be NaN");
});
function assertExist() {
	let val = flag2(this, "object");
	this.assert(val !== null && val !== void 0, "expected #{this} to exist", "expected #{this} to not exist");
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
	let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
	flagMsg = flagMsg ? flagMsg + ": " : "";
	switch (type(val).toLowerCase()) {
		case "array":
		case "string":
			itemsCount = val.length;
			break;
		case "map":
		case "set":
			itemsCount = val.size;
			break;
		case "weakmap":
		case "weakset": throw new AssertionError(flagMsg + ".empty was passed a weak collection", void 0, ssfi);
		case "function": {
			const msg = flagMsg + ".empty was passed a function " + getName(val);
			throw new AssertionError(msg.trim(), void 0, ssfi);
		}
		default:
			if (val !== Object(val)) throw new AssertionError(flagMsg + ".empty was passed non-string primitive " + inspect2(val), void 0, ssfi);
			itemsCount = Object.keys(val).length;
	}
	this.assert(0 === itemsCount, "expected #{this} to be empty", "expected #{this} not to be empty");
});
function checkArguments() {
	let obj = flag2(this, "object"), type3 = type(obj);
	this.assert("Arguments" === type3, "expected #{this} to be arguments but got " + type3, "expected #{this} to not be arguments");
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object");
	if (flag2(this, "deep")) {
		let prevLockSsfi = flag2(this, "lockSsfi");
		flag2(this, "lockSsfi", true);
		this.eql(val);
		flag2(this, "lockSsfi", prevLockSsfi);
	} else this.assert(val === obj, "expected #{this} to equal #{exp}", "expected #{this} to not equal #{exp}", val, this._obj, true);
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
	if (msg) flag2(this, "message", msg);
	let eql = flag2(this, "eql");
	this.assert(eql(obj, flag2(this, "object")), "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", obj, this._obj, true);
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase();
	if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
	if (!doLength && objType === "date" && nType !== "date") throw new AssertionError(msgPrefix + "the argument to above must be a date", void 0, ssfi);
	else if (!isNumeric(n) && (doLength || isNumeric(obj))) throw new AssertionError(msgPrefix + "the argument to above must be a number", void 0, ssfi);
	else if (!doLength && objType !== "date" && !isNumeric(obj)) {
		let printObj = objType === "string" ? "'" + obj + "'" : obj;
		throw new AssertionError(msgPrefix + "expected " + printObj + " to be a number or a date", void 0, ssfi);
	}
	if (doLength) {
		let descriptor = "length", itemsCount;
		if (objType === "map" || objType === "set") {
			descriptor = "size";
			itemsCount = obj.size;
		} else itemsCount = obj.length;
		this.assert(itemsCount > n, "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " above #{exp}", n, itemsCount);
	} else this.assert(obj > n, "expected #{this} to be above #{exp}", "expected #{this} to be at most #{exp}", n);
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = true;
	if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
	if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to least must be a date";
	else if (!isNumeric(n) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the argument to least must be a number";
	else if (!doLength && objType !== "date" && !isNumeric(obj)) {
		let printObj = objType === "string" ? "'" + obj + "'" : obj;
		errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
	} else shouldThrow = false;
	if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
	if (doLength) {
		let descriptor = "length", itemsCount;
		if (objType === "map" || objType === "set") {
			descriptor = "size";
			itemsCount = obj.size;
		} else itemsCount = obj.length;
		this.assert(itemsCount >= n, "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " below #{exp}", n, itemsCount);
	} else this.assert(obj >= n, "expected #{this} to be at least #{exp}", "expected #{this} to be below #{exp}", n);
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = true;
	if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
	if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to below must be a date";
	else if (!isNumeric(n) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the argument to below must be a number";
	else if (!doLength && objType !== "date" && !isNumeric(obj)) {
		let printObj = objType === "string" ? "'" + obj + "'" : obj;
		errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
	} else shouldThrow = false;
	if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
	if (doLength) {
		let descriptor = "length", itemsCount;
		if (objType === "map" || objType === "set") {
			descriptor = "size";
			itemsCount = obj.size;
		} else itemsCount = obj.length;
		this.assert(itemsCount < n, "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " below #{exp}", n, itemsCount);
	} else this.assert(obj < n, "expected #{this} to be below #{exp}", "expected #{this} to be at least #{exp}", n);
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = true;
	if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
	if (!doLength && objType === "date" && nType !== "date") errorMessage = msgPrefix + "the argument to most must be a date";
	else if (!isNumeric(n) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the argument to most must be a number";
	else if (!doLength && objType !== "date" && !isNumeric(obj)) {
		let printObj = objType === "string" ? "'" + obj + "'" : obj;
		errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
	} else shouldThrow = false;
	if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
	if (doLength) {
		let descriptor = "length", itemsCount;
		if (objType === "map" || objType === "set") {
			descriptor = "size";
			itemsCount = obj.size;
		} else itemsCount = obj.length;
		this.assert(itemsCount <= n, "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}", "expected #{this} to have a " + descriptor + " above #{exp}", n, itemsCount);
	} else this.assert(obj <= n, "expected #{this} to be at most #{exp}", "expected #{this} to be above #{exp}", n);
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = true, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
	if (doLength && objType !== "map" && objType !== "set") new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
	if (!doLength && objType === "date" && (startType !== "date" || finishType !== "date")) errorMessage = msgPrefix + "the arguments to within must be dates";
	else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj))) errorMessage = msgPrefix + "the arguments to within must be numbers";
	else if (!doLength && objType !== "date" && !isNumeric(obj)) {
		let printObj = objType === "string" ? "'" + obj + "'" : obj;
		errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
	} else shouldThrow = false;
	if (shouldThrow) throw new AssertionError(errorMessage, void 0, ssfi);
	if (doLength) {
		let descriptor = "length", itemsCount;
		if (objType === "map" || objType === "set") {
			descriptor = "size";
			itemsCount = obj.size;
		} else itemsCount = obj.length;
		this.assert(itemsCount >= start && itemsCount <= finish, "expected #{this} to have a " + descriptor + " within " + range, "expected #{this} to not have a " + descriptor + " within " + range);
	} else this.assert(obj >= start && obj <= finish, "expected #{this} to be within " + range, "expected #{this} to not be within " + range);
});
function assertInstanceOf(constructor, msg) {
	if (msg) flag2(this, "message", msg);
	let target = flag2(this, "object");
	let ssfi = flag2(this, "ssfi");
	let flagMsg = flag2(this, "message");
	let isInstanceOf;
	try {
		isInstanceOf = target instanceof constructor;
	} catch (err) {
		if (err instanceof TypeError) {
			flagMsg = flagMsg ? flagMsg + ": " : "";
			throw new AssertionError(flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.", void 0, ssfi);
		}
		throw err;
	}
	let name = getName(constructor);
	if (name == null) name = "an unnamed constructor";
	this.assert(isInstanceOf, "expected #{this} to be an instance of " + name, "expected #{this} to not be an instance of " + name);
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
	if (msg) flag2(this, "message", msg);
	let isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
	flagMsg = flagMsg ? flagMsg + ": " : "";
	if (isNested) {
		if (nameType !== "string") throw new AssertionError(flagMsg + "the argument to property must be a string when using nested syntax", void 0, ssfi);
	} else if (nameType !== "string" && nameType !== "number" && nameType !== "symbol") throw new AssertionError(flagMsg + "the argument to property must be a string, number, or symbol", void 0, ssfi);
	if (isNested && isOwn) throw new AssertionError(flagMsg + "The \"nested\" and \"own\" flags cannot be combined.", void 0, ssfi);
	if (obj === null || obj === void 0) throw new AssertionError(flagMsg + "Target cannot be null or undefined.", void 0, ssfi);
	let isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
	let descriptor = "";
	if (isDeep) descriptor += "deep ";
	if (isOwn) descriptor += "own ";
	if (isNested) descriptor += "nested ";
	descriptor += "property ";
	let hasProperty2;
	if (isOwn) hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name);
	else if (isNested) hasProperty2 = pathInfo.exists;
	else hasProperty2 = hasProperty(obj, name);
	if (!negate || arguments.length === 1) this.assert(hasProperty2, "expected #{this} to have " + descriptor + inspect2(name), "expected #{this} to not have " + descriptor + inspect2(name));
	if (arguments.length > 1) this.assert(hasProperty2 && isEql(val, value), "expected #{this} to have " + descriptor + inspect2(name) + " of #{exp}, but got #{act}", "expected #{this} to not have " + descriptor + inspect2(name) + " of #{act}", val, value);
	flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
	flag2(this, "own", true);
	assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
	if (typeof descriptor === "string") {
		msg = descriptor;
		descriptor = null;
	}
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object");
	let actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
	let eql = flag2(this, "eql");
	if (actualDescriptor && descriptor) this.assert(eql(descriptor, actualDescriptor), "expected the own property descriptor for " + inspect2(name) + " on #{this} to match " + inspect2(descriptor) + ", got " + inspect2(actualDescriptor), "expected the own property descriptor for " + inspect2(name) + " on #{this} to not match " + inspect2(descriptor), descriptor, actualDescriptor, true);
	else this.assert(actualDescriptor, "expected #{this} to have an own property descriptor for " + inspect2(name), "expected #{this} to not have an own property descriptor for " + inspect2(name));
	flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
	flag2(this, "doLength", true);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
	switch (objType) {
		case "map":
		case "set":
			descriptor = "size";
			itemsCount = obj.size;
			break;
		default:
			new Assertion(obj, flagMsg, ssfi, true).to.have.property("length");
			itemsCount = obj.length;
	}
	this.assert(itemsCount == n, "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}", "expected #{this} to not have a " + descriptor + " of #{act}", n, itemsCount);
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object");
	this.assert(re.exec(obj), "expected #{this} to match " + re, "expected #{this} not to match " + re);
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
	new Assertion(obj, flagMsg, ssfi, true).is.a("string");
	this.assert(~obj.indexOf(str), "expected #{this} to contain " + inspect2(str), "expected #{this} to not contain " + inspect2(str));
});
function assertKeys(keys$1) {
	let obj = flag2(this, "object"), objType = type(obj), keysType = type(keys$1), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = true, flagMsg = flag2(this, "message");
	flagMsg = flagMsg ? flagMsg + ": " : "";
	let mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
	if (objType === "Map" || objType === "Set") {
		deepStr = isDeep ? "deeply " : "";
		actual = [];
		obj.forEach(function(val, key) {
			actual.push(key);
		});
		if (keysType !== "Array") keys$1 = Array.prototype.slice.call(arguments);
	} else {
		actual = getOwnEnumerableProperties(obj);
		switch (keysType) {
			case "Array":
				if (arguments.length > 1) throw new AssertionError(mixedArgsMsg, void 0, ssfi);
				break;
			case "Object":
				if (arguments.length > 1) throw new AssertionError(mixedArgsMsg, void 0, ssfi);
				keys$1 = Object.keys(keys$1);
				break;
			default: keys$1 = Array.prototype.slice.call(arguments);
		}
		keys$1 = keys$1.map(function(val) {
			return typeof val === "symbol" ? val : String(val);
		});
	}
	if (!keys$1.length) throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
	let len = keys$1.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys$1, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
	if (!any && !all) all = true;
	if (any) ok = expected.some(function(expectedKey) {
		return actual.some(function(actualKey) {
			return isEql(expectedKey, actualKey);
		});
	});
	if (all) {
		ok = expected.every(function(expectedKey) {
			return actual.some(function(actualKey) {
				return isEql(expectedKey, actualKey);
			});
		});
		if (!flag2(this, "contains")) ok = ok && keys$1.length == actual.length;
	}
	if (len > 1) {
		keys$1 = keys$1.map(function(key) {
			return inspect2(key);
		});
		let last = keys$1.pop();
		if (all) str = keys$1.join(", ") + ", and " + last;
		if (any) str = keys$1.join(", ") + ", or " + last;
	} else str = inspect2(keys$1[0]);
	str = (len > 1 ? "keys " : "key ") + str;
	str = (flag2(this, "contains") ? "contain " : "have ") + str;
	this.assert(ok, "expected #{this} to " + deepStr + str, "expected #{this} to not " + deepStr + str, expected.slice(0).sort(compareByInspect), actual.sort(compareByInspect), true);
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || false;
	new Assertion(obj, flagMsg, ssfi, true).is.a("function");
	if (isRegExp2(errorLike) || typeof errorLike === "string") {
		errMsgMatcher = errorLike;
		errorLike = null;
	}
	let caughtErr;
	let errorWasThrown = false;
	try {
		obj();
	} catch (err) {
		errorWasThrown = true;
		caughtErr = err;
	}
	let everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0;
	let everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
	let errorLikeFail = false;
	let errMsgMatcherFail = false;
	if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
		let errorLikeString = "an error";
		if (errorLike instanceof Error) errorLikeString = "#{exp}";
		else if (errorLike) errorLikeString = check_error_exports.getConstructorName(errorLike);
		let actual = caughtErr;
		if (caughtErr instanceof Error) actual = caughtErr.toString();
		else if (typeof caughtErr === "string") actual = caughtErr;
		else if (caughtErr && (typeof caughtErr === "object" || typeof caughtErr === "function")) try {
			actual = check_error_exports.getConstructorName(caughtErr);
		} catch (_err) {}
		this.assert(errorWasThrown, "expected #{this} to throw " + errorLikeString, "expected #{this} to not throw an error but #{act} was thrown", errorLike && errorLike.toString(), actual);
	}
	if (errorLike && caughtErr) {
		if (errorLike instanceof Error) {
			if (check_error_exports.compatibleInstance(caughtErr, errorLike) === negate) if (everyArgIsDefined && negate) errorLikeFail = true;
			else this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""), errorLike.toString(), caughtErr.toString());
		}
		if (check_error_exports.compatibleConstructor(caughtErr, errorLike) === negate) if (everyArgIsDefined && negate) errorLikeFail = true;
		else this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr));
	}
	if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
		let placeholder = "including";
		if (isRegExp2(errMsgMatcher)) placeholder = "matching";
		if (check_error_exports.compatibleMessage(caughtErr, errMsgMatcher) === negate) if (everyArgIsDefined && negate) errMsgMatcherFail = true;
		else this.assert(negate, "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}", "expected #{this} to throw error not " + placeholder + " #{exp}", errMsgMatcher, check_error_exports.getMessage(caughtErr));
	}
	if (errorLikeFail && errMsgMatcherFail) this.assert(negate, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""), errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr));
	flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), itself = flag2(this, "itself"), context = "function" === typeof obj && !itself ? obj.prototype[method] : obj[method];
	this.assert("function" === typeof context, "expected #{this} to respond to " + inspect2(method), "expected #{this} to not respond to " + inspect2(method));
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
	flag2(this, "itself", true);
});
function satisfy(matcher, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object");
	let result = matcher(obj);
	this.assert(result, "expected #{this} to satisfy " + objDisplay$1(matcher), "expected #{this} to not satisfy" + objDisplay$1(matcher), flag2(this, "negate") ? false : true, result);
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
	new Assertion(obj, flagMsg, ssfi, true).is.numeric;
	let message = "A `delta` value is required for `closeTo`";
	if (delta == void 0) throw new AssertionError(flagMsg ? `${flagMsg}: ${message}` : message, void 0, ssfi);
	new Assertion(delta, flagMsg, ssfi, true).is.numeric;
	message = "A `expected` value is required for `closeTo`";
	if (expected == void 0) throw new AssertionError(flagMsg ? `${flagMsg}: ${message}` : message, void 0, ssfi);
	new Assertion(expected, flagMsg, ssfi, true).is.numeric;
	const abs = /* @__PURE__ */ __name((x$1) => x$1 < 0n ? -x$1 : x$1, "abs");
	const strip = /* @__PURE__ */ __name((number) => parseFloat(parseFloat(number).toPrecision(12)), "strip");
	this.assert(strip(abs(obj - expected)) <= delta, "expected #{this} to be close to " + expected + " +/- " + delta, "expected #{this} not to be close to " + expected + " +/- " + delta);
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
	let superset = Array.from(_superset);
	let subset = Array.from(_subset);
	if (!contains) {
		if (subset.length !== superset.length) return false;
		superset = superset.slice();
	}
	return subset.every(function(elem, idx) {
		if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
		if (!cmp) {
			let matchIdx = superset.indexOf(elem);
			if (matchIdx === -1) return false;
			if (!contains) superset.splice(matchIdx, 1);
			return true;
		}
		return superset.some(function(elem2, matchIdx) {
			if (!cmp(elem, elem2)) return false;
			if (!contains) superset.splice(matchIdx, 1);
			return true;
		});
	});
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
	new Assertion(obj, flagMsg, ssfi, true).to.be.iterable;
	new Assertion(subset, flagMsg, ssfi, true).to.be.iterable;
	let contains = flag2(this, "contains");
	let ordered = flag2(this, "ordered");
	let subject, failMsg, failNegateMsg;
	if (contains) {
		subject = ordered ? "an ordered superset" : "a superset";
		failMsg = "expected #{this} to be " + subject + " of #{exp}";
		failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}";
	} else {
		subject = ordered ? "ordered members" : "members";
		failMsg = "expected #{this} to have the same " + subject + " as #{exp}";
		failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}";
	}
	let cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
	this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
});
Assertion.addProperty("iterable", function(msg) {
	if (msg) flag2(this, "message", msg);
	let obj = flag2(this, "object");
	this.assert(obj != void 0 && obj[Symbol.iterator], "expected #{this} to be an iterable", "expected #{this} to not be an iterable", obj);
});
function oneOf(list, msg) {
	if (msg) flag2(this, "message", msg);
	let expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
	new Assertion(list, flagMsg, ssfi, true).to.be.an("array");
	if (contains) this.assert(list.some(function(possibility) {
		return expected.indexOf(possibility) > -1;
	}), "expected #{this} to contain one of #{exp}", "expected #{this} to not contain one of #{exp}", list, expected);
	else if (isDeep) this.assert(list.some(function(possibility) {
		return eql(expected, possibility);
	}), "expected #{this} to deeply equal one of #{exp}", "expected #{this} to deeply equal one of #{exp}", list, expected);
	else this.assert(list.indexOf(expected) > -1, "expected #{this} to be one of #{exp}", "expected #{this} to not be one of #{exp}", list, expected);
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
	if (msg) flag2(this, "message", msg);
	let fn$1 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
	new Assertion(fn$1, flagMsg, ssfi, true).is.a("function");
	let initial;
	if (!prop) {
		new Assertion(subject, flagMsg, ssfi, true).is.a("function");
		initial = subject();
	} else {
		new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
		initial = subject[prop];
	}
	fn$1();
	let final = prop === void 0 || prop === null ? subject() : subject[prop];
	let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
	flag2(this, "deltaMsgObj", msgObj);
	flag2(this, "initialDeltaValue", initial);
	flag2(this, "finalDeltaValue", final);
	flag2(this, "deltaBehavior", "change");
	flag2(this, "realDelta", final !== initial);
	this.assert(initial !== final, "expected " + msgObj + " to change", "expected " + msgObj + " to not change");
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
	if (msg) flag2(this, "message", msg);
	let fn$1 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
	new Assertion(fn$1, flagMsg, ssfi, true).is.a("function");
	let initial;
	if (!prop) {
		new Assertion(subject, flagMsg, ssfi, true).is.a("function");
		initial = subject();
	} else {
		new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
		initial = subject[prop];
	}
	new Assertion(initial, flagMsg, ssfi, true).is.a("number");
	fn$1();
	let final = prop === void 0 || prop === null ? subject() : subject[prop];
	let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
	flag2(this, "deltaMsgObj", msgObj);
	flag2(this, "initialDeltaValue", initial);
	flag2(this, "finalDeltaValue", final);
	flag2(this, "deltaBehavior", "increase");
	flag2(this, "realDelta", final - initial);
	this.assert(final - initial > 0, "expected " + msgObj + " to increase", "expected " + msgObj + " to not increase");
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
	if (msg) flag2(this, "message", msg);
	let fn$1 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
	new Assertion(fn$1, flagMsg, ssfi, true).is.a("function");
	let initial;
	if (!prop) {
		new Assertion(subject, flagMsg, ssfi, true).is.a("function");
		initial = subject();
	} else {
		new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
		initial = subject[prop];
	}
	new Assertion(initial, flagMsg, ssfi, true).is.a("number");
	fn$1();
	let final = prop === void 0 || prop === null ? subject() : subject[prop];
	let msgObj = prop === void 0 || prop === null ? initial : "." + prop;
	flag2(this, "deltaMsgObj", msgObj);
	flag2(this, "initialDeltaValue", initial);
	flag2(this, "finalDeltaValue", final);
	flag2(this, "deltaBehavior", "decrease");
	flag2(this, "realDelta", initial - final);
	this.assert(final - initial < 0, "expected " + msgObj + " to decrease", "expected " + msgObj + " to not decrease");
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
	if (msg) flag2(this, "message", msg);
	let msgObj = flag2(this, "deltaMsgObj");
	let initial = flag2(this, "initialDeltaValue");
	let final = flag2(this, "finalDeltaValue");
	let behavior = flag2(this, "deltaBehavior");
	let realDelta = flag2(this, "realDelta");
	let expression;
	if (behavior === "change") expression = Math.abs(final - initial) === Math.abs(delta);
	else expression = realDelta === Math.abs(delta);
	this.assert(expression, "expected " + msgObj + " to " + behavior + " by " + delta, "expected " + msgObj + " to not " + behavior + " by " + delta);
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
	let obj = flag2(this, "object");
	let isExtensible = obj === Object(obj) && Object.isExtensible(obj);
	this.assert(isExtensible, "expected #{this} to be extensible", "expected #{this} to not be extensible");
});
Assertion.addProperty("sealed", function() {
	let obj = flag2(this, "object");
	let isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
	this.assert(isSealed, "expected #{this} to be sealed", "expected #{this} to not be sealed");
});
Assertion.addProperty("frozen", function() {
	let obj = flag2(this, "object");
	let isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
	this.assert(isFrozen, "expected #{this} to be frozen", "expected #{this} to not be frozen");
});
Assertion.addProperty("finite", function(_msg) {
	let obj = flag2(this, "object");
	this.assert(typeof obj === "number" && isFinite(obj), "expected #{this} to be a finite number", "expected #{this} to not be a finite number");
});
function compareSubset(expected, actual) {
	if (expected === actual) return true;
	if (typeof actual !== typeof expected) return false;
	if (typeof expected !== "object" || expected === null) return expected === actual;
	if (!actual) return false;
	if (Array.isArray(expected)) {
		if (!Array.isArray(actual)) return false;
		return expected.every(function(exp) {
			return actual.some(function(act) {
				return compareSubset(exp, act);
			});
		});
	}
	if (expected instanceof Date) if (actual instanceof Date) return expected.getTime() === actual.getTime();
	else return false;
	return Object.keys(expected).every(function(key) {
		let expectedValue = expected[key];
		let actualValue = actual[key];
		if (typeof expectedValue === "object" && expectedValue !== null && actualValue !== null) return compareSubset(expectedValue, actualValue);
		if (typeof expectedValue === "function") return expectedValue(actualValue);
		return actualValue === expectedValue;
	});
}
__name(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function(expected) {
	const actual = flag(this, "object");
	const showDiff = config.showDiff;
	this.assert(compareSubset(expected, actual), "expected #{act} to contain subset #{exp}", "expected #{act} to not contain subset #{exp}", expected, actual, showDiff);
});
function expect(val, message) {
	return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
	if (arguments.length < 2) {
		message = actual;
		actual = void 0;
	}
	message = message || "expect.fail()";
	throw new AssertionError(message, {
		actual,
		expected,
		operator
	}, expect.fail);
};
var should_exports = {};
__export(should_exports, {
	Should: () => Should,
	should: () => should
});
function loadShould() {
	function shouldGetter() {
		if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === "function" && this instanceof Symbol || typeof BigInt === "function" && this instanceof BigInt) return new Assertion(this.valueOf(), null, shouldGetter);
		return new Assertion(this, null, shouldGetter);
	}
	__name(shouldGetter, "shouldGetter");
	function shouldSetter(value) {
		Object.defineProperty(this, "should", {
			value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	}
	__name(shouldSetter, "shouldSetter");
	Object.defineProperty(Object.prototype, "should", {
		set: shouldSetter,
		get: shouldGetter,
		configurable: true
	});
	let should2 = {};
	should2.fail = function(actual, expected, message, operator) {
		if (arguments.length < 2) {
			message = actual;
			actual = void 0;
		}
		message = message || "should.fail()";
		throw new AssertionError(message, {
			actual,
			expected,
			operator
		}, should2.fail);
	};
	should2.equal = function(actual, expected, message) {
		new Assertion(actual, message).to.equal(expected);
	};
	should2.Throw = function(fn$1, errt, errs, msg) {
		new Assertion(fn$1, msg).to.Throw(errt, errs);
	};
	should2.exist = function(val, msg) {
		new Assertion(val, msg).to.exist;
	};
	should2.not = {};
	should2.not.equal = function(actual, expected, msg) {
		new Assertion(actual, msg).to.not.equal(expected);
	};
	should2.not.Throw = function(fn$1, errt, errs, msg) {
		new Assertion(fn$1, msg).to.not.Throw(errt, errs);
	};
	should2.not.exist = function(val, msg) {
		new Assertion(val, msg).to.not.exist;
	};
	should2["throw"] = should2["Throw"];
	should2.not["throw"] = should2.not["Throw"];
	return should2;
}
__name(loadShould, "loadShould");
var should = loadShould;
var Should = loadShould;
function assert$1(express, errmsg) {
	new Assertion(null, null, assert$1, true).assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert$1, "assert");
assert$1.fail = function(actual, expected, message, operator) {
	if (arguments.length < 2) {
		message = actual;
		actual = void 0;
	}
	message = message || "assert.fail()";
	throw new AssertionError(message, {
		actual,
		expected,
		operator
	}, assert$1.fail);
};
assert$1.isOk = function(val, msg) {
	new Assertion(val, msg, assert$1.isOk, true).is.ok;
};
assert$1.isNotOk = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotOk, true).is.not.ok;
};
assert$1.equal = function(act, exp, msg) {
	let test2 = new Assertion(act, msg, assert$1.equal, true);
	test2.assert(exp == flag(test2, "object"), "expected #{this} to equal #{exp}", "expected #{this} to not equal #{act}", exp, act, true);
};
assert$1.notEqual = function(act, exp, msg) {
	let test2 = new Assertion(act, msg, assert$1.notEqual, true);
	test2.assert(exp != flag(test2, "object"), "expected #{this} to not equal #{exp}", "expected #{this} to equal #{act}", exp, act, true);
};
assert$1.strictEqual = function(act, exp, msg) {
	new Assertion(act, msg, assert$1.strictEqual, true).to.equal(exp);
};
assert$1.notStrictEqual = function(act, exp, msg) {
	new Assertion(act, msg, assert$1.notStrictEqual, true).to.not.equal(exp);
};
assert$1.deepEqual = assert$1.deepStrictEqual = function(act, exp, msg) {
	new Assertion(act, msg, assert$1.deepEqual, true).to.eql(exp);
};
assert$1.notDeepEqual = function(act, exp, msg) {
	new Assertion(act, msg, assert$1.notDeepEqual, true).to.not.eql(exp);
};
assert$1.isAbove = function(val, abv, msg) {
	new Assertion(val, msg, assert$1.isAbove, true).to.be.above(abv);
};
assert$1.isAtLeast = function(val, atlst, msg) {
	new Assertion(val, msg, assert$1.isAtLeast, true).to.be.least(atlst);
};
assert$1.isBelow = function(val, blw, msg) {
	new Assertion(val, msg, assert$1.isBelow, true).to.be.below(blw);
};
assert$1.isAtMost = function(val, atmst, msg) {
	new Assertion(val, msg, assert$1.isAtMost, true).to.be.most(atmst);
};
assert$1.isTrue = function(val, msg) {
	new Assertion(val, msg, assert$1.isTrue, true).is["true"];
};
assert$1.isNotTrue = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotTrue, true).to.not.equal(true);
};
assert$1.isFalse = function(val, msg) {
	new Assertion(val, msg, assert$1.isFalse, true).is["false"];
};
assert$1.isNotFalse = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotFalse, true).to.not.equal(false);
};
assert$1.isNull = function(val, msg) {
	new Assertion(val, msg, assert$1.isNull, true).to.equal(null);
};
assert$1.isNotNull = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotNull, true).to.not.equal(null);
};
assert$1.isNaN = function(val, msg) {
	new Assertion(val, msg, assert$1.isNaN, true).to.be.NaN;
};
assert$1.isNotNaN = function(value, message) {
	new Assertion(value, message, assert$1.isNotNaN, true).not.to.be.NaN;
};
assert$1.exists = function(val, msg) {
	new Assertion(val, msg, assert$1.exists, true).to.exist;
};
assert$1.notExists = function(val, msg) {
	new Assertion(val, msg, assert$1.notExists, true).to.not.exist;
};
assert$1.isUndefined = function(val, msg) {
	new Assertion(val, msg, assert$1.isUndefined, true).to.equal(void 0);
};
assert$1.isDefined = function(val, msg) {
	new Assertion(val, msg, assert$1.isDefined, true).to.not.equal(void 0);
};
assert$1.isCallable = function(value, message) {
	new Assertion(value, message, assert$1.isCallable, true).is.callable;
};
assert$1.isNotCallable = function(value, message) {
	new Assertion(value, message, assert$1.isNotCallable, true).is.not.callable;
};
assert$1.isObject = function(val, msg) {
	new Assertion(val, msg, assert$1.isObject, true).to.be.a("object");
};
assert$1.isNotObject = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotObject, true).to.not.be.a("object");
};
assert$1.isArray = function(val, msg) {
	new Assertion(val, msg, assert$1.isArray, true).to.be.an("array");
};
assert$1.isNotArray = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotArray, true).to.not.be.an("array");
};
assert$1.isString = function(val, msg) {
	new Assertion(val, msg, assert$1.isString, true).to.be.a("string");
};
assert$1.isNotString = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotString, true).to.not.be.a("string");
};
assert$1.isNumber = function(val, msg) {
	new Assertion(val, msg, assert$1.isNumber, true).to.be.a("number");
};
assert$1.isNotNumber = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotNumber, true).to.not.be.a("number");
};
assert$1.isNumeric = function(val, msg) {
	new Assertion(val, msg, assert$1.isNumeric, true).is.numeric;
};
assert$1.isNotNumeric = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotNumeric, true).is.not.numeric;
};
assert$1.isFinite = function(val, msg) {
	new Assertion(val, msg, assert$1.isFinite, true).to.be.finite;
};
assert$1.isBoolean = function(val, msg) {
	new Assertion(val, msg, assert$1.isBoolean, true).to.be.a("boolean");
};
assert$1.isNotBoolean = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotBoolean, true).to.not.be.a("boolean");
};
assert$1.typeOf = function(val, type3, msg) {
	new Assertion(val, msg, assert$1.typeOf, true).to.be.a(type3);
};
assert$1.notTypeOf = function(value, type3, message) {
	new Assertion(value, message, assert$1.notTypeOf, true).to.not.be.a(type3);
};
assert$1.instanceOf = function(val, type3, msg) {
	new Assertion(val, msg, assert$1.instanceOf, true).to.be.instanceOf(type3);
};
assert$1.notInstanceOf = function(val, type3, msg) {
	new Assertion(val, msg, assert$1.notInstanceOf, true).to.not.be.instanceOf(type3);
};
assert$1.include = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.include, true).include(inc);
};
assert$1.notInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.notInclude, true).not.include(inc);
};
assert$1.deepInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.deepInclude, true).deep.include(inc);
};
assert$1.notDeepInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.notDeepInclude, true).not.deep.include(inc);
};
assert$1.nestedInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.nestedInclude, true).nested.include(inc);
};
assert$1.notNestedInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.notNestedInclude, true).not.nested.include(inc);
};
assert$1.deepNestedInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.deepNestedInclude, true).deep.nested.include(inc);
};
assert$1.notDeepNestedInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.notDeepNestedInclude, true).not.deep.nested.include(inc);
};
assert$1.ownInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.ownInclude, true).own.include(inc);
};
assert$1.notOwnInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.notOwnInclude, true).not.own.include(inc);
};
assert$1.deepOwnInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.deepOwnInclude, true).deep.own.include(inc);
};
assert$1.notDeepOwnInclude = function(exp, inc, msg) {
	new Assertion(exp, msg, assert$1.notDeepOwnInclude, true).not.deep.own.include(inc);
};
assert$1.match = function(exp, re, msg) {
	new Assertion(exp, msg, assert$1.match, true).to.match(re);
};
assert$1.notMatch = function(exp, re, msg) {
	new Assertion(exp, msg, assert$1.notMatch, true).to.not.match(re);
};
assert$1.property = function(obj, prop, msg) {
	new Assertion(obj, msg, assert$1.property, true).to.have.property(prop);
};
assert$1.notProperty = function(obj, prop, msg) {
	new Assertion(obj, msg, assert$1.notProperty, true).to.not.have.property(prop);
};
assert$1.propertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.propertyVal, true).to.have.property(prop, val);
};
assert$1.notPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.notPropertyVal, true).to.not.have.property(prop, val);
};
assert$1.deepPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.deepPropertyVal, true).to.have.deep.property(prop, val);
};
assert$1.notDeepPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
};
assert$1.ownProperty = function(obj, prop, msg) {
	new Assertion(obj, msg, assert$1.ownProperty, true).to.have.own.property(prop);
};
assert$1.notOwnProperty = function(obj, prop, msg) {
	new Assertion(obj, msg, assert$1.notOwnProperty, true).to.not.have.own.property(prop);
};
assert$1.ownPropertyVal = function(obj, prop, value, msg) {
	new Assertion(obj, msg, assert$1.ownPropertyVal, true).to.have.own.property(prop, value);
};
assert$1.notOwnPropertyVal = function(obj, prop, value, msg) {
	new Assertion(obj, msg, assert$1.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
};
assert$1.deepOwnPropertyVal = function(obj, prop, value, msg) {
	new Assertion(obj, msg, assert$1.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
};
assert$1.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
	new Assertion(obj, msg, assert$1.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
};
assert$1.nestedProperty = function(obj, prop, msg) {
	new Assertion(obj, msg, assert$1.nestedProperty, true).to.have.nested.property(prop);
};
assert$1.notNestedProperty = function(obj, prop, msg) {
	new Assertion(obj, msg, assert$1.notNestedProperty, true).to.not.have.nested.property(prop);
};
assert$1.nestedPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.nestedPropertyVal, true).to.have.nested.property(prop, val);
};
assert$1.notNestedPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
};
assert$1.deepNestedPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
};
assert$1.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
	new Assertion(obj, msg, assert$1.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
};
assert$1.lengthOf = function(exp, len, msg) {
	new Assertion(exp, msg, assert$1.lengthOf, true).to.have.lengthOf(len);
};
assert$1.hasAnyKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.hasAnyKeys, true).to.have.any.keys(keys$1);
};
assert$1.hasAllKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.hasAllKeys, true).to.have.all.keys(keys$1);
};
assert$1.containsAllKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.containsAllKeys, true).to.contain.all.keys(keys$1);
};
assert$1.doesNotHaveAnyKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys$1);
};
assert$1.doesNotHaveAllKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.doesNotHaveAllKeys, true).to.not.have.all.keys(keys$1);
};
assert$1.hasAnyDeepKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.hasAnyDeepKeys, true).to.have.any.deep.keys(keys$1);
};
assert$1.hasAllDeepKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.hasAllDeepKeys, true).to.have.all.deep.keys(keys$1);
};
assert$1.containsAllDeepKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.containsAllDeepKeys, true).to.contain.all.deep.keys(keys$1);
};
assert$1.doesNotHaveAnyDeepKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys$1);
};
assert$1.doesNotHaveAllDeepKeys = function(obj, keys$1, msg) {
	new Assertion(obj, msg, assert$1.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys$1);
};
assert$1.throws = function(fn$1, errorLike, errMsgMatcher, msg) {
	if ("string" === typeof errorLike || errorLike instanceof RegExp) {
		errMsgMatcher = errorLike;
		errorLike = null;
	}
	let assertErr = new Assertion(fn$1, msg, assert$1.throws, true).to.throw(errorLike, errMsgMatcher);
	return flag(assertErr, "object");
};
assert$1.doesNotThrow = function(fn$1, errorLike, errMsgMatcher, message) {
	if ("string" === typeof errorLike || errorLike instanceof RegExp) {
		errMsgMatcher = errorLike;
		errorLike = null;
	}
	new Assertion(fn$1, message, assert$1.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
};
assert$1.operator = function(val, operator, val2, msg) {
	let ok;
	switch (operator) {
		case "==":
			ok = val == val2;
			break;
		case "===":
			ok = val === val2;
			break;
		case ">":
			ok = val > val2;
			break;
		case ">=":
			ok = val >= val2;
			break;
		case "<":
			ok = val < val2;
			break;
		case "<=":
			ok = val <= val2;
			break;
		case "!=":
			ok = val != val2;
			break;
		case "!==":
			ok = val !== val2;
			break;
		default:
			msg = msg ? msg + ": " : msg;
			throw new AssertionError(msg + "Invalid operator \"" + operator + "\"", void 0, assert$1.operator);
	}
	let test2 = new Assertion(ok, msg, assert$1.operator, true);
	test2.assert(true === flag(test2, "object"), "expected " + inspect2(val) + " to be " + operator + " " + inspect2(val2), "expected " + inspect2(val) + " to not be " + operator + " " + inspect2(val2));
};
assert$1.closeTo = function(act, exp, delta, msg) {
	new Assertion(act, msg, assert$1.closeTo, true).to.be.closeTo(exp, delta);
};
assert$1.approximately = function(act, exp, delta, msg) {
	new Assertion(act, msg, assert$1.approximately, true).to.be.approximately(exp, delta);
};
assert$1.sameMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.sameMembers, true).to.have.same.members(set2);
};
assert$1.notSameMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.notSameMembers, true).to.not.have.same.members(set2);
};
assert$1.sameDeepMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.sameDeepMembers, true).to.have.same.deep.members(set2);
};
assert$1.notSameDeepMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
};
assert$1.sameOrderedMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.sameOrderedMembers, true).to.have.same.ordered.members(set2);
};
assert$1.notSameOrderedMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
};
assert$1.sameDeepOrderedMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
};
assert$1.notSameDeepOrderedMembers = function(set1, set2, msg) {
	new Assertion(set1, msg, assert$1.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
};
assert$1.includeMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.includeMembers, true).to.include.members(subset);
};
assert$1.notIncludeMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.notIncludeMembers, true).to.not.include.members(subset);
};
assert$1.includeDeepMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.includeDeepMembers, true).to.include.deep.members(subset);
};
assert$1.notIncludeDeepMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
};
assert$1.includeOrderedMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.includeOrderedMembers, true).to.include.ordered.members(subset);
};
assert$1.notIncludeOrderedMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
};
assert$1.includeDeepOrderedMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
};
assert$1.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
	new Assertion(superset, msg, assert$1.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
};
assert$1.oneOf = function(inList, list, msg) {
	new Assertion(inList, msg, assert$1.oneOf, true).to.be.oneOf(list);
};
assert$1.isIterable = function(obj, msg) {
	if (obj == void 0 || !obj[Symbol.iterator]) {
		msg = msg ? `${msg} expected ${inspect2(obj)} to be an iterable` : `expected ${inspect2(obj)} to be an iterable`;
		throw new AssertionError(msg, void 0, assert$1.isIterable);
	}
};
assert$1.changes = function(fn$1, obj, prop, msg) {
	if (arguments.length === 3 && typeof obj === "function") {
		msg = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.changes, true).to.change(obj, prop);
};
assert$1.changesBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.changesBy, true).to.change(obj, prop).by(delta);
};
assert$1.doesNotChange = function(fn$1, obj, prop, msg) {
	if (arguments.length === 3 && typeof obj === "function") {
		msg = prop;
		prop = null;
	}
	return new Assertion(fn$1, msg, assert$1.doesNotChange, true).to.not.change(obj, prop);
};
assert$1.changesButNotBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
};
assert$1.increases = function(fn$1, obj, prop, msg) {
	if (arguments.length === 3 && typeof obj === "function") {
		msg = prop;
		prop = null;
	}
	return new Assertion(fn$1, msg, assert$1.increases, true).to.increase(obj, prop);
};
assert$1.increasesBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.increasesBy, true).to.increase(obj, prop).by(delta);
};
assert$1.doesNotIncrease = function(fn$1, obj, prop, msg) {
	if (arguments.length === 3 && typeof obj === "function") {
		msg = prop;
		prop = null;
	}
	return new Assertion(fn$1, msg, assert$1.doesNotIncrease, true).to.not.increase(obj, prop);
};
assert$1.increasesButNotBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
};
assert$1.decreases = function(fn$1, obj, prop, msg) {
	if (arguments.length === 3 && typeof obj === "function") {
		msg = prop;
		prop = null;
	}
	return new Assertion(fn$1, msg, assert$1.decreases, true).to.decrease(obj, prop);
};
assert$1.decreasesBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.decreasesBy, true).to.decrease(obj, prop).by(delta);
};
assert$1.doesNotDecrease = function(fn$1, obj, prop, msg) {
	if (arguments.length === 3 && typeof obj === "function") {
		msg = prop;
		prop = null;
	}
	return new Assertion(fn$1, msg, assert$1.doesNotDecrease, true).to.not.decrease(obj, prop);
};
assert$1.doesNotDecreaseBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	return new Assertion(fn$1, msg, assert$1.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
};
assert$1.decreasesButNotBy = function(fn$1, obj, prop, delta, msg) {
	if (arguments.length === 4 && typeof obj === "function") {
		let tmpMsg = delta;
		delta = prop;
		msg = tmpMsg;
	} else if (arguments.length === 3) {
		delta = prop;
		prop = null;
	}
	new Assertion(fn$1, msg, assert$1.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
};
assert$1.ifError = function(val) {
	if (val) throw val;
};
assert$1.isExtensible = function(obj, msg) {
	new Assertion(obj, msg, assert$1.isExtensible, true).to.be.extensible;
};
assert$1.isNotExtensible = function(obj, msg) {
	new Assertion(obj, msg, assert$1.isNotExtensible, true).to.not.be.extensible;
};
assert$1.isSealed = function(obj, msg) {
	new Assertion(obj, msg, assert$1.isSealed, true).to.be.sealed;
};
assert$1.isNotSealed = function(obj, msg) {
	new Assertion(obj, msg, assert$1.isNotSealed, true).to.not.be.sealed;
};
assert$1.isFrozen = function(obj, msg) {
	new Assertion(obj, msg, assert$1.isFrozen, true).to.be.frozen;
};
assert$1.isNotFrozen = function(obj, msg) {
	new Assertion(obj, msg, assert$1.isNotFrozen, true).to.not.be.frozen;
};
assert$1.isEmpty = function(val, msg) {
	new Assertion(val, msg, assert$1.isEmpty, true).to.be.empty;
};
assert$1.isNotEmpty = function(val, msg) {
	new Assertion(val, msg, assert$1.isNotEmpty, true).to.not.be.empty;
};
assert$1.containsSubset = function(val, exp, msg) {
	new Assertion(val, msg).to.containSubset(exp);
};
assert$1.doesNotContainSubset = function(val, exp, msg) {
	new Assertion(val, msg).to.not.containSubset(exp);
};
for (const [name, as] of [
	["isOk", "ok"],
	["isNotOk", "notOk"],
	["throws", "throw"],
	["throws", "Throw"],
	["isExtensible", "extensible"],
	["isNotExtensible", "notExtensible"],
	["isSealed", "sealed"],
	["isNotSealed", "notSealed"],
	["isFrozen", "frozen"],
	["isNotFrozen", "notFrozen"],
	["isEmpty", "empty"],
	["isNotEmpty", "notEmpty"],
	["isCallable", "isFunction"],
	["isNotCallable", "isNotFunction"],
	["containsSubset", "containSubset"]
]) assert$1[as] = assert$1[name];
var used = [];
function use(fn$1) {
	const exports = {
		use,
		AssertionError,
		util: utils_exports,
		config,
		expect,
		assert: assert$1,
		Assertion,
		...should_exports
	};
	if (!~used.indexOf(fn$1)) {
		fn$1(exports, utils_exports);
		used.push(fn$1);
	}
	return exports;
}
__name(use, "use");
/*!
* Chai - flag utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - test utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - expectTypes utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getActual utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - message composition utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - transferFlags utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* chai
* http://chaijs.com
* Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - isProxyEnabled helper
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - addProperty utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - addLengthGuard utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getProperties utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - proxify utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - addMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - overwriteProperty utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - overwriteMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - addChainingMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - overwriteChainableMethod utility
* Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - compareByInspect utility
* Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getOwnEnumerablePropertySymbols utility
* Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - getOwnEnumerableProperties utility
* Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* Chai - isNaN utility
* Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
* MIT Licensed
*/
/*!
* chai
* Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*!
* chai
* Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*/
/*! Bundled license information:

deep-eql/index.js:
(*!
* deep-eql
* Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
* MIT Licensed
*)
(*!
* Check to see if the MemoizeMap has recorded a result of the two operands
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {MemoizeMap} memoizeMap
* @returns {Boolean|null} result
*)
(*!
* Set the result of the equality into the MemoizeMap
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {MemoizeMap} memoizeMap
* @param {Boolean} result
*)
(*!
* Primary Export
*)
(*!
* The main logic of the `deepEqual` function.
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {Object} [options] (optional) Additional options
* @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
* @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
references to blow the stack.
* @return {Boolean} equal match
*)
(*!
* Compare two Regular Expressions for equality.
*
* @param {RegExp} leftHandOperand
* @param {RegExp} rightHandOperand
* @return {Boolean} result
*)
(*!
* Compare two Sets/Maps for equality. Faster than other equality functions.
*
* @param {Set} leftHandOperand
* @param {Set} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*)
(*!
* Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
*
* @param {Iterable} leftHandOperand
* @param {Iterable} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*)
(*!
* Simple equality for generator objects such as those returned by generator functions.
*
* @param {Iterable} leftHandOperand
* @param {Iterable} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*)
(*!
* Determine if the given object has an @@iterator function.
*
* @param {Object} target
* @return {Boolean} `true` if the object has an @@iterator function.
*)
(*!
* Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
* This will consume the iterator - which could have side effects depending on the @@iterator implementation.
*
* @param {Object} target
* @returns {Array} an array of entries from the @@iterator function
*)
(*!
* Gets all entries from a Generator. This will consume the generator - which could have side effects.
*
* @param {Generator} target
* @returns {Array} an array of entries from the Generator.
*)
(*!
* Gets all own and inherited enumerable keys from a target.
*
* @param {Object} target
* @returns {Array} an array of own and inherited enumerable keys from the target.
*)
(*!
* Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
* each key. If any value of the given key is not equal, the function will return false (early).
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
* @param {Object} [options] (Optional)
* @return {Boolean} result
*)
(*!
* Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
* for each enumerable key in the object.
*
* @param {Mixed} leftHandOperand
* @param {Mixed} rightHandOperand
* @param {Object} [options] (Optional)
* @return {Boolean} result
*)
(*!
* Returns true if the argument is a primitive.
*
* This intentionally returns true for all objects that can be compared by reference,
* including functions and symbols.
*
* @param {Mixed} value
* @return {Boolean} result
*)
*/

//#endregion
//#region node_modules/.pnpm/@vitest+expect@3.2.4/node_modules/@vitest/expect/dist/index.js
const MATCHERS_OBJECT = Symbol.for("matchers-object");
const JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object");
const GLOBAL_EXPECT = Symbol.for("expect-global");
const ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object");
const customMatchers = {
	toSatisfy(actual, expected, message) {
		const { printReceived: printReceived$2, printExpected: printExpected$2, matcherHint: matcherHint$1 } = this.utils;
		const pass = expected(actual);
		return {
			pass,
			message: () => pass ? `\
${matcherHint$1(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${message || printExpected$2(expected)}
Received:
${printReceived$2(actual)}` : `\
${matcherHint$1(".toSatisfy", "received", "")}

Expected value to satisfy:
${message || printExpected$2(expected)}

Received:
${printReceived$2(actual)}`
		};
	},
	toBeOneOf(actual, expected) {
		const { equals: equals$1, customTesters } = this;
		const { printReceived: printReceived$2, printExpected: printExpected$2, matcherHint: matcherHint$1 } = this.utils;
		if (!Array.isArray(expected)) throw new TypeError(`You must provide an array to ${matcherHint$1(".toBeOneOf")}, not '${typeof expected}'.`);
		const pass = expected.length === 0 || expected.some((item) => equals$1(item, actual, customTesters));
		return {
			pass,
			message: () => pass ? `\
${matcherHint$1(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${printExpected$2(expected)}
Received:
${printReceived$2(actual)}` : `\
${matcherHint$1(".toBeOneOf", "received", "")}

Expected value to be one of:
${printExpected$2(expected)}

Received:
${printReceived$2(actual)}`
		};
	}
};
const EXPECTED_COLOR = u.green;
const RECEIVED_COLOR = u.red;
const INVERTED_COLOR = u.inverse;
const BOLD_WEIGHT = u.bold;
const DIM_COLOR = u.dim;
function matcherHint(matcherName, received = "received", expected = "expected", options = {}) {
	const { comment = "", isDirectExpectCall = false, isNot = false, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options;
	let hint = "";
	let dimString = "expect";
	if (!isDirectExpectCall && received !== "") {
		hint += DIM_COLOR(`${dimString}(`) + receivedColor(received);
		dimString = ")";
	}
	if (promise !== "") {
		hint += DIM_COLOR(`${dimString}.`) + promise;
		dimString = "";
	}
	if (isNot) {
		hint += `${DIM_COLOR(`${dimString}.`)}not`;
		dimString = "";
	}
	if (matcherName.includes(".")) dimString += matcherName;
	else {
		hint += DIM_COLOR(`${dimString}.`) + matcherName;
		dimString = "";
	}
	if (expected === "") dimString += "()";
	else {
		hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected);
		if (secondArgument) hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument);
		dimString = ")";
	}
	if (comment !== "") dimString += ` // ${comment}`;
	if (dimString !== "") hint += DIM_COLOR(dimString);
	return hint;
}
const SPACE_SYMBOL = "·";
function replaceTrailingSpaces(text) {
	return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
function printReceived(object$1) {
	return RECEIVED_COLOR(replaceTrailingSpaces(stringify(object$1)));
}
function printExpected(value) {
	return EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));
}
function getMatcherUtils() {
	return {
		EXPECTED_COLOR,
		RECEIVED_COLOR,
		INVERTED_COLOR,
		BOLD_WEIGHT,
		DIM_COLOR,
		diff,
		matcherHint,
		printReceived,
		printExpected,
		printDiffOrStringify,
		printWithType
	};
}
function printWithType(name, value, print) {
	const type$1 = getType(value);
	const hasType = type$1 !== "null" && type$1 !== "undefined" ? `${name} has type:  ${type$1}\n` : "";
	const hasValue = `${name} has value: ${print(value)}`;
	return hasType + hasValue;
}
function addCustomEqualityTesters(newTesters) {
	if (!Array.isArray(newTesters)) throw new TypeError(`expect.customEqualityTesters: Must be set to an array of Testers. Was given "${getType(newTesters)}"`);
	globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters.push(...newTesters);
}
function getCustomEqualityTesters() {
	return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
function equals(a$2, b$1, customTesters, strictCheck) {
	customTesters = customTesters || [];
	return eq(a$2, b$1, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
const functionToString = Function.prototype.toString;
function isAsymmetric(obj) {
	return !!obj && typeof obj === "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a$2, b$1) {
	const asymmetricA = isAsymmetric(a$2);
	const asymmetricB = isAsymmetric(b$1);
	if (asymmetricA && asymmetricB) return;
	if (asymmetricA) return a$2.asymmetricMatch(b$1);
	if (asymmetricB) return b$1.asymmetricMatch(a$2);
}
function eq(a$2, b$1, aStack, bStack, customTesters, hasKey$1) {
	let result = true;
	const asymmetricResult = asymmetricMatch(a$2, b$1);
	if (asymmetricResult !== void 0) return asymmetricResult;
	const testerContext = { equals };
	for (let i = 0; i < customTesters.length; i++) {
		const customTesterResult = customTesters[i].call(testerContext, a$2, b$1, customTesters);
		if (customTesterResult !== void 0) return customTesterResult;
	}
	if (typeof URL === "function" && a$2 instanceof URL && b$1 instanceof URL) return a$2.href === b$1.href;
	if (Object.is(a$2, b$1)) return true;
	if (a$2 === null || b$1 === null) return a$2 === b$1;
	const className = Object.prototype.toString.call(a$2);
	if (className !== Object.prototype.toString.call(b$1)) return false;
	switch (className) {
		case "[object Boolean]":
		case "[object String]":
		case "[object Number]": if (typeof a$2 !== typeof b$1) return false;
		else if (typeof a$2 !== "object" && typeof b$1 !== "object") return Object.is(a$2, b$1);
		else return Object.is(a$2.valueOf(), b$1.valueOf());
		case "[object Date]": {
			const numA = +a$2;
			const numB = +b$1;
			return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
		}
		case "[object RegExp]": return a$2.source === b$1.source && a$2.flags === b$1.flags;
		case "[object Temporal.Instant]":
		case "[object Temporal.ZonedDateTime]":
		case "[object Temporal.PlainDateTime]":
		case "[object Temporal.PlainDate]":
		case "[object Temporal.PlainTime]":
		case "[object Temporal.PlainYearMonth]":
		case "[object Temporal.PlainMonthDay]": return a$2.equals(b$1);
		case "[object Temporal.Duration]": return a$2.toString() === b$1.toString();
	}
	if (typeof a$2 !== "object" || typeof b$1 !== "object") return false;
	if (isDomNode(a$2) && isDomNode(b$1)) return a$2.isEqualNode(b$1);
	let length = aStack.length;
	while (length--) if (aStack[length] === a$2) return bStack[length] === b$1;
	else if (bStack[length] === b$1) return false;
	aStack.push(a$2);
	bStack.push(b$1);
	if (className === "[object Array]" && a$2.length !== b$1.length) return false;
	if (a$2 instanceof Error && b$1 instanceof Error) try {
		return isErrorEqual(a$2, b$1, aStack, bStack, customTesters, hasKey$1);
	} finally {
		aStack.pop();
		bStack.pop();
	}
	const aKeys = keys(a$2, hasKey$1);
	let key;
	let size = aKeys.length;
	if (keys(b$1, hasKey$1).length !== size) return false;
	while (size--) {
		key = aKeys[size];
		result = hasKey$1(b$1, key) && eq(a$2[key], b$1[key], aStack, bStack, customTesters, hasKey$1);
		if (!result) return false;
	}
	aStack.pop();
	bStack.pop();
	return result;
}
function isErrorEqual(a$2, b$1, aStack, bStack, customTesters, hasKey$1) {
	let result = Object.getPrototypeOf(a$2) === Object.getPrototypeOf(b$1) && a$2.name === b$1.name && a$2.message === b$1.message;
	if (typeof b$1.cause !== "undefined") result && (result = eq(a$2.cause, b$1.cause, aStack, bStack, customTesters, hasKey$1));
	if (a$2 instanceof AggregateError && b$1 instanceof AggregateError) result && (result = eq(a$2.errors, b$1.errors, aStack, bStack, customTesters, hasKey$1));
	result && (result = eq({ ...a$2 }, { ...b$1 }, aStack, bStack, customTesters, hasKey$1));
	return result;
}
function keys(obj, hasKey$1) {
	const keys$1 = [];
	for (const key in obj) if (hasKey$1(obj, key)) keys$1.push(key);
	return keys$1.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key) {
	return hasKey(obj, key) && obj[key] !== void 0;
}
function hasKey(obj, key) {
	return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
	return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
function isDomNode(obj) {
	return obj !== null && typeof obj === "object" && "nodeType" in obj && typeof obj.nodeType === "number" && "nodeName" in obj && typeof obj.nodeName === "string" && "isEqualNode" in obj && typeof obj.isEqualNode === "function";
}
const IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
const IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
const IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
const IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
const IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
	return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL] && !maybeKeyed[IS_ORDERED_SENTINEL]);
}
function isImmutableUnorderedSet(maybeSet) {
	return !!(maybeSet && maybeSet[IS_SET_SENTINEL] && !maybeSet[IS_ORDERED_SENTINEL]);
}
function isObjectLiteral(source) {
	return source != null && typeof source === "object" && !Array.isArray(source);
}
function isImmutableList(source) {
	return Boolean(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL]);
}
function isImmutableOrderedKeyed(source) {
	return Boolean(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL] && source[IS_ORDERED_SENTINEL]);
}
function isImmutableOrderedSet(source) {
	return Boolean(source && isObjectLiteral(source) && source[IS_SET_SENTINEL] && source[IS_ORDERED_SENTINEL]);
}
function isImmutableRecord(source) {
	return Boolean(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL]);
}
/**
* Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
*/
const IteratorSymbol = Symbol.iterator;
function hasIterator(object$1) {
	return !!(object$1 != null && object$1[IteratorSymbol]);
}
function iterableEquality(a$2, b$1, customTesters = [], aStack = [], bStack = []) {
	if (typeof a$2 !== "object" || typeof b$1 !== "object" || Array.isArray(a$2) || Array.isArray(b$1) || !hasIterator(a$2) || !hasIterator(b$1)) return;
	if (a$2.constructor !== b$1.constructor) return false;
	let length = aStack.length;
	while (length--) if (aStack[length] === a$2) return bStack[length] === b$1;
	aStack.push(a$2);
	bStack.push(b$1);
	const filteredCustomTesters = [...customTesters.filter((t) => t !== iterableEquality), iterableEqualityWithStack];
	function iterableEqualityWithStack(a$3, b$2) {
		return iterableEquality(a$3, b$2, [...customTesters], [...aStack], [...bStack]);
	}
	if (a$2.size !== void 0) {
		if (a$2.size !== b$1.size) return false;
		else if (isA("Set", a$2) || isImmutableUnorderedSet(a$2)) {
			let allFound = true;
			for (const aValue of a$2) if (!b$1.has(aValue)) {
				let has = false;
				for (const bValue of b$1) if (equals(aValue, bValue, filteredCustomTesters) === true) has = true;
				if (has === false) {
					allFound = false;
					break;
				}
			}
			aStack.pop();
			bStack.pop();
			return allFound;
		} else if (isA("Map", a$2) || isImmutableUnorderedKeyed(a$2)) {
			let allFound = true;
			for (const aEntry of a$2) if (!b$1.has(aEntry[0]) || !equals(aEntry[1], b$1.get(aEntry[0]), filteredCustomTesters)) {
				let has = false;
				for (const bEntry of b$1) {
					const matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters);
					let matchedValue = false;
					if (matchedKey === true) matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters);
					if (matchedValue === true) has = true;
				}
				if (has === false) {
					allFound = false;
					break;
				}
			}
			aStack.pop();
			bStack.pop();
			return allFound;
		}
	}
	const bIterator = b$1[IteratorSymbol]();
	for (const aValue of a$2) {
		const nextB = bIterator.next();
		if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters)) return false;
	}
	if (!bIterator.next().done) return false;
	if (!isImmutableList(a$2) && !isImmutableOrderedKeyed(a$2) && !isImmutableOrderedSet(a$2) && !isImmutableRecord(a$2)) {
		const aEntries = Object.entries(a$2);
		const bEntries = Object.entries(b$1);
		if (!equals(aEntries, bEntries, filteredCustomTesters)) return false;
	}
	aStack.pop();
	bStack.pop();
	return true;
}
/**
* Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.
*/
function hasPropertyInObject(object$1, key) {
	if (!object$1 || typeof object$1 !== "object" || object$1 === Object.prototype) return false;
	return Object.prototype.hasOwnProperty.call(object$1, key) || hasPropertyInObject(Object.getPrototypeOf(object$1), key);
}
function isObjectWithKeys(a$2) {
	return isObject$1(a$2) && !(a$2 instanceof Error) && !Array.isArray(a$2) && !(a$2 instanceof Date);
}
function subsetEquality(object$1, subset, customTesters = []) {
	const filteredCustomTesters = customTesters.filter((t) => t !== subsetEquality);
	const subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object$2, subset$1) => {
		if (!isObjectWithKeys(subset$1)) return;
		return Object.keys(subset$1).every((key) => {
			if (subset$1[key] != null && typeof subset$1[key] === "object") {
				if (seenReferences.has(subset$1[key])) return equals(object$2[key], subset$1[key], filteredCustomTesters);
				seenReferences.set(subset$1[key], true);
			}
			const result = object$2 != null && hasPropertyInObject(object$2, key) && equals(object$2[key], subset$1[key], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
			seenReferences.delete(subset$1[key]);
			return result;
		});
	};
	return subsetEqualityWithContext()(object$1, subset);
}
function typeEquality(a$2, b$1) {
	if (a$2 == null || b$1 == null || a$2.constructor === b$1.constructor) return;
	return false;
}
function arrayBufferEquality(a$2, b$1) {
	let dataViewA = a$2;
	let dataViewB = b$1;
	if (!(a$2 instanceof DataView && b$1 instanceof DataView)) {
		if (!(a$2 instanceof ArrayBuffer) || !(b$1 instanceof ArrayBuffer)) return;
		try {
			dataViewA = new DataView(a$2);
			dataViewB = new DataView(b$1);
		} catch {
			return;
		}
	}
	if (dataViewA.byteLength !== dataViewB.byteLength) return false;
	for (let i = 0; i < dataViewA.byteLength; i++) if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) return false;
	return true;
}
function sparseArrayEquality(a$2, b$1, customTesters = []) {
	if (!Array.isArray(a$2) || !Array.isArray(b$1)) return;
	const aKeys = Object.keys(a$2);
	const bKeys = Object.keys(b$1);
	const filteredCustomTesters = customTesters.filter((t) => t !== sparseArrayEquality);
	return equals(a$2, b$1, filteredCustomTesters, true) && equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
	const toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
	if (["toStrictEqual", "toEqual"].includes(deepEqualityName)) return `${toBeMessage}\n\nIf it should pass with deep equality, replace "toBe" with "${deepEqualityName}"\n\nExpected: ${expected}\nReceived: serializes to the same string\n`;
	return toBeMessage;
}
function pluralize(word, count) {
	return `${count} ${word}${count === 1 ? "" : "s"}`;
}
function getObjectKeys(object$1) {
	return [...Object.keys(object$1), ...Object.getOwnPropertySymbols(object$1).filter((s) => {
		var _Object$getOwnPropert;
		return (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object$1, s)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.enumerable;
	})];
}
function getObjectSubset(object$1, subset, customTesters) {
	let stripped = 0;
	const getObjectSubsetWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object$2, subset$1) => {
		if (Array.isArray(object$2)) {
			if (Array.isArray(subset$1) && subset$1.length === object$2.length) return subset$1.map((sub, i) => getObjectSubsetWithContext(seenReferences)(object$2[i], sub));
		} else if (object$2 instanceof Date) return object$2;
		else if (isObject$1(object$2) && isObject$1(subset$1)) {
			if (equals(object$2, subset$1, [
				...customTesters,
				iterableEquality,
				subsetEquality
			])) return subset$1;
			const trimmed = {};
			seenReferences.set(object$2, trimmed);
			if (typeof object$2.constructor === "function" && typeof object$2.constructor.name === "string") Object.defineProperty(trimmed, "constructor", {
				enumerable: false,
				value: object$2.constructor
			});
			for (const key of getObjectKeys(object$2)) if (hasPropertyInObject(subset$1, key)) trimmed[key] = seenReferences.has(object$2[key]) ? seenReferences.get(object$2[key]) : getObjectSubsetWithContext(seenReferences)(object$2[key], subset$1[key]);
			else if (!seenReferences.has(object$2[key])) {
				stripped += 1;
				if (isObject$1(object$2[key])) stripped += getObjectKeys(object$2[key]).length;
				getObjectSubsetWithContext(seenReferences)(object$2[key], subset$1[key]);
			}
			if (getObjectKeys(trimmed).length > 0) return trimmed;
		}
		return object$2;
	};
	return {
		subset: getObjectSubsetWithContext()(object$1, subset),
		stripped
	};
}
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
	const globalState = /* @__PURE__ */ new WeakMap();
	const matchers = Object.create(null);
	const customEqualityTesters = [];
	const asymmetricMatchers = Object.create(null);
	Object.defineProperty(globalThis, MATCHERS_OBJECT, { get: () => globalState });
	Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
		configurable: true,
		get: () => ({
			state: globalState.get(globalThis[GLOBAL_EXPECT]),
			matchers,
			customEqualityTesters
		})
	});
	Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, { get: () => asymmetricMatchers });
}
function getState(expect$1) {
	return globalThis[MATCHERS_OBJECT].get(expect$1);
}
function setState(state, expect$1) {
	const map$1 = globalThis[MATCHERS_OBJECT];
	const current = map$1.get(expect$1) || {};
	const results = Object.defineProperties(current, {
		...Object.getOwnPropertyDescriptors(current),
		...Object.getOwnPropertyDescriptors(state)
	});
	map$1.set(expect$1, results);
}
var AsymmetricMatcher$2 = class {
	$$typeof = Symbol.for("jest.asymmetricMatcher");
	constructor(sample, inverse = false) {
		this.sample = sample;
		this.inverse = inverse;
	}
	getMatcherContext(expect$1) {
		return {
			...getState(expect$1 || globalThis[GLOBAL_EXPECT]),
			equals,
			isNot: this.inverse,
			customTesters: getCustomEqualityTesters(),
			utils: {
				...getMatcherUtils(),
				diff,
				stringify,
				iterableEquality,
				subsetEquality
			}
		};
	}
};
AsymmetricMatcher$2.prototype[Symbol.for("chai/inspect")] = function(options) {
	const result = stringify(this, options.depth, { min: true });
	if (result.length <= options.truncate) return result;
	return `${this.toString()}{…}`;
};
var StringContaining = class extends AsymmetricMatcher$2 {
	constructor(sample, inverse = false) {
		if (!isA("String", sample)) throw new Error("Expected is not a string");
		super(sample, inverse);
	}
	asymmetricMatch(other) {
		const result = isA("String", other) && other.includes(this.sample);
		return this.inverse ? !result : result;
	}
	toString() {
		return `String${this.inverse ? "Not" : ""}Containing`;
	}
	getExpectedType() {
		return "string";
	}
};
var Anything = class extends AsymmetricMatcher$2 {
	asymmetricMatch(other) {
		return other != null;
	}
	toString() {
		return "Anything";
	}
	toAsymmetricMatcher() {
		return "Anything";
	}
};
var ObjectContaining = class extends AsymmetricMatcher$2 {
	constructor(sample, inverse = false) {
		super(sample, inverse);
	}
	getPrototype(obj) {
		if (Object.getPrototypeOf) return Object.getPrototypeOf(obj);
		if (obj.constructor.prototype === obj) return null;
		return obj.constructor.prototype;
	}
	hasProperty(obj, property) {
		if (!obj) return false;
		if (Object.prototype.hasOwnProperty.call(obj, property)) return true;
		return this.hasProperty(this.getPrototype(obj), property);
	}
	asymmetricMatch(other) {
		if (typeof this.sample !== "object") throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
		let result = true;
		const matcherContext = this.getMatcherContext();
		for (const property in this.sample) if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
			result = false;
			break;
		}
		return this.inverse ? !result : result;
	}
	toString() {
		return `Object${this.inverse ? "Not" : ""}Containing`;
	}
	getExpectedType() {
		return "object";
	}
};
var ArrayContaining = class extends AsymmetricMatcher$2 {
	constructor(sample, inverse = false) {
		super(sample, inverse);
	}
	asymmetricMatch(other) {
		if (!Array.isArray(this.sample)) throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
		const matcherContext = this.getMatcherContext();
		const result = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => equals(item, another, matcherContext.customTesters)));
		return this.inverse ? !result : result;
	}
	toString() {
		return `Array${this.inverse ? "Not" : ""}Containing`;
	}
	getExpectedType() {
		return "array";
	}
};
var Any = class extends AsymmetricMatcher$2 {
	constructor(sample) {
		if (typeof sample === "undefined") throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
		super(sample);
	}
	fnNameFor(func) {
		if (func.name) return func.name;
		const matches = Function.prototype.toString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
		return matches ? matches[1] : "<anonymous>";
	}
	asymmetricMatch(other) {
		if (this.sample === String) return typeof other == "string" || other instanceof String;
		if (this.sample === Number) return typeof other == "number" || other instanceof Number;
		if (this.sample === Function) return typeof other == "function" || typeof other === "function";
		if (this.sample === Boolean) return typeof other == "boolean" || other instanceof Boolean;
		if (this.sample === BigInt) return typeof other == "bigint" || other instanceof BigInt;
		if (this.sample === Symbol) return typeof other == "symbol" || other instanceof Symbol;
		if (this.sample === Object) return typeof other == "object";
		return other instanceof this.sample;
	}
	toString() {
		return "Any";
	}
	getExpectedType() {
		if (this.sample === String) return "string";
		if (this.sample === Number) return "number";
		if (this.sample === Function) return "function";
		if (this.sample === Object) return "object";
		if (this.sample === Boolean) return "boolean";
		return this.fnNameFor(this.sample);
	}
	toAsymmetricMatcher() {
		return `Any<${this.fnNameFor(this.sample)}>`;
	}
};
var StringMatching = class extends AsymmetricMatcher$2 {
	constructor(sample, inverse = false) {
		if (!isA("String", sample) && !isA("RegExp", sample)) throw new Error("Expected is not a String or a RegExp");
		super(new RegExp(sample), inverse);
	}
	asymmetricMatch(other) {
		const result = isA("String", other) && this.sample.test(other);
		return this.inverse ? !result : result;
	}
	toString() {
		return `String${this.inverse ? "Not" : ""}Matching`;
	}
	getExpectedType() {
		return "string";
	}
};
var CloseTo = class extends AsymmetricMatcher$2 {
	precision;
	constructor(sample, precision = 2, inverse = false) {
		if (!isA("Number", sample)) throw new Error("Expected is not a Number");
		if (!isA("Number", precision)) throw new Error("Precision is not a Number");
		super(sample);
		this.inverse = inverse;
		this.precision = precision;
	}
	asymmetricMatch(other) {
		if (!isA("Number", other)) return false;
		let result = false;
		if (other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY) result = true;
		else if (other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY) result = true;
		else result = Math.abs(this.sample - other) < 10 ** -this.precision / 2;
		return this.inverse ? !result : result;
	}
	toString() {
		return `Number${this.inverse ? "Not" : ""}CloseTo`;
	}
	getExpectedType() {
		return "number";
	}
	toAsymmetricMatcher() {
		return [
			this.toString(),
			this.sample,
			`(${pluralize("digit", this.precision)})`
		].join(" ");
	}
};
const JestAsymmetricMatchers = (chai$1, utils) => {
	utils.addMethod(chai$1.expect, "anything", () => new Anything());
	utils.addMethod(chai$1.expect, "any", (expected) => new Any(expected));
	utils.addMethod(chai$1.expect, "stringContaining", (expected) => new StringContaining(expected));
	utils.addMethod(chai$1.expect, "objectContaining", (expected) => new ObjectContaining(expected));
	utils.addMethod(chai$1.expect, "arrayContaining", (expected) => new ArrayContaining(expected));
	utils.addMethod(chai$1.expect, "stringMatching", (expected) => new StringMatching(expected));
	utils.addMethod(chai$1.expect, "closeTo", (expected, precision) => new CloseTo(expected, precision));
	chai$1.expect.not = {
		stringContaining: (expected) => new StringContaining(expected, true),
		objectContaining: (expected) => new ObjectContaining(expected, true),
		arrayContaining: (expected) => new ArrayContaining(expected, true),
		stringMatching: (expected) => new StringMatching(expected, true),
		closeTo: (expected, precision) => new CloseTo(expected, precision, true)
	};
};
function createAssertionMessage$1(util, assertion, hasArgs) {
	const not = util.flag(assertion, "negate") ? "not." : "";
	const name = `${util.flag(assertion, "_name")}(${hasArgs ? "expected" : ""})`;
	const promiseName = util.flag(assertion, "promise");
	return `expect(actual)${promiseName ? `.${promiseName}` : ""}.${not}${name}`;
}
function recordAsyncExpect$1(_test$1, promise, assertion, error) {
	const test$7 = _test$1;
	if (test$7 && promise instanceof Promise) {
		promise = promise.finally(() => {
			if (!test$7.promises) return;
			const index = test$7.promises.indexOf(promise);
			if (index !== -1) test$7.promises.splice(index, 1);
		});
		if (!test$7.promises) test$7.promises = [];
		test$7.promises.push(promise);
		let resolved = false;
		test$7.onFinished ?? (test$7.onFinished = []);
		test$7.onFinished.push(() => {
			if (!resolved) {
				var _vitest_worker__;
				const stack = (((_vitest_worker__ = globalThis.__vitest_worker__) === null || _vitest_worker__ === void 0 ? void 0 : _vitest_worker__.onFilterStackTrace) || ((s) => s || ""))(error.stack);
				console.warn([
					`Promise returned by \`${assertion}\` was not awaited. `,
					"Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
					"Please remember to await the assertion.\n",
					stack
				].join(""));
			}
		});
		return {
			then(onFulfilled, onRejected) {
				resolved = true;
				return promise.then(onFulfilled, onRejected);
			},
			catch(onRejected) {
				return promise.catch(onRejected);
			},
			finally(onFinally) {
				return promise.finally(onFinally);
			},
			[Symbol.toStringTag]: "Promise"
		};
	}
	return promise;
}
function handleTestError(test$7, err) {
	var _test$result;
	test$7.result || (test$7.result = { state: "fail" });
	test$7.result.state = "fail";
	(_test$result = test$7.result).errors || (_test$result.errors = []);
	test$7.result.errors.push(processError(err));
}
function wrapAssertion(utils, name, fn$1) {
	return function(...args) {
		if (name !== "withTest") utils.flag(this, "_name", name);
		if (!utils.flag(this, "soft")) return fn$1.apply(this, args);
		const test$7 = utils.flag(this, "vitest-test");
		if (!test$7) throw new Error("expect.soft() can only be used inside a test");
		try {
			const result = fn$1.apply(this, args);
			if (result && typeof result === "object" && typeof result.then === "function") return result.then(noop, (err) => {
				handleTestError(test$7, err);
			});
			return result;
		} catch (err) {
			handleTestError(test$7, err);
		}
	};
}
const JestChaiExpect = (chai$1, utils) => {
	const { AssertionError: AssertionError$1 } = chai$1;
	const customTesters = getCustomEqualityTesters();
	function def(name, fn$1) {
		const addMethod$1 = (n) => {
			const softWrapper = wrapAssertion(utils, n, fn$1);
			utils.addMethod(chai$1.Assertion.prototype, n, softWrapper);
			utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n, softWrapper);
		};
		if (Array.isArray(name)) name.forEach((n) => addMethod$1(n));
		else addMethod$1(name);
	}
	[
		"throw",
		"throws",
		"Throw"
	].forEach((m$1) => {
		utils.overwriteMethod(chai$1.Assertion.prototype, m$1, (_super) => {
			return function(...args) {
				const promise = utils.flag(this, "promise");
				const object$1 = utils.flag(this, "object");
				const isNot = utils.flag(this, "negate");
				if (promise === "rejects") utils.flag(this, "object", () => {
					throw object$1;
				});
				else if (promise === "resolves" && typeof object$1 !== "function") if (!isNot) {
					const message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
					throw new AssertionError$1(message, { showDiff: false }, utils.flag(this, "ssfi"));
				} else return;
				_super.apply(this, args);
			};
		});
	});
	def("withTest", function(test$7) {
		utils.flag(this, "vitest-test", test$7);
		return this;
	});
	def("toEqual", function(expected) {
		const actual = utils.flag(this, "object");
		const equal = equals(actual, expected, [...customTesters, iterableEquality]);
		return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
	});
	def("toStrictEqual", function(expected) {
		const obj = utils.flag(this, "object");
		const equal = equals(obj, expected, [
			...customTesters,
			iterableEquality,
			typeEquality,
			sparseArrayEquality,
			arrayBufferEquality
		], true);
		return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
	});
	def("toBe", function(expected) {
		const actual = this._obj;
		const pass = Object.is(actual, expected);
		let deepEqualityName = "";
		if (!pass) {
			if (equals(actual, expected, [
				...customTesters,
				iterableEquality,
				typeEquality,
				sparseArrayEquality,
				arrayBufferEquality
			], true)) deepEqualityName = "toStrictEqual";
			else if (equals(actual, expected, [...customTesters, iterableEquality])) deepEqualityName = "toEqual";
		}
		return this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
	});
	def("toMatchObject", function(expected) {
		const actual = this._obj;
		const pass = equals(actual, expected, [
			...customTesters,
			iterableEquality,
			subsetEquality
		]);
		const isNot = utils.flag(this, "negate");
		const { subset: actualSubset, stripped } = getObjectSubset(actual, expected, customTesters);
		if (pass && isNot || !pass && !isNot) {
			const msg = utils.getMessage(this, [
				pass,
				"expected #{this} to match object #{exp}",
				"expected #{this} to not match object #{exp}",
				expected,
				actualSubset,
				false
			]);
			const message = stripped === 0 ? msg : `${msg}\n(${stripped} matching ${stripped === 1 ? "property" : "properties"} omitted from actual)`;
			throw new AssertionError$1(message, {
				showDiff: true,
				expected,
				actual: actualSubset
			});
		}
	});
	def("toMatch", function(expected) {
		const actual = this._obj;
		if (typeof actual !== "string") throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
		return this.assert(typeof expected === "string" ? actual.includes(expected) : actual.match(expected), `expected #{this} to match #{exp}`, `expected #{this} not to match #{exp}`, expected, actual);
	});
	def("toContain", function(item) {
		const actual = this._obj;
		if (typeof Node !== "undefined" && actual instanceof Node) {
			if (!(item instanceof Node)) throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
			return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
		}
		if (typeof DOMTokenList !== "undefined" && actual instanceof DOMTokenList) {
			assertTypes(item, "class name", ["string"]);
			const expectedClassList = utils.flag(this, "negate") ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
			return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
		}
		if (typeof actual === "string" && typeof item === "string") return this.assert(actual.includes(item), `expected #{this} to contain #{exp}`, `expected #{this} not to contain #{exp}`, item, actual);
		if (actual != null && typeof actual !== "string") utils.flag(this, "object", Array.from(actual));
		return this.contain(item);
	});
	def("toContainEqual", function(expected) {
		const obj = utils.flag(this, "object");
		const index = Array.from(obj).findIndex((item) => {
			return equals(item, expected, customTesters);
		});
		this.assert(index !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
	});
	def("toBeTruthy", function() {
		const obj = utils.flag(this, "object");
		this.assert(Boolean(obj), "expected #{this} to be truthy", "expected #{this} to not be truthy", true, obj);
	});
	def("toBeFalsy", function() {
		const obj = utils.flag(this, "object");
		this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", false, obj);
	});
	def("toBeGreaterThan", function(expected) {
		const actual = this._obj;
		assertTypes(actual, "actual", ["number", "bigint"]);
		assertTypes(expected, "expected", ["number", "bigint"]);
		return this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, expected, actual, false);
	});
	def("toBeGreaterThanOrEqual", function(expected) {
		const actual = this._obj;
		assertTypes(actual, "actual", ["number", "bigint"]);
		assertTypes(expected, "expected", ["number", "bigint"]);
		return this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, expected, actual, false);
	});
	def("toBeLessThan", function(expected) {
		const actual = this._obj;
		assertTypes(actual, "actual", ["number", "bigint"]);
		assertTypes(expected, "expected", ["number", "bigint"]);
		return this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, expected, actual, false);
	});
	def("toBeLessThanOrEqual", function(expected) {
		const actual = this._obj;
		assertTypes(actual, "actual", ["number", "bigint"]);
		assertTypes(expected, "expected", ["number", "bigint"]);
		return this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, expected, actual, false);
	});
	def("toBeNaN", function() {
		const obj = utils.flag(this, "object");
		this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", NaN, obj);
	});
	def("toBeUndefined", function() {
		const obj = utils.flag(this, "object");
		this.assert(void 0 === obj, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, obj);
	});
	def("toBeNull", function() {
		const obj = utils.flag(this, "object");
		this.assert(obj === null, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
	});
	def("toBeDefined", function() {
		const obj = utils.flag(this, "object");
		this.assert(typeof obj !== "undefined", "expected #{this} to be defined", "expected #{this} to be undefined", obj);
	});
	def("toBeTypeOf", function(expected) {
		const actual = typeof this._obj;
		const equal = expected === actual;
		return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
	});
	def("toBeInstanceOf", function(obj) {
		return this.instanceOf(obj);
	});
	def("toHaveLength", function(length) {
		return this.have.length(length);
	});
	def("toHaveProperty", function(...args) {
		if (Array.isArray(args[0])) args[0] = args[0].map((key) => String(key).replace(/([.[\]])/g, "\\$1")).join(".");
		const actual = this._obj;
		const [propertyName, expected] = args;
		const getValue = () => {
			if (Object.prototype.hasOwnProperty.call(actual, propertyName)) return {
				value: actual[propertyName],
				exists: true
			};
			return utils.getPathInfo(actual, propertyName);
		};
		const { value, exists } = getValue();
		const pass = exists && (args.length === 1 || equals(expected, value, customTesters));
		const valueString = args.length === 1 ? "" : ` with value ${utils.objDisplay(expected)}`;
		return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value : void 0);
	});
	def("toBeCloseTo", function(received, precision = 2) {
		const expected = this._obj;
		let pass = false;
		let expectedDiff = 0;
		let receivedDiff = 0;
		if (received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY) pass = true;
		else if (received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY) pass = true;
		else {
			expectedDiff = 10 ** -precision / 2;
			receivedDiff = Math.abs(expected - received);
			pass = receivedDiff < expectedDiff;
		}
		return this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff}`, received, expected, false);
	});
	function assertIsMock(assertion) {
		if (!isMockFunction(assertion._obj)) throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
	}
	function getSpy(assertion) {
		assertIsMock(assertion);
		return assertion._obj;
	}
	def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const callCount = spy.mock.calls.length;
		return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, false);
	});
	def("toHaveBeenCalledOnce", function() {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const callCount = spy.mock.calls.length;
		return this.assert(callCount === 1, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, false);
	});
	def(["toHaveBeenCalled", "toBeCalled"], function() {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const callCount = spy.mock.calls.length;
		const called = callCount > 0;
		const isNot = utils.flag(this, "negate");
		let msg = utils.getMessage(this, [
			called,
			`expected "${spyName}" to be called at least once`,
			`expected "${spyName}" to not be called at all, but actually been called ${callCount} times`,
			true,
			called
		]);
		if (called && isNot) msg = formatCalls(spy, msg);
		if (called && isNot || !called && !isNot) throw new AssertionError$1(msg);
	});
	function equalsArgumentArray(a$2, b$1) {
		return a$2.length === b$1.length && a$2.every((aItem, i) => equals(aItem, b$1[i], [...customTesters, iterableEquality]));
	}
	def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args) {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args));
		const isNot = utils.flag(this, "negate");
		const msg = utils.getMessage(this, [
			pass,
			`expected "${spyName}" to be called with arguments: #{exp}`,
			`expected "${spyName}" to not be called with arguments: #{exp}`,
			args
		]);
		if (pass && isNot || !pass && !isNot) throw new AssertionError$1(formatCalls(spy, msg, args));
	});
	def("toHaveBeenCalledExactlyOnceWith", function(...args) {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const callCount = spy.mock.calls.length;
		const pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)) && callCount === 1;
		const isNot = utils.flag(this, "negate");
		const msg = utils.getMessage(this, [
			pass,
			`expected "${spyName}" to be called once with arguments: #{exp}`,
			`expected "${spyName}" to not be called once with arguments: #{exp}`,
			args
		]);
		if (pass && isNot || !pass && !isNot) throw new AssertionError$1(formatCalls(spy, msg, args));
	});
	def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args) {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const nthCall = spy.mock.calls[times - 1];
		const callCount = spy.mock.calls.length;
		const isCalled = times <= callCount;
		this.assert(nthCall && equalsArgumentArray(nthCall, args), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? `` : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args, nthCall, isCalled);
	});
	def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args) {
		const spy = getSpy(this);
		const spyName = spy.getMockName();
		const lastCall = spy.mock.calls[spy.mock.calls.length - 1];
		this.assert(lastCall && equalsArgumentArray(lastCall, args), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args, lastCall);
	});
	/**
	* Used for `toHaveBeenCalledBefore` and `toHaveBeenCalledAfter` to determine if the expected spy was called before the result spy.
	*/
	function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
		const beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder;
		const afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
		if (beforeInvocationCallOrder.length === 0) return !failIfNoFirstInvocation;
		if (afterInvocationCallOrder.length === 0) return false;
		return beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
	}
	def(["toHaveBeenCalledBefore"], function(resultSpy, failIfNoFirstInvocation = true) {
		const expectSpy = getSpy(this);
		if (!isMockFunction(resultSpy)) throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
		this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called before "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called before "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
	});
	def(["toHaveBeenCalledAfter"], function(resultSpy, failIfNoFirstInvocation = true) {
		const expectSpy = getSpy(this);
		if (!isMockFunction(resultSpy)) throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
		this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called after "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called after "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
	});
	def(["toThrow", "toThrowError"], function(expected) {
		if (typeof expected === "string" || typeof expected === "undefined" || expected instanceof RegExp) return this.throws(expected === "" ? /^$/ : expected);
		const obj = this._obj;
		const promise = utils.flag(this, "promise");
		const isNot = utils.flag(this, "negate");
		let thrown = null;
		if (promise === "rejects") thrown = obj;
		else if (promise === "resolves" && typeof obj !== "function") if (!isNot) {
			const message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't";
			throw new AssertionError$1(message, { showDiff: false }, utils.flag(this, "ssfi"));
		} else return;
		else {
			let isThrow = false;
			try {
				obj();
			} catch (err) {
				isThrow = true;
				thrown = err;
			}
			if (!isThrow && !isNot) {
				const message = utils.flag(this, "message") || "expected function to throw an error, but it didn't";
				throw new AssertionError$1(message, { showDiff: false }, utils.flag(this, "ssfi"));
			}
		}
		if (typeof expected === "function") {
			const name = expected.name || expected.prototype.constructor.name;
			return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name}`, `expected error not to be instance of ${name}`, expected, thrown);
		}
		if (expected instanceof Error) {
			const equal = equals(thrown, expected, [...customTesters, iterableEquality]);
			return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
		}
		if (typeof expected === "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch === "function") {
			const matcher = expected;
			return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
		}
		throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
	});
	[{
		name: "toHaveResolved",
		condition: (spy) => spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type: type$1 }) => type$1 === "fulfilled"),
		action: "resolved"
	}, {
		name: ["toHaveReturned", "toReturn"],
		condition: (spy) => spy.mock.calls.length > 0 && spy.mock.results.some(({ type: type$1 }) => type$1 !== "throw"),
		action: "called"
	}].forEach(({ name, condition, action }) => {
		def(name, function() {
			const spy = getSpy(this);
			const spyName = spy.getMockName();
			const pass = condition(spy);
			this.assert(pass, `expected "${spyName}" to be successfully ${action} at least once`, `expected "${spyName}" to not be successfully ${action}`, pass, !pass, false);
		});
	});
	[{
		name: "toHaveResolvedTimes",
		condition: (spy, times) => spy.mock.settledResults.reduce((s, { type: type$1 }) => type$1 === "fulfilled" ? ++s : s, 0) === times,
		action: "resolved"
	}, {
		name: ["toHaveReturnedTimes", "toReturnTimes"],
		condition: (spy, times) => spy.mock.results.reduce((s, { type: type$1 }) => type$1 === "throw" ? s : ++s, 0) === times,
		action: "called"
	}].forEach(({ name, condition, action }) => {
		def(name, function(times) {
			const spy = getSpy(this);
			const spyName = spy.getMockName();
			const pass = condition(spy, times);
			this.assert(pass, `expected "${spyName}" to be successfully ${action} ${times} times`, `expected "${spyName}" to not be successfully ${action} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, false);
		});
	});
	[{
		name: "toHaveResolvedWith",
		condition: (spy, value) => spy.mock.settledResults.some(({ type: type$1, value: result }) => type$1 === "fulfilled" && equals(value, result)),
		action: "resolve"
	}, {
		name: ["toHaveReturnedWith", "toReturnWith"],
		condition: (spy, value) => spy.mock.results.some(({ type: type$1, value: result }) => type$1 === "return" && equals(value, result)),
		action: "return"
	}].forEach(({ name, condition, action }) => {
		def(name, function(value) {
			const spy = getSpy(this);
			const pass = condition(spy, value);
			const isNot = utils.flag(this, "negate");
			if (pass && isNot || !pass && !isNot) {
				const spyName = spy.getMockName();
				const msg = utils.getMessage(this, [
					pass,
					`expected "${spyName}" to ${action} with: #{exp} at least once`,
					`expected "${spyName}" to not ${action} with: #{exp}`,
					value
				]);
				const results = action === "return" ? spy.mock.results : spy.mock.settledResults;
				throw new AssertionError$1(formatReturns(spy, results, msg, value));
			}
		});
	});
	[{
		name: "toHaveLastResolvedWith",
		condition: (spy, value) => {
			const result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
			return result && result.type === "fulfilled" && equals(result.value, value);
		},
		action: "resolve"
	}, {
		name: ["toHaveLastReturnedWith", "lastReturnedWith"],
		condition: (spy, value) => {
			const result = spy.mock.results[spy.mock.results.length - 1];
			return result && result.type === "return" && equals(result.value, value);
		},
		action: "return"
	}].forEach(({ name, condition, action }) => {
		def(name, function(value) {
			const spy = getSpy(this);
			const results = action === "return" ? spy.mock.results : spy.mock.settledResults;
			const result = results[results.length - 1];
			const spyName = spy.getMockName();
			this.assert(condition(spy, value), `expected last "${spyName}" call to ${action} #{exp}`, `expected last "${spyName}" call to not ${action} #{exp}`, value, result === null || result === void 0 ? void 0 : result.value);
		});
	});
	[{
		name: "toHaveNthResolvedWith",
		condition: (spy, index, value) => {
			const result = spy.mock.settledResults[index - 1];
			return result && result.type === "fulfilled" && equals(result.value, value);
		},
		action: "resolve"
	}, {
		name: ["toHaveNthReturnedWith", "nthReturnedWith"],
		condition: (spy, index, value) => {
			const result = spy.mock.results[index - 1];
			return result && result.type === "return" && equals(result.value, value);
		},
		action: "return"
	}].forEach(({ name, condition, action }) => {
		def(name, function(nthCall, value) {
			const spy = getSpy(this);
			const spyName = spy.getMockName();
			const result = (action === "return" ? spy.mock.results : spy.mock.settledResults)[nthCall - 1];
			const ordinalCall = `${ordinalOf(nthCall)} call`;
			this.assert(condition(spy, nthCall, value), `expected ${ordinalCall} "${spyName}" call to ${action} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action} #{exp}`, value, result === null || result === void 0 ? void 0 : result.value);
		});
	});
	def("withContext", function(context) {
		for (const key in context) utils.flag(this, key, context[key]);
		return this;
	});
	utils.addProperty(chai$1.Assertion.prototype, "resolves", function __VITEST_RESOLVES__() {
		const error = /* @__PURE__ */ new Error("resolves");
		utils.flag(this, "promise", "resolves");
		utils.flag(this, "error", error);
		const test$7 = utils.flag(this, "vitest-test");
		const obj = utils.flag(this, "object");
		if (utils.flag(this, "poll")) throw new SyntaxError(`expect.poll() is not supported in combination with .resolves`);
		if (typeof (obj === null || obj === void 0 ? void 0 : obj.then) !== "function") throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
		const proxy = new Proxy(this, { get: (target, key, receiver) => {
			const result = Reflect.get(target, key, receiver);
			if (typeof result !== "function") return result instanceof chai$1.Assertion ? proxy : result;
			return (...args) => {
				utils.flag(this, "_name", key);
				const promise = obj.then((value) => {
					utils.flag(this, "object", value);
					return result.call(this, ...args);
				}, (err) => {
					const _error = new AssertionError$1(`promise rejected "${utils.inspect(err)}" instead of resolving`, { showDiff: false });
					_error.cause = err;
					_error.stack = error.stack.replace(error.message, _error.message);
					throw _error;
				});
				return recordAsyncExpect$1(test$7, promise, createAssertionMessage$1(utils, this, !!args.length), error);
			};
		} });
		return proxy;
	});
	utils.addProperty(chai$1.Assertion.prototype, "rejects", function __VITEST_REJECTS__() {
		const error = /* @__PURE__ */ new Error("rejects");
		utils.flag(this, "promise", "rejects");
		utils.flag(this, "error", error);
		const test$7 = utils.flag(this, "vitest-test");
		const obj = utils.flag(this, "object");
		const wrapper = typeof obj === "function" ? obj() : obj;
		if (utils.flag(this, "poll")) throw new SyntaxError(`expect.poll() is not supported in combination with .rejects`);
		if (typeof (wrapper === null || wrapper === void 0 ? void 0 : wrapper.then) !== "function") throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
		const proxy = new Proxy(this, { get: (target, key, receiver) => {
			const result = Reflect.get(target, key, receiver);
			if (typeof result !== "function") return result instanceof chai$1.Assertion ? proxy : result;
			return (...args) => {
				utils.flag(this, "_name", key);
				const promise = wrapper.then((value) => {
					const _error = new AssertionError$1(`promise resolved "${utils.inspect(value)}" instead of rejecting`, {
						showDiff: true,
						expected: /* @__PURE__ */ new Error("rejected promise"),
						actual: value
					});
					_error.stack = error.stack.replace(error.message, _error.message);
					throw _error;
				}, (err) => {
					utils.flag(this, "object", err);
					return result.call(this, ...args);
				});
				return recordAsyncExpect$1(test$7, promise, createAssertionMessage$1(utils, this, !!args.length), error);
			};
		} });
		return proxy;
	});
};
function ordinalOf(i) {
	const j$1 = i % 10;
	const k$1 = i % 100;
	if (j$1 === 1 && k$1 !== 11) return `${i}st`;
	if (j$1 === 2 && k$1 !== 12) return `${i}nd`;
	if (j$1 === 3 && k$1 !== 13) return `${i}rd`;
	return `${i}th`;
}
function formatCalls(spy, msg, showActualCall) {
	if (spy.mock.calls.length) msg += u.gray(`\n\nReceived: \n\n${spy.mock.calls.map((callArg, i) => {
		let methodCall = u.bold(`  ${ordinalOf(i + 1)} ${spy.getMockName()} call:\n\n`);
		if (showActualCall) methodCall += diff(showActualCall, callArg, { omitAnnotationLines: true });
		else methodCall += stringify(callArg).split("\n").map((line) => `    ${line}`).join("\n");
		methodCall += "\n";
		return methodCall;
	}).join("\n")}`);
	msg += u.gray(`\n\nNumber of calls: ${u.bold(spy.mock.calls.length)}\n`);
	return msg;
}
function formatReturns(spy, results, msg, showActualReturn) {
	if (results.length) msg += u.gray(`\n\nReceived: \n\n${results.map((callReturn, i) => {
		let methodCall = u.bold(`  ${ordinalOf(i + 1)} ${spy.getMockName()} call return:\n\n`);
		if (showActualReturn) methodCall += diff(showActualReturn, callReturn.value, { omitAnnotationLines: true });
		else methodCall += stringify(callReturn).split("\n").map((line) => `    ${line}`).join("\n");
		methodCall += "\n";
		return methodCall;
	}).join("\n")}`);
	msg += u.gray(`\n\nNumber of calls: ${u.bold(spy.mock.calls.length)}\n`);
	return msg;
}
function getMatcherState(assertion, expect$1) {
	const obj = assertion._obj;
	const isNot = utils_exports.flag(assertion, "negate");
	const promise = utils_exports.flag(assertion, "promise") || "";
	const jestUtils = {
		...getMatcherUtils(),
		diff,
		stringify,
		iterableEquality,
		subsetEquality
	};
	return {
		state: {
			...getState(expect$1),
			customTesters: getCustomEqualityTesters(),
			isNot,
			utils: jestUtils,
			promise,
			equals,
			suppressedErrors: [],
			soft: utils_exports.flag(assertion, "soft"),
			poll: utils_exports.flag(assertion, "poll")
		},
		isNot,
		obj
	};
}
var JestExtendError = class extends Error {
	constructor(message, actual, expected) {
		super(message);
		this.actual = actual;
		this.expected = expected;
	}
};
function JestExtendPlugin(c, expect$1, matchers) {
	return (_, utils) => {
		Object.entries(matchers).forEach(([expectAssertionName, expectAssertion]) => {
			function expectWrapper(...args) {
				const { state, isNot, obj } = getMatcherState(this, expect$1);
				const result = expectAssertion.call(state, obj, ...args);
				if (result && typeof result === "object" && typeof result.then === "function") return result.then(({ pass: pass$1, message: message$1, actual: actual$1, expected: expected$1 }) => {
					if (pass$1 && isNot || !pass$1 && !isNot) throw new JestExtendError(message$1(), actual$1, expected$1);
				});
				const { pass, message, actual, expected } = result;
				if (pass && isNot || !pass && !isNot) throw new JestExtendError(message(), actual, expected);
			}
			const softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
			utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper);
			utils.addMethod(c.Assertion.prototype, expectAssertionName, softWrapper);
			class CustomMatcher extends AsymmetricMatcher$2 {
				constructor(inverse = false, ...sample) {
					super(sample, inverse);
				}
				asymmetricMatch(other) {
					const { pass } = expectAssertion.call(this.getMatcherContext(expect$1), other, ...this.sample);
					return this.inverse ? !pass : pass;
				}
				toString() {
					return `${this.inverse ? "not." : ""}${expectAssertionName}`;
				}
				getExpectedType() {
					return "any";
				}
				toAsymmetricMatcher() {
					return `${this.toString()}<${this.sample.map((item) => stringify(item)).join(", ")}>`;
				}
			}
			const customMatcher = (...sample) => new CustomMatcher(false, ...sample);
			Object.defineProperty(expect$1, expectAssertionName, {
				configurable: true,
				enumerable: true,
				value: customMatcher,
				writable: true
			});
			Object.defineProperty(expect$1.not, expectAssertionName, {
				configurable: true,
				enumerable: true,
				value: (...sample) => new CustomMatcher(true, ...sample),
				writable: true
			});
			Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
				configurable: true,
				enumerable: true,
				value: customMatcher,
				writable: true
			});
		});
	};
}
const JestExtend = (chai$1, utils) => {
	utils.addMethod(chai$1.expect, "extend", (expect$1, expects) => {
		use(JestExtendPlugin(chai$1, expect$1, expects));
	});
};

//#endregion
//#region node_modules/.pnpm/@vitest+utils@3.2.4/node_modules/@vitest/utils/dist/source-map.js
const comma$1 = ",".charCodeAt(0);
const chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar$1 = new Uint8Array(64);
const charToInt$1 = new Uint8Array(128);
for (let i = 0; i < 64; i++) {
	const c = chars$1.charCodeAt(i);
	intToChar$1[i] = c;
	charToInt$1[c] = i;
}
var UrlType$1;
(function(UrlType$2) {
	UrlType$2[UrlType$2["Empty"] = 1] = "Empty";
	UrlType$2[UrlType$2["Hash"] = 2] = "Hash";
	UrlType$2[UrlType$2["Query"] = 3] = "Query";
	UrlType$2[UrlType$2["RelativePath"] = 4] = "RelativePath";
	UrlType$2[UrlType$2["AbsolutePath"] = 5] = "AbsolutePath";
	UrlType$2[UrlType$2["SchemeRelative"] = 6] = "SchemeRelative";
	UrlType$2[UrlType$2["Absolute"] = 7] = "Absolute";
})(UrlType$1 || (UrlType$1 = {}));
const _DRIVE_LETTER_START_RE$1 = /^[A-Za-z]:\//;
function normalizeWindowsPath$1(input = "") {
	if (!input) return input;
	return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE$1, (r$1) => r$1.toUpperCase());
}
const _IS_ABSOLUTE_RE$1 = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd$1() {
	if (typeof process !== "undefined" && typeof process.cwd === "function") return process.cwd().replace(/\\/g, "/");
	return "/";
}
const resolve$3 = function(...arguments_) {
	arguments_ = arguments_.map((argument) => normalizeWindowsPath$1(argument));
	let resolvedPath = "";
	let resolvedAbsolute = false;
	for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
		const path = index >= 0 ? arguments_[index] : cwd$1();
		if (!path || path.length === 0) continue;
		resolvedPath = `${path}/${resolvedPath}`;
		resolvedAbsolute = isAbsolute$1(path);
	}
	resolvedPath = normalizeString$1(resolvedPath, !resolvedAbsolute);
	if (resolvedAbsolute && !isAbsolute$1(resolvedPath)) return `/${resolvedPath}`;
	return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString$1(path, allowAboveRoot) {
	let res = "";
	let lastSegmentLength = 0;
	let lastSlash = -1;
	let dots = 0;
	let char = null;
	for (let index = 0; index <= path.length; ++index) {
		if (index < path.length) char = path[index];
		else if (char === "/") break;
		else char = "/";
		if (char === "/") {
			if (lastSlash === index - 1 || dots === 1);
			else if (dots === 2) {
				if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
					if (res.length > 2) {
						const lastSlashIndex = res.lastIndexOf("/");
						if (lastSlashIndex === -1) {
							res = "";
							lastSegmentLength = 0;
						} else {
							res = res.slice(0, lastSlashIndex);
							lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
						}
						lastSlash = index;
						dots = 0;
						continue;
					} else if (res.length > 0) {
						res = "";
						lastSegmentLength = 0;
						lastSlash = index;
						dots = 0;
						continue;
					}
				}
				if (allowAboveRoot) {
					res += res.length > 0 ? "/.." : "..";
					lastSegmentLength = 2;
				}
			} else {
				if (res.length > 0) res += `/${path.slice(lastSlash + 1, index)}`;
				else res = path.slice(lastSlash + 1, index);
				lastSegmentLength = index - lastSlash - 1;
			}
			lastSlash = index;
			dots = 0;
		} else if (char === "." && dots !== -1) ++dots;
		else dots = -1;
	}
	return res;
}
const isAbsolute$1 = function(p$2) {
	return _IS_ABSOLUTE_RE$1.test(p$2);
};
const CHROME_IE_STACK_REGEXP$1 = /^\s*at .*(?:\S:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP$1 = /^(?:eval@)?(?:\[native code\])?$/;
function extractLocation$1(urlLike) {
	if (!urlLike.includes(":")) return [urlLike];
	const parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/^\(|\)$/g, ""));
	if (!parts) return [urlLike];
	let url = parts[1];
	if (url.startsWith("async ")) url = url.slice(6);
	if (url.startsWith("http:") || url.startsWith("https:")) {
		const urlObj = new URL(url);
		urlObj.searchParams.delete("import");
		urlObj.searchParams.delete("browserv");
		url = urlObj.pathname + urlObj.hash + urlObj.search;
	}
	if (url.startsWith("/@fs/")) {
		const isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
		url = url.slice(isWindows ? 5 : 4);
	}
	return [
		url,
		parts[2] || void 0,
		parts[3] || void 0
	];
}
function parseSingleFFOrSafariStack$1(raw) {
	let line = raw.trim();
	if (SAFARI_NATIVE_CODE_REGEXP$1.test(line)) return null;
	if (line.includes(" > eval")) line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
	if (!line.includes("@") && !line.includes(":")) return null;
	const functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/;
	const matches = line.match(functionNameRegex);
	const functionName$1 = matches && matches[1] ? matches[1] : void 0;
	const [url, lineNumber, columnNumber] = extractLocation$1(line.replace(functionNameRegex, ""));
	if (!url || !lineNumber || !columnNumber) return null;
	return {
		file: url,
		method: functionName$1 || "",
		line: Number.parseInt(lineNumber),
		column: Number.parseInt(columnNumber)
	};
}
function parseSingleStack(raw) {
	const line = raw.trim();
	if (!CHROME_IE_STACK_REGEXP$1.test(line)) return parseSingleFFOrSafariStack$1(line);
	return parseSingleV8Stack$1(line);
}
function parseSingleV8Stack$1(raw) {
	let line = raw.trim();
	if (!CHROME_IE_STACK_REGEXP$1.test(line)) return null;
	if (line.includes("(eval ")) line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
	let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
	const location = sanitizedLine.match(/ (\(.+\)$)/);
	sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
	const [url, lineNumber, columnNumber] = extractLocation$1(location ? location[1] : sanitizedLine);
	let method = location && sanitizedLine || "";
	let file = url && ["eval", "<anonymous>"].includes(url) ? void 0 : url;
	if (!file || !lineNumber || !columnNumber) return null;
	if (method.startsWith("async ")) method = method.slice(6);
	if (file.startsWith("file://")) file = file.slice(7);
	file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve$3(file);
	if (method) method = method.replace(/__vite_ssr_import_\d+__\./g, "");
	return {
		method,
		file,
		line: Number.parseInt(lineNumber),
		column: Number.parseInt(columnNumber)
	};
}

//#endregion
//#region node_modules/.pnpm/js-tokens@9.0.1/node_modules/js-tokens/index.js
var require_js_tokens = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/js-tokens@9.0.1/node_modules/js-tokens/index.js": ((exports, module) => {
	var HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]?|[^\/[\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
	Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
	Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy;
	StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
	NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
	Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
	WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/uy;
	LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
	MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
	SingleLineComment = /\/\/.*/y;
	HashbangComment = /^#!.*/;
	JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
	JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy;
	JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
	JSXText = /[^<>{}]+/y;
	TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
	TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
	KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
	KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
	Newline = RegExp(LineTerminatorSequence.source);
	module.exports = function* (input, { jsx = false } = {}) {
		var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
		({length} = input);
		lastIndex = 0;
		lastSignificantToken = "";
		stack = [{ tag: "JS" }];
		braces = [];
		parenNesting = 0;
		postfixIncDec = false;
		if (match = HashbangComment.exec(input)) {
			yield {
				type: "HashbangComment",
				value: match[0]
			};
			lastIndex = match[0].length;
		}
		while (lastIndex < length) {
			mode = stack[stack.length - 1];
			switch (mode.tag) {
				case "JS":
				case "JSNonExpressionParen":
				case "InterpolationInTemplate":
				case "InterpolationInJSX":
					if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
						RegularExpressionLiteral.lastIndex = lastIndex;
						if (match = RegularExpressionLiteral.exec(input)) {
							lastIndex = RegularExpressionLiteral.lastIndex;
							lastSignificantToken = match[0];
							postfixIncDec = true;
							yield {
								type: "RegularExpressionLiteral",
								value: match[0],
								closed: match[1] !== void 0 && match[1] !== "\\"
							};
							continue;
						}
					}
					Punctuator.lastIndex = lastIndex;
					if (match = Punctuator.exec(input)) {
						punctuator = match[0];
						nextLastIndex = Punctuator.lastIndex;
						nextLastSignificantToken = punctuator;
						switch (punctuator) {
							case "(":
								if (lastSignificantToken === "?NonExpressionParenKeyword") stack.push({
									tag: "JSNonExpressionParen",
									nesting: parenNesting
								});
								parenNesting++;
								postfixIncDec = false;
								break;
							case ")":
								parenNesting--;
								postfixIncDec = true;
								if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
									stack.pop();
									nextLastSignificantToken = "?NonExpressionParenEnd";
									postfixIncDec = false;
								}
								break;
							case "{":
								Punctuator.lastIndex = 0;
								isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
								braces.push(isExpression);
								postfixIncDec = false;
								break;
							case "}":
								switch (mode.tag) {
									case "InterpolationInTemplate":
										if (braces.length === mode.nesting) {
											Template.lastIndex = lastIndex;
											match = Template.exec(input);
											lastIndex = Template.lastIndex;
											lastSignificantToken = match[0];
											if (match[1] === "${") {
												lastSignificantToken = "?InterpolationInTemplate";
												postfixIncDec = false;
												yield {
													type: "TemplateMiddle",
													value: match[0]
												};
											} else {
												stack.pop();
												postfixIncDec = true;
												yield {
													type: "TemplateTail",
													value: match[0],
													closed: match[1] === "`"
												};
											}
											continue;
										}
										break;
									case "InterpolationInJSX": if (braces.length === mode.nesting) {
										stack.pop();
										lastIndex += 1;
										lastSignificantToken = "}";
										yield {
											type: "JSXPunctuator",
											value: "}"
										};
										continue;
									}
								}
								postfixIncDec = braces.pop();
								nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
								break;
							case "]":
								postfixIncDec = true;
								break;
							case "++":
							case "--":
								nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
								break;
							case "<":
								if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
									stack.push({ tag: "JSXTag" });
									lastIndex += 1;
									lastSignificantToken = "<";
									yield {
										type: "JSXPunctuator",
										value: punctuator
									};
									continue;
								}
								postfixIncDec = false;
								break;
							default: postfixIncDec = false;
						}
						lastIndex = nextLastIndex;
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "Punctuator",
							value: punctuator
						};
						continue;
					}
					Identifier.lastIndex = lastIndex;
					if (match = Identifier.exec(input)) {
						lastIndex = Identifier.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "for":
							case "if":
							case "while":
							case "with": if (lastSignificantToken !== "." && lastSignificantToken !== "?.") nextLastSignificantToken = "?NonExpressionParenKeyword";
						}
						lastSignificantToken = nextLastSignificantToken;
						postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
						yield {
							type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
							value: match[0]
						};
						continue;
					}
					StringLiteral.lastIndex = lastIndex;
					if (match = StringLiteral.exec(input)) {
						lastIndex = StringLiteral.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "StringLiteral",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					NumericLiteral.lastIndex = lastIndex;
					if (match = NumericLiteral.exec(input)) {
						lastIndex = NumericLiteral.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "NumericLiteral",
							value: match[0]
						};
						continue;
					}
					Template.lastIndex = lastIndex;
					if (match = Template.exec(input)) {
						lastIndex = Template.lastIndex;
						lastSignificantToken = match[0];
						if (match[1] === "${") {
							lastSignificantToken = "?InterpolationInTemplate";
							stack.push({
								tag: "InterpolationInTemplate",
								nesting: braces.length
							});
							postfixIncDec = false;
							yield {
								type: "TemplateHead",
								value: match[0]
							};
						} else {
							postfixIncDec = true;
							yield {
								type: "NoSubstitutionTemplate",
								value: match[0],
								closed: match[1] === "`"
							};
						}
						continue;
					}
					break;
				case "JSXTag":
				case "JSXTagEnd":
					JSXPunctuator.lastIndex = lastIndex;
					if (match = JSXPunctuator.exec(input)) {
						lastIndex = JSXPunctuator.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "<":
								stack.push({ tag: "JSXTag" });
								break;
							case ">":
								stack.pop();
								if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
									nextLastSignificantToken = "?JSX";
									postfixIncDec = true;
								} else stack.push({ tag: "JSXChildren" });
								break;
							case "{":
								stack.push({
									tag: "InterpolationInJSX",
									nesting: braces.length
								});
								nextLastSignificantToken = "?InterpolationInJSX";
								postfixIncDec = false;
								break;
							case "/": if (lastSignificantToken === "<") {
								stack.pop();
								if (stack[stack.length - 1].tag === "JSXChildren") stack.pop();
								stack.push({ tag: "JSXTagEnd" });
							}
						}
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "JSXPunctuator",
							value: match[0]
						};
						continue;
					}
					JSXIdentifier.lastIndex = lastIndex;
					if (match = JSXIdentifier.exec(input)) {
						lastIndex = JSXIdentifier.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXIdentifier",
							value: match[0]
						};
						continue;
					}
					JSXString.lastIndex = lastIndex;
					if (match = JSXString.exec(input)) {
						lastIndex = JSXString.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXString",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					break;
				case "JSXChildren":
					JSXText.lastIndex = lastIndex;
					if (match = JSXText.exec(input)) {
						lastIndex = JSXText.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXText",
							value: match[0]
						};
						continue;
					}
					switch (input[lastIndex]) {
						case "<":
							stack.push({ tag: "JSXTag" });
							lastIndex++;
							lastSignificantToken = "<";
							yield {
								type: "JSXPunctuator",
								value: "<"
							};
							continue;
						case "{":
							stack.push({
								tag: "InterpolationInJSX",
								nesting: braces.length
							});
							lastIndex++;
							lastSignificantToken = "?InterpolationInJSX";
							postfixIncDec = false;
							yield {
								type: "JSXPunctuator",
								value: "{"
							};
							continue;
					}
			}
			WhiteSpace.lastIndex = lastIndex;
			if (match = WhiteSpace.exec(input)) {
				lastIndex = WhiteSpace.lastIndex;
				yield {
					type: "WhiteSpace",
					value: match[0]
				};
				continue;
			}
			LineTerminatorSequence.lastIndex = lastIndex;
			if (match = LineTerminatorSequence.exec(input)) {
				lastIndex = LineTerminatorSequence.lastIndex;
				postfixIncDec = false;
				if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				yield {
					type: "LineTerminatorSequence",
					value: match[0]
				};
				continue;
			}
			MultiLineComment.lastIndex = lastIndex;
			if (match = MultiLineComment.exec(input)) {
				lastIndex = MultiLineComment.lastIndex;
				if (Newline.test(match[0])) {
					postfixIncDec = false;
					if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				}
				yield {
					type: "MultiLineComment",
					value: match[0],
					closed: match[1] !== void 0
				};
				continue;
			}
			SingleLineComment.lastIndex = lastIndex;
			if (match = SingleLineComment.exec(input)) {
				lastIndex = SingleLineComment.lastIndex;
				postfixIncDec = false;
				yield {
					type: "SingleLineComment",
					value: match[0]
				};
				continue;
			}
			firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
			lastIndex += firstCodePoint.length;
			lastSignificantToken = firstCodePoint;
			postfixIncDec = false;
			yield {
				type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
				value: firstCodePoint
			};
		}
	};
}) });

//#endregion
//#region node_modules/.pnpm/strip-literal@3.0.0/node_modules/strip-literal/dist/index.mjs
var import_js_tokens = /* @__PURE__ */ __toESM(require_js_tokens(), 1);
function stripLiteralJsTokens(code, options) {
	const FILL = options?.fillChar ?? " ";
	const FILL_COMMENT = " ";
	let result = "";
	const filter = options?.filter ?? (() => true);
	const tokens = [];
	for (const token of (0, import_js_tokens.default)(code, { jsx: false })) {
		tokens.push(token);
		if (token.type === "SingleLineComment") {
			result += FILL_COMMENT.repeat(token.value.length);
			continue;
		}
		if (token.type === "MultiLineComment") {
			result += token.value.replace(/[^\n]/g, FILL_COMMENT);
			continue;
		}
		if (token.type === "StringLiteral") {
			if (!token.closed) {
				result += token.value;
				continue;
			}
			const body = token.value.slice(1, -1);
			if (filter(body)) {
				result += token.value[0] + FILL.repeat(body.length) + token.value[token.value.length - 1];
				continue;
			}
		}
		if (token.type === "NoSubstitutionTemplate") {
			const body = token.value.slice(1, -1);
			if (filter(body)) {
				result += `\`${body.replace(/[^\n]/g, FILL)}\``;
				continue;
			}
		}
		if (token.type === "RegularExpressionLiteral") {
			const body = token.value;
			if (filter(body)) {
				result += body.replace(/\/(.*)\/(\w?)$/g, (_, $1, $2) => `/${FILL.repeat($1.length)}/${$2}`);
				continue;
			}
		}
		if (token.type === "TemplateHead") {
			const body = token.value.slice(1, -2);
			if (filter(body)) {
				result += `\`${body.replace(/[^\n]/g, FILL)}\${`;
				continue;
			}
		}
		if (token.type === "TemplateTail") {
			const body = token.value.slice(0, -2);
			if (filter(body)) {
				result += `}${body.replace(/[^\n]/g, FILL)}\``;
				continue;
			}
		}
		if (token.type === "TemplateMiddle") {
			const body = token.value.slice(1, -2);
			if (filter(body)) {
				result += `}${body.replace(/[^\n]/g, FILL)}\${`;
				continue;
			}
		}
		result += token.value;
	}
	return {
		result,
		tokens
	};
}
function stripLiteral(code, options) {
	return stripLiteralDetailed(code, options).result;
}
function stripLiteralDetailed(code, options) {
	return stripLiteralJsTokens(code, options);
}

//#endregion
//#region node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.M-eThtNZ.mjs
const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
	if (!input) return input;
	return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r$1) => r$1.toUpperCase());
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd() {
	if (typeof process !== "undefined" && typeof process.cwd === "function") return process.cwd().replace(/\\/g, "/");
	return "/";
}
const resolve = function(...arguments_) {
	arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
	let resolvedPath = "";
	let resolvedAbsolute = false;
	for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
		const path = index >= 0 ? arguments_[index] : cwd();
		if (!path || path.length === 0) continue;
		resolvedPath = `${path}/${resolvedPath}`;
		resolvedAbsolute = isAbsolute(path);
	}
	resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
	if (resolvedAbsolute && !isAbsolute(resolvedPath)) return `/${resolvedPath}`;
	return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
	let res = "";
	let lastSegmentLength = 0;
	let lastSlash = -1;
	let dots = 0;
	let char = null;
	for (let index = 0; index <= path.length; ++index) {
		if (index < path.length) char = path[index];
		else if (char === "/") break;
		else char = "/";
		if (char === "/") {
			if (lastSlash === index - 1 || dots === 1);
			else if (dots === 2) {
				if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
					if (res.length > 2) {
						const lastSlashIndex = res.lastIndexOf("/");
						if (lastSlashIndex === -1) {
							res = "";
							lastSegmentLength = 0;
						} else {
							res = res.slice(0, lastSlashIndex);
							lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
						}
						lastSlash = index;
						dots = 0;
						continue;
					} else if (res.length > 0) {
						res = "";
						lastSegmentLength = 0;
						lastSlash = index;
						dots = 0;
						continue;
					}
				}
				if (allowAboveRoot) {
					res += res.length > 0 ? "/.." : "..";
					lastSegmentLength = 2;
				}
			} else {
				if (res.length > 0) res += `/${path.slice(lastSlash + 1, index)}`;
				else res = path.slice(lastSlash + 1, index);
				lastSegmentLength = index - lastSlash - 1;
			}
			lastSlash = index;
			dots = 0;
		} else if (char === "." && dots !== -1) ++dots;
		else dots = -1;
	}
	return res;
}
const isAbsolute = function(p$2) {
	return _IS_ABSOLUTE_RE.test(p$2);
};

//#endregion
//#region node_modules/.pnpm/@vitest+runner@3.2.4/node_modules/@vitest/runner/dist/chunk-hooks.js
var PendingError = class extends Error {
	code = "VITEST_PENDING";
	taskId;
	constructor(message, task, note) {
		super(message);
		this.message = message;
		this.note = note;
		this.taskId = task.id;
	}
};
const fnMap = /* @__PURE__ */ new WeakMap();
const testFixtureMap = /* @__PURE__ */ new WeakMap();
const hooksMap = /* @__PURE__ */ new WeakMap();
function setFn(key, fn$1) {
	fnMap.set(key, fn$1);
}
function setTestFixture(key, fixture) {
	testFixtureMap.set(key, fixture);
}
function getTestFixture(key) {
	return testFixtureMap.get(key);
}
function setHooks(key, hooks) {
	hooksMap.set(key, hooks);
}
function getHooks(key) {
	return hooksMap.get(key);
}
function mergeScopedFixtures(testFixtures, scopedFixtures) {
	const scopedFixturesMap = scopedFixtures.reduce((map$1, fixture) => {
		map$1[fixture.prop] = fixture;
		return map$1;
	}, {});
	const newFixtures = {};
	testFixtures.forEach((fixture) => {
		const useFixture = scopedFixturesMap[fixture.prop] || { ...fixture };
		newFixtures[useFixture.prop] = useFixture;
	});
	for (const fixtureKep in newFixtures) {
		var _fixture$deps;
		const fixture = newFixtures[fixtureKep];
		fixture.deps = (_fixture$deps = fixture.deps) === null || _fixture$deps === void 0 ? void 0 : _fixture$deps.map((dep) => newFixtures[dep.prop]);
	}
	return Object.values(newFixtures);
}
function mergeContextFixtures(fixtures, context, runner$1) {
	const fixtureOptionKeys = [
		"auto",
		"injected",
		"scope"
	];
	const fixtureArray = Object.entries(fixtures).map(([prop, value]) => {
		const fixtureItem = { value };
		if (Array.isArray(value) && value.length >= 2 && isObject$1(value[1]) && Object.keys(value[1]).some((key) => fixtureOptionKeys.includes(key))) {
			var _runner$injectValue;
			Object.assign(fixtureItem, value[1]);
			const userValue = value[0];
			fixtureItem.value = fixtureItem.injected ? ((_runner$injectValue = runner$1.injectValue) === null || _runner$injectValue === void 0 ? void 0 : _runner$injectValue.call(runner$1, prop)) ?? userValue : userValue;
		}
		fixtureItem.scope = fixtureItem.scope || "test";
		if (fixtureItem.scope === "worker" && !runner$1.getWorkerContext) fixtureItem.scope = "file";
		fixtureItem.prop = prop;
		fixtureItem.isFn = typeof fixtureItem.value === "function";
		return fixtureItem;
	});
	if (Array.isArray(context.fixtures)) context.fixtures = context.fixtures.concat(fixtureArray);
	else context.fixtures = fixtureArray;
	fixtureArray.forEach((fixture) => {
		if (fixture.isFn) {
			const usedProps = getUsedProps(fixture.value);
			if (usedProps.length) fixture.deps = context.fixtures.filter(({ prop }) => prop !== fixture.prop && usedProps.includes(prop));
			if (fixture.scope !== "test") {
				var _fixture$deps2;
				(_fixture$deps2 = fixture.deps) === null || _fixture$deps2 === void 0 || _fixture$deps2.forEach((dep) => {
					if (!dep.isFn) return;
					if (fixture.scope === "worker" && dep.scope === "worker") return;
					if (fixture.scope === "file" && dep.scope !== "test") return;
					throw new SyntaxError(`cannot use the ${dep.scope} fixture "${dep.prop}" inside the ${fixture.scope} fixture "${fixture.prop}"`);
				});
			}
		}
	});
	return context;
}
const fixtureValueMaps = /* @__PURE__ */ new Map();
const cleanupFnArrayMap = /* @__PURE__ */ new Map();
function withFixtures(runner$1, fn$1, testContext) {
	return (hookContext) => {
		const context = hookContext || testContext;
		if (!context) return fn$1({});
		const fixtures = getTestFixture(context);
		if (!(fixtures === null || fixtures === void 0 ? void 0 : fixtures.length)) return fn$1(context);
		const usedProps = getUsedProps(fn$1);
		const hasAutoFixture = fixtures.some(({ auto }) => auto);
		if (!usedProps.length && !hasAutoFixture) return fn$1(context);
		if (!fixtureValueMaps.get(context)) fixtureValueMaps.set(context, /* @__PURE__ */ new Map());
		const fixtureValueMap = fixtureValueMaps.get(context);
		if (!cleanupFnArrayMap.has(context)) cleanupFnArrayMap.set(context, []);
		const cleanupFnArray = cleanupFnArrayMap.get(context);
		const usedFixtures = fixtures.filter(({ prop, auto }) => auto || usedProps.includes(prop));
		const pendingFixtures = resolveDeps(usedFixtures);
		if (!pendingFixtures.length) return fn$1(context);
		async function resolveFixtures() {
			for (const fixture of pendingFixtures) {
				if (fixtureValueMap.has(fixture)) continue;
				const resolvedValue = await resolveFixtureValue(runner$1, fixture, context, cleanupFnArray);
				context[fixture.prop] = resolvedValue;
				fixtureValueMap.set(fixture, resolvedValue);
				if (fixture.scope === "test") cleanupFnArray.unshift(() => {
					fixtureValueMap.delete(fixture);
				});
			}
		}
		return resolveFixtures().then(() => fn$1(context));
	};
}
const globalFixturePromise = /* @__PURE__ */ new WeakMap();
function resolveFixtureValue(runner$1, fixture, context, cleanupFnArray) {
	var _runner$getWorkerCont;
	const fileContext = getFileContext(context.task.file);
	const workerContext = (_runner$getWorkerCont = runner$1.getWorkerContext) === null || _runner$getWorkerCont === void 0 ? void 0 : _runner$getWorkerCont.call(runner$1);
	if (!fixture.isFn) {
		var _fixture$prop;
		fileContext[_fixture$prop = fixture.prop] ?? (fileContext[_fixture$prop] = fixture.value);
		if (workerContext) {
			var _fixture$prop2;
			workerContext[_fixture$prop2 = fixture.prop] ?? (workerContext[_fixture$prop2] = fixture.value);
		}
		return fixture.value;
	}
	if (fixture.scope === "test") return resolveFixtureFunction(fixture.value, context, cleanupFnArray);
	if (globalFixturePromise.has(fixture)) return globalFixturePromise.get(fixture);
	let fixtureContext;
	if (fixture.scope === "worker") {
		if (!workerContext) throw new TypeError("[@vitest/runner] The worker context is not available in the current test runner. Please, provide the `getWorkerContext` method when initiating the runner.");
		fixtureContext = workerContext;
	} else fixtureContext = fileContext;
	if (fixture.prop in fixtureContext) return fixtureContext[fixture.prop];
	if (!cleanupFnArrayMap.has(fixtureContext)) cleanupFnArrayMap.set(fixtureContext, []);
	const cleanupFnFileArray = cleanupFnArrayMap.get(fixtureContext);
	const promise = resolveFixtureFunction(fixture.value, fixtureContext, cleanupFnFileArray).then((value) => {
		fixtureContext[fixture.prop] = value;
		globalFixturePromise.delete(fixture);
		return value;
	});
	globalFixturePromise.set(fixture, promise);
	return promise;
}
async function resolveFixtureFunction(fixtureFn, context, cleanupFnArray) {
	const useFnArgPromise = createDefer();
	let isUseFnArgResolved = false;
	const fixtureReturn = fixtureFn(context, async (useFnArg) => {
		isUseFnArgResolved = true;
		useFnArgPromise.resolve(useFnArg);
		const useReturnPromise = createDefer();
		cleanupFnArray.push(async () => {
			useReturnPromise.resolve();
			await fixtureReturn;
		});
		await useReturnPromise;
	}).catch((e) => {
		if (!isUseFnArgResolved) {
			useFnArgPromise.reject(e);
			return;
		}
		throw e;
	});
	return useFnArgPromise;
}
function resolveDeps(fixtures, depSet = /* @__PURE__ */ new Set(), pendingFixtures = []) {
	fixtures.forEach((fixture) => {
		if (pendingFixtures.includes(fixture)) return;
		if (!fixture.isFn || !fixture.deps) {
			pendingFixtures.push(fixture);
			return;
		}
		if (depSet.has(fixture)) throw new Error(`Circular fixture dependency detected: ${fixture.prop} <- ${[...depSet].reverse().map((d) => d.prop).join(" <- ")}`);
		depSet.add(fixture);
		resolveDeps(fixture.deps, depSet, pendingFixtures);
		pendingFixtures.push(fixture);
		depSet.clear();
	});
	return pendingFixtures;
}
function getUsedProps(fn$1) {
	let fnString = stripLiteral(fn$1.toString());
	if (/__async\((?:this|null), (?:null|arguments|\[[_0-9, ]*\]), function\*/.test(fnString)) fnString = fnString.split(/__async\((?:this|null),/)[1];
	const match = fnString.match(/[^(]*\(([^)]*)/);
	if (!match) return [];
	const args = splitByComma(match[1]);
	if (!args.length) return [];
	let first = args[0];
	if ("__VITEST_FIXTURE_INDEX__" in fn$1) {
		first = args[fn$1.__VITEST_FIXTURE_INDEX__];
		if (!first) return [];
	}
	if (!(first.startsWith("{") && first.endsWith("}"))) throw new Error(`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received "${first}".`);
	const _first = first.slice(1, -1).replace(/\s/g, "");
	const props = splitByComma(_first).map((prop) => {
		return prop.replace(/:.*|=.*/g, "");
	});
	const last = props.at(-1);
	if (last && last.startsWith("...")) throw new Error(`Rest parameters are not supported in fixtures, received "${last}".`);
	return props;
}
function splitByComma(s) {
	const result = [];
	const stack = [];
	let start = 0;
	for (let i = 0; i < s.length; i++) if (s[i] === "{" || s[i] === "[") stack.push(s[i] === "{" ? "}" : "]");
	else if (s[i] === stack[stack.length - 1]) stack.pop();
	else if (!stack.length && s[i] === ",") {
		const token = s.substring(start, i).trim();
		if (token) result.push(token);
		start = i + 1;
	}
	const lastToken = s.substring(start).trim();
	if (lastToken) result.push(lastToken);
	return result;
}
let _test;
function getCurrentTest() {
	return _test;
}
function createChainable(keys$1, fn$1) {
	function create(context) {
		const chain$1 = function(...args) {
			return fn$1.apply(context, args);
		};
		Object.assign(chain$1, fn$1);
		chain$1.withContext = () => chain$1.bind(context);
		chain$1.setContext = (key, value) => {
			context[key] = value;
		};
		chain$1.mergeContext = (ctx) => {
			Object.assign(context, ctx);
		};
		for (const key of keys$1) Object.defineProperty(chain$1, key, { get() {
			return create({
				...context,
				[key]: true
			});
		} });
		return chain$1;
	}
	const chain = create({});
	chain.fn = fn$1;
	return chain;
}
/**
* Creates a suite of tests, allowing for grouping and hierarchical organization of tests.
* Suites can contain both tests and other suites, enabling complex test structures.
*
* @param {string} name - The name of the suite, used for identification and reporting.
* @param {Function} fn - A function that defines the tests and suites within this suite.
* @example
* ```ts
* // Define a suite with two tests
* suite('Math operations', () => {
*   test('should add two numbers', () => {
*     expect(add(1, 2)).toBe(3);
*   });
*
*   test('should subtract two numbers', () => {
*     expect(subtract(5, 2)).toBe(3);
*   });
* });
* ```
* @example
* ```ts
* // Define nested suites
* suite('String operations', () => {
*   suite('Trimming', () => {
*     test('should trim whitespace from start and end', () => {
*       expect('  hello  '.trim()).toBe('hello');
*     });
*   });
*
*   suite('Concatenation', () => {
*     test('should concatenate two strings', () => {
*       expect('hello' + ' ' + 'world').toBe('hello world');
*     });
*   });
* });
* ```
*/
const suite = createSuite();
/**
* Defines a test case with a given name and test function. The test function can optionally be configured with test options.
*
* @param {string | Function} name - The name of the test or a function that will be used as a test name.
* @param {TestOptions | TestFunction} [optionsOrFn] - Optional. The test options or the test function if no explicit name is provided.
* @param {number | TestOptions | TestFunction} [optionsOrTest] - Optional. The test function or options, depending on the previous parameters.
* @throws {Error} If called inside another test function.
* @example
* ```ts
* // Define a simple test
* test('should add two numbers', () => {
*   expect(add(1, 2)).toBe(3);
* });
* ```
* @example
* ```ts
* // Define a test with options
* test('should subtract two numbers', { retry: 3 }, () => {
*   expect(subtract(5, 2)).toBe(3);
* });
* ```
*/
const test$1 = createTest(function(name, optionsOrFn, optionsOrTest) {
	if (getCurrentTest()) throw new Error("Calling the test function inside another test function is not allowed. Please put it inside \"describe\" or \"suite\" so it can be properly collected.");
	getCurrentSuite().test.fn.call(this, formatName(name), optionsOrFn, optionsOrTest);
});
/**
* Creates a suite of tests, allowing for grouping and hierarchical organization of tests.
* Suites can contain both tests and other suites, enabling complex test structures.
*
* @param {string} name - The name of the suite, used for identification and reporting.
* @param {Function} fn - A function that defines the tests and suites within this suite.
* @example
* ```ts
* // Define a suite with two tests
* describe('Math operations', () => {
*   test('should add two numbers', () => {
*     expect(add(1, 2)).toBe(3);
*   });
*
*   test('should subtract two numbers', () => {
*     expect(subtract(5, 2)).toBe(3);
*   });
* });
* ```
* @example
* ```ts
* // Define nested suites
* describe('String operations', () => {
*   describe('Trimming', () => {
*     test('should trim whitespace from start and end', () => {
*       expect('  hello  '.trim()).toBe('hello');
*     });
*   });
*
*   describe('Concatenation', () => {
*     test('should concatenate two strings', () => {
*       expect('hello' + ' ' + 'world').toBe('hello world');
*     });
*   });
* });
* ```
*/
const describe = suite;
/**
* Defines a test case with a given name and test function. The test function can optionally be configured with test options.
*
* @param {string | Function} name - The name of the test or a function that will be used as a test name.
* @param {TestOptions | TestFunction} [optionsOrFn] - Optional. The test options or the test function if no explicit name is provided.
* @param {number | TestOptions | TestFunction} [optionsOrTest] - Optional. The test function or options, depending on the previous parameters.
* @throws {Error} If called inside another test function.
* @example
* ```ts
* // Define a simple test
* it('adds two numbers', () => {
*   expect(add(1, 2)).toBe(3);
* });
* ```
* @example
* ```ts
* // Define a test with options
* it('subtracts two numbers', { retry: 3 }, () => {
*   expect(subtract(5, 2)).toBe(3);
* });
* ```
*/
const it = test$1;
let runner;
let defaultSuite;
let currentTestFilepath;
function assert(condition, message) {
	if (!condition) throw new Error(`Vitest failed to find ${message}. This is a bug in Vitest. Please, open an issue with reproduction.`);
}
function getTestFilepath() {
	return currentTestFilepath;
}
function getRunner() {
	assert(runner, "the runner");
	return runner;
}
function getCurrentSuite() {
	const currentSuite = collectorContext.currentSuite || defaultSuite;
	assert(currentSuite, "the current suite");
	return currentSuite;
}
function createSuiteHooks() {
	return {
		beforeAll: [],
		afterAll: [],
		beforeEach: [],
		afterEach: []
	};
}
function parseArguments(optionsOrFn, optionsOrTest) {
	let options = {};
	let fn$1 = () => {};
	if (typeof optionsOrTest === "object") {
		if (typeof optionsOrFn === "object") throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");
		console.warn("Using an object as a third argument is deprecated. Vitest 4 will throw an error if the third argument is not a timeout number. Please use the second argument for options. See more at https://vitest.dev/guide/migration");
		options = optionsOrTest;
	} else if (typeof optionsOrTest === "number") options = { timeout: optionsOrTest };
	else if (typeof optionsOrFn === "object") options = optionsOrFn;
	if (typeof optionsOrFn === "function") {
		if (typeof optionsOrTest === "function") throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");
		fn$1 = optionsOrFn;
	} else if (typeof optionsOrTest === "function") fn$1 = optionsOrTest;
	return {
		options,
		handler: fn$1
	};
}
function createSuiteCollector(name, factory = () => {}, mode, each, suiteOptions, parentCollectorFixtures) {
	const tasks = [];
	let suite$1;
	initSuite(true);
	const task = function(name$1 = "", options = {}) {
		var _collectorContext$cur;
		const timeout = (options === null || options === void 0 ? void 0 : options.timeout) ?? runner.config.testTimeout;
		const task$1 = {
			id: "",
			name: name$1,
			suite: (_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 ? void 0 : _collectorContext$cur.suite,
			each: options.each,
			fails: options.fails,
			context: void 0,
			type: "test",
			file: void 0,
			timeout,
			retry: options.retry ?? runner.config.retry,
			repeats: options.repeats,
			mode: options.only ? "only" : options.skip ? "skip" : options.todo ? "todo" : "run",
			meta: options.meta ?? Object.create(null),
			annotations: []
		};
		const handler = options.handler;
		if (options.concurrent || !options.sequential && runner.config.sequence.concurrent) task$1.concurrent = true;
		task$1.shuffle = suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.shuffle;
		const context = createTestContext(task$1, runner);
		Object.defineProperty(task$1, "context", {
			value: context,
			enumerable: false
		});
		setTestFixture(context, options.fixtures);
		const limit = Error.stackTraceLimit;
		Error.stackTraceLimit = 15;
		const stackTraceError = /* @__PURE__ */ new Error("STACK_TRACE_ERROR");
		Error.stackTraceLimit = limit;
		if (handler) setFn(task$1, withTimeout(withAwaitAsyncAssertions(withFixtures(runner, handler, context), task$1), timeout, false, stackTraceError, (_, error) => abortIfTimeout([context], error)));
		if (runner.config.includeTaskLocation) {
			const error = stackTraceError.stack;
			const stack = findTestFileStackTrace(error);
			if (stack) task$1.location = stack;
		}
		tasks.push(task$1);
		return task$1;
	};
	const test$7 = createTest(function(name$1, optionsOrFn, optionsOrTest) {
		let { options, handler } = parseArguments(optionsOrFn, optionsOrTest);
		if (typeof suiteOptions === "object") options = Object.assign({}, suiteOptions, options);
		options.concurrent = this.concurrent || !this.sequential && (options === null || options === void 0 ? void 0 : options.concurrent);
		options.sequential = this.sequential || !this.concurrent && (options === null || options === void 0 ? void 0 : options.sequential);
		const test$8 = task(formatName(name$1), {
			...this,
			...options,
			handler
		});
		test$8.type = "test";
	});
	let collectorFixtures = parentCollectorFixtures;
	const collector = {
		type: "collector",
		name,
		mode,
		suite: suite$1,
		options: suiteOptions,
		test: test$7,
		tasks,
		collect,
		task,
		clear,
		on: addHook,
		fixtures() {
			return collectorFixtures;
		},
		scoped(fixtures) {
			const parsed = mergeContextFixtures(fixtures, { fixtures: collectorFixtures }, runner);
			if (parsed.fixtures) collectorFixtures = parsed.fixtures;
		}
	};
	function addHook(name$1, ...fn$1) {
		getHooks(suite$1)[name$1].push(...fn$1);
	}
	function initSuite(includeLocation) {
		var _collectorContext$cur2;
		if (typeof suiteOptions === "number") suiteOptions = { timeout: suiteOptions };
		suite$1 = {
			id: "",
			type: "suite",
			name,
			suite: (_collectorContext$cur2 = collectorContext.currentSuite) === null || _collectorContext$cur2 === void 0 ? void 0 : _collectorContext$cur2.suite,
			mode,
			each,
			file: void 0,
			shuffle: suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.shuffle,
			tasks: [],
			meta: Object.create(null),
			concurrent: suiteOptions === null || suiteOptions === void 0 ? void 0 : suiteOptions.concurrent
		};
		if (runner && includeLocation && runner.config.includeTaskLocation) {
			const limit = Error.stackTraceLimit;
			Error.stackTraceLimit = 15;
			const error = (/* @__PURE__ */ new Error("stacktrace")).stack;
			Error.stackTraceLimit = limit;
			const stack = findTestFileStackTrace(error);
			if (stack) suite$1.location = stack;
		}
		setHooks(suite$1, createSuiteHooks());
	}
	function clear() {
		tasks.length = 0;
		initSuite(false);
	}
	async function collect(file) {
		if (!file) throw new TypeError("File is required to collect tasks.");
		if (factory) await runWithSuite(collector, () => factory(test$7));
		const allChildren = [];
		for (const i of tasks) allChildren.push(i.type === "collector" ? await i.collect(file) : i);
		suite$1.file = file;
		suite$1.tasks = allChildren;
		allChildren.forEach((task$1) => {
			task$1.file = file;
		});
		return suite$1;
	}
	collectTask(collector);
	return collector;
}
function withAwaitAsyncAssertions(fn$1, task) {
	return async (...args) => {
		const fnResult = await fn$1(...args);
		if (task.promises) {
			const errors = (await Promise.allSettled(task.promises)).map((r$1) => r$1.status === "rejected" ? r$1.reason : void 0).filter(Boolean);
			if (errors.length) throw errors;
		}
		return fnResult;
	};
}
function createSuite() {
	function suiteFn(name, factoryOrOptions, optionsOrFactory) {
		var _currentSuite$options;
		const mode = this.only ? "only" : this.skip ? "skip" : this.todo ? "todo" : "run";
		const currentSuite = collectorContext.currentSuite || defaultSuite;
		let { options, handler: factory } = parseArguments(factoryOrOptions, optionsOrFactory);
		const isConcurrentSpecified = options.concurrent || this.concurrent || options.sequential === false;
		const isSequentialSpecified = options.sequential || this.sequential || options.concurrent === false;
		options = {
			...currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.options,
			...options,
			shuffle: this.shuffle ?? options.shuffle ?? (currentSuite === null || currentSuite === void 0 || (_currentSuite$options = currentSuite.options) === null || _currentSuite$options === void 0 ? void 0 : _currentSuite$options.shuffle) ?? (runner === null || runner === void 0 ? void 0 : runner.config.sequence.shuffle)
		};
		const isConcurrent = isConcurrentSpecified || options.concurrent && !isSequentialSpecified;
		const isSequential = isSequentialSpecified || options.sequential && !isConcurrentSpecified;
		options.concurrent = isConcurrent && !isSequential;
		options.sequential = isSequential && !isConcurrent;
		return createSuiteCollector(formatName(name), factory, mode, this.each, options, currentSuite === null || currentSuite === void 0 ? void 0 : currentSuite.fixtures());
	}
	suiteFn.each = function(cases, ...args) {
		const suite$1 = this.withContext();
		this.setContext("each", true);
		if (Array.isArray(cases) && args.length) cases = formatTemplateString(cases, args);
		return (name, optionsOrFn, fnOrOptions) => {
			const _name = formatName(name);
			const arrayOnlyCases = cases.every(Array.isArray);
			const { options, handler } = parseArguments(optionsOrFn, fnOrOptions);
			const fnFirst = typeof optionsOrFn === "function" && typeof fnOrOptions === "object";
			cases.forEach((i, idx) => {
				const items = Array.isArray(i) ? i : [i];
				if (fnFirst) if (arrayOnlyCases) suite$1(formatTitle(_name, items, idx), () => handler(...items), options);
				else suite$1(formatTitle(_name, items, idx), () => handler(i), options);
				else if (arrayOnlyCases) suite$1(formatTitle(_name, items, idx), options, () => handler(...items));
				else suite$1(formatTitle(_name, items, idx), options, () => handler(i));
			});
			this.setContext("each", void 0);
		};
	};
	suiteFn.for = function(cases, ...args) {
		if (Array.isArray(cases) && args.length) cases = formatTemplateString(cases, args);
		return (name, optionsOrFn, fnOrOptions) => {
			const name_ = formatName(name);
			const { options, handler } = parseArguments(optionsOrFn, fnOrOptions);
			cases.forEach((item, idx) => {
				suite(formatTitle(name_, toArray(item), idx), options, () => handler(item));
			});
		};
	};
	suiteFn.skipIf = (condition) => condition ? suite.skip : suite;
	suiteFn.runIf = (condition) => condition ? suite : suite.skip;
	return createChainable([
		"concurrent",
		"sequential",
		"shuffle",
		"skip",
		"only",
		"todo"
	], suiteFn);
}
function createTaskCollector(fn$1, context) {
	const taskFn = fn$1;
	taskFn.each = function(cases, ...args) {
		const test$7 = this.withContext();
		this.setContext("each", true);
		if (Array.isArray(cases) && args.length) cases = formatTemplateString(cases, args);
		return (name, optionsOrFn, fnOrOptions) => {
			const _name = formatName(name);
			const arrayOnlyCases = cases.every(Array.isArray);
			const { options, handler } = parseArguments(optionsOrFn, fnOrOptions);
			const fnFirst = typeof optionsOrFn === "function" && typeof fnOrOptions === "object";
			cases.forEach((i, idx) => {
				const items = Array.isArray(i) ? i : [i];
				if (fnFirst) if (arrayOnlyCases) test$7(formatTitle(_name, items, idx), () => handler(...items), options);
				else test$7(formatTitle(_name, items, idx), () => handler(i), options);
				else if (arrayOnlyCases) test$7(formatTitle(_name, items, idx), options, () => handler(...items));
				else test$7(formatTitle(_name, items, idx), options, () => handler(i));
			});
			this.setContext("each", void 0);
		};
	};
	taskFn.for = function(cases, ...args) {
		const test$7 = this.withContext();
		if (Array.isArray(cases) && args.length) cases = formatTemplateString(cases, args);
		return (name, optionsOrFn, fnOrOptions) => {
			const _name = formatName(name);
			const { options, handler } = parseArguments(optionsOrFn, fnOrOptions);
			cases.forEach((item, idx) => {
				const handlerWrapper = (ctx) => handler(item, ctx);
				handlerWrapper.__VITEST_FIXTURE_INDEX__ = 1;
				handlerWrapper.toString = () => handler.toString();
				test$7(formatTitle(_name, toArray(item), idx), options, handlerWrapper);
			});
		};
	};
	taskFn.skipIf = function(condition) {
		return condition ? this.skip : this;
	};
	taskFn.runIf = function(condition) {
		return condition ? this : this.skip;
	};
	taskFn.scoped = function(fixtures) {
		getCurrentSuite().scoped(fixtures);
	};
	taskFn.extend = function(fixtures) {
		const _context = mergeContextFixtures(fixtures, context || {}, runner);
		const originalWrapper = fn$1;
		return createTest(function(name, optionsOrFn, optionsOrTest) {
			const scopedFixtures = getCurrentSuite().fixtures();
			const context$1 = { ...this };
			if (scopedFixtures) context$1.fixtures = mergeScopedFixtures(context$1.fixtures || [], scopedFixtures);
			const { handler, options } = parseArguments(optionsOrFn, optionsOrTest);
			const timeout = options.timeout ?? (runner === null || runner === void 0 ? void 0 : runner.config.testTimeout);
			originalWrapper.call(context$1, formatName(name), handler, timeout);
		}, _context);
	};
	const _test$1 = createChainable([
		"concurrent",
		"sequential",
		"skip",
		"only",
		"todo",
		"fails"
	], taskFn);
	if (context) _test$1.mergeContext(context);
	return _test$1;
}
function createTest(fn$1, context) {
	return createTaskCollector(fn$1, context);
}
function formatName(name) {
	return typeof name === "string" ? name : typeof name === "function" ? name.name || "<anonymous>" : String(name);
}
function formatTitle(template, items, idx) {
	if (template.includes("%#") || template.includes("%$")) template = template.replace(/%%/g, "__vitest_escaped_%__").replace(/%#/g, `${idx}`).replace(/%\$/g, `${idx + 1}`).replace(/__vitest_escaped_%__/g, "%%");
	const count = template.split("%").length - 1;
	if (template.includes("%f")) (template.match(/%f/g) || []).forEach((_, i) => {
		if (isNegativeNaN(items[i]) || Object.is(items[i], -0)) {
			let occurrence = 0;
			template = template.replace(/%f/g, (match) => {
				occurrence++;
				return occurrence === i + 1 ? "-%f" : match;
			});
		}
	});
	let formatted = format$1(template, ...items.slice(0, count));
	const isObjectItem = isObject$1(items[0]);
	formatted = formatted.replace(/\$([$\w.]+)/g, (_, key) => {
		var _runner$config;
		const isArrayKey = /^\d+$/.test(key);
		if (!isObjectItem && !isArrayKey) return `$${key}`;
		const arrayElement = isArrayKey ? objectAttr(items, key) : void 0;
		const value = isObjectItem ? objectAttr(items[0], key, arrayElement) : arrayElement;
		return objDisplay(value, { truncate: runner === null || runner === void 0 || (_runner$config = runner.config) === null || _runner$config === void 0 || (_runner$config = _runner$config.chaiConfig) === null || _runner$config === void 0 ? void 0 : _runner$config.truncateThreshold });
	});
	return formatted;
}
function formatTemplateString(cases, args) {
	const header = cases.join("").trim().replace(/ /g, "").split("\n").map((i) => i.split("|"))[0];
	const res = [];
	for (let i = 0; i < Math.floor(args.length / header.length); i++) {
		const oneCase = {};
		for (let j$1 = 0; j$1 < header.length; j$1++) oneCase[header[j$1]] = args[i * header.length + j$1];
		res.push(oneCase);
	}
	return res;
}
function findTestFileStackTrace(error) {
	const testFilePath = getTestFilepath();
	const lines = error.split("\n").slice(1);
	for (const line of lines) {
		const stack = parseSingleStack(line);
		if (stack && stack.file === testFilePath) return {
			line: stack.line,
			column: stack.column
		};
	}
}
const now$2 = globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;
function getNames(task) {
	const names = [task.name];
	let current = task;
	while (current === null || current === void 0 ? void 0 : current.suite) {
		current = current.suite;
		if (current === null || current === void 0 ? void 0 : current.name) names.unshift(current.name);
	}
	if (current !== task.file) names.unshift(task.file.name);
	return names;
}
function getTestName(task, separator = " > ") {
	return getNames(task).slice(1).join(separator);
}
const now$1 = globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;
const unixNow = Date.now;
const { clearTimeout, setTimeout } = getSafeTimers();
const packs = /* @__PURE__ */ new Map();
const eventsPacks = [];
const pendingTasksUpdates = [];
function sendTasksUpdate(runner$1) {
	if (packs.size) {
		var _runner$onTaskUpdate;
		const taskPacks = Array.from(packs).map(([id, task]) => {
			return [
				id,
				task[0],
				task[1]
			];
		});
		const p$2 = (_runner$onTaskUpdate = runner$1.onTaskUpdate) === null || _runner$onTaskUpdate === void 0 ? void 0 : _runner$onTaskUpdate.call(runner$1, taskPacks, eventsPacks);
		if (p$2) {
			pendingTasksUpdates.push(p$2);
			p$2.then(() => pendingTasksUpdates.splice(pendingTasksUpdates.indexOf(p$2), 1), () => {});
		}
		eventsPacks.length = 0;
		packs.clear();
	}
}
async function finishSendTasksUpdate(runner$1) {
	sendTasksUpdate(runner$1);
	await Promise.all(pendingTasksUpdates);
}
function throttle(fn$1, ms) {
	let last = 0;
	let pendingCall;
	return function call$1(...args) {
		const now$4 = unixNow();
		if (now$4 - last > ms) {
			last = now$4;
			clearTimeout(pendingCall);
			pendingCall = void 0;
			return fn$1.apply(this, args);
		}
		pendingCall ?? (pendingCall = setTimeout(() => call$1.bind(this)(...args), ms));
	};
}
const sendTasksUpdateThrottled = throttle(sendTasksUpdate, 100);
const now$3 = Date.now;
const collectorContext = {
	tasks: [],
	currentSuite: null
};
function collectTask(task) {
	var _collectorContext$cur;
	(_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 || _collectorContext$cur.tasks.push(task);
}
async function runWithSuite(suite$1, fn$1) {
	const prev = collectorContext.currentSuite;
	collectorContext.currentSuite = suite$1;
	await fn$1();
	collectorContext.currentSuite = prev;
}
function withTimeout(fn$1, timeout, isHook = false, stackTraceError, onTimeout) {
	if (timeout <= 0 || timeout === Number.POSITIVE_INFINITY) return fn$1;
	const { setTimeout: setTimeout$1, clearTimeout: clearTimeout$1 } = getSafeTimers();
	return function runWithTimeout(...args) {
		const startTime = now$3();
		const runner$1 = getRunner();
		runner$1._currentTaskStartTime = startTime;
		runner$1._currentTaskTimeout = timeout;
		return new Promise((resolve_, reject_) => {
			var _timer$unref;
			const timer = setTimeout$1(() => {
				clearTimeout$1(timer);
				rejectTimeoutError();
			}, timeout);
			(_timer$unref = timer.unref) === null || _timer$unref === void 0 || _timer$unref.call(timer);
			function rejectTimeoutError() {
				const error = makeTimeoutError(isHook, timeout, stackTraceError);
				onTimeout === null || onTimeout === void 0 || onTimeout(args, error);
				reject_(error);
			}
			function resolve$4(result) {
				runner$1._currentTaskStartTime = void 0;
				runner$1._currentTaskTimeout = void 0;
				clearTimeout$1(timer);
				if (now$3() - startTime >= timeout) {
					rejectTimeoutError();
					return;
				}
				resolve_(result);
			}
			function reject(error) {
				runner$1._currentTaskStartTime = void 0;
				runner$1._currentTaskTimeout = void 0;
				clearTimeout$1(timer);
				reject_(error);
			}
			try {
				const result = fn$1(...args);
				if (typeof result === "object" && result != null && typeof result.then === "function") result.then(resolve$4, reject);
				else resolve$4(result);
			} catch (error) {
				reject(error);
			}
		});
	};
}
const abortControllers = /* @__PURE__ */ new WeakMap();
function abortIfTimeout([context], error) {
	if (context) abortContextSignal(context, error);
}
function abortContextSignal(context, error) {
	const abortController = abortControllers.get(context);
	abortController === null || abortController === void 0 || abortController.abort(error);
}
function createTestContext(test$7, runner$1) {
	var _runner$extendTaskCon;
	const context = function() {
		throw new Error("done() callback is deprecated, use promise instead");
	};
	let abortController = abortControllers.get(context);
	if (!abortController) {
		abortController = new AbortController();
		abortControllers.set(context, abortController);
	}
	context.signal = abortController.signal;
	context.task = test$7;
	context.skip = (condition, note) => {
		if (condition === false) return;
		test$7.result ?? (test$7.result = { state: "skip" });
		test$7.result.pending = true;
		throw new PendingError("test is skipped; abort execution", test$7, typeof condition === "string" ? condition : note);
	};
	async function annotate(message, location, type$1, attachment) {
		const annotation = {
			message,
			type: type$1 || "notice"
		};
		if (attachment) {
			if (!attachment.body && !attachment.path) throw new TypeError(`Test attachment requires body or path to be set. Both are missing.`);
			if (attachment.body && attachment.path) throw new TypeError(`Test attachment requires only one of "body" or "path" to be set. Both are specified.`);
			annotation.attachment = attachment;
			if (attachment.body instanceof Uint8Array) attachment.body = encodeUint8Array(attachment.body);
		}
		if (location) annotation.location = location;
		if (!runner$1.onTestAnnotate) throw new Error(`Test runner doesn't support test annotations.`);
		await finishSendTasksUpdate(runner$1);
		const resolvedAnnotation = await runner$1.onTestAnnotate(test$7, annotation);
		test$7.annotations.push(resolvedAnnotation);
		return resolvedAnnotation;
	}
	context.annotate = (message, type$1, attachment) => {
		if (test$7.result && test$7.result.state !== "run") throw new Error(`Cannot annotate tests outside of the test run. The test "${test$7.name}" finished running with the "${test$7.result.state}" state already.`);
		let location;
		const stack = (/* @__PURE__ */ new Error("STACK_TRACE")).stack;
		const index = stack.includes("STACK_TRACE") ? 2 : 1;
		const stackLine = stack.split("\n")[index];
		const parsed = parseSingleStack(stackLine);
		if (parsed) location = {
			file: parsed.file,
			line: parsed.line,
			column: parsed.column
		};
		if (typeof type$1 === "object") return recordAsyncAnnotation(test$7, annotate(message, location, void 0, type$1));
		else return recordAsyncAnnotation(test$7, annotate(message, location, type$1, attachment));
	};
	context.onTestFailed = (handler, timeout) => {
		test$7.onFailed || (test$7.onFailed = []);
		test$7.onFailed.push(withTimeout(handler, timeout ?? runner$1.config.hookTimeout, true, /* @__PURE__ */ new Error("STACK_TRACE_ERROR"), (_, error) => abortController.abort(error)));
	};
	context.onTestFinished = (handler, timeout) => {
		test$7.onFinished || (test$7.onFinished = []);
		test$7.onFinished.push(withTimeout(handler, timeout ?? runner$1.config.hookTimeout, true, /* @__PURE__ */ new Error("STACK_TRACE_ERROR"), (_, error) => abortController.abort(error)));
	};
	return ((_runner$extendTaskCon = runner$1.extendTaskContext) === null || _runner$extendTaskCon === void 0 ? void 0 : _runner$extendTaskCon.call(runner$1, context)) || context;
}
function makeTimeoutError(isHook, timeout, stackTraceError) {
	const message = `${isHook ? "Hook" : "Test"} timed out in ${timeout}ms.\nIf this is a long-running ${isHook ? "hook" : "test"}, pass a timeout value as the last argument or configure it globally with "${isHook ? "hookTimeout" : "testTimeout"}".`;
	const error = new Error(message);
	if (stackTraceError === null || stackTraceError === void 0 ? void 0 : stackTraceError.stack) error.stack = stackTraceError.stack.replace(error.message, stackTraceError.message);
	return error;
}
const fileContexts = /* @__PURE__ */ new WeakMap();
function getFileContext(file) {
	const context = fileContexts.get(file);
	if (!context) throw new Error(`Cannot find file context for ${file.name}`);
	return context;
}
const table = [];
for (let i = 65; i < 91; i++) table.push(String.fromCharCode(i));
for (let i = 97; i < 123; i++) table.push(String.fromCharCode(i));
for (let i = 0; i < 10; i++) table.push(i.toString(10));
function encodeUint8Array(bytes) {
	let base64 = "";
	const len = bytes.byteLength;
	for (let i = 0; i < len; i += 3) if (len === i + 1) {
		const a$2 = (bytes[i] & 252) >> 2;
		const b$1 = (bytes[i] & 3) << 4;
		base64 += table[a$2];
		base64 += table[b$1];
		base64 += "==";
	} else if (len === i + 2) {
		const a$2 = (bytes[i] & 252) >> 2;
		const b$1 = (bytes[i] & 3) << 4 | (bytes[i + 1] & 240) >> 4;
		const c = (bytes[i + 1] & 15) << 2;
		base64 += table[a$2];
		base64 += table[b$1];
		base64 += table[c];
		base64 += "=";
	} else {
		const a$2 = (bytes[i] & 252) >> 2;
		const b$1 = (bytes[i] & 3) << 4 | (bytes[i + 1] & 240) >> 4;
		const c = (bytes[i + 1] & 15) << 2 | (bytes[i + 2] & 192) >> 6;
		const d = bytes[i + 2] & 63;
		base64 += table[a$2];
		base64 += table[b$1];
		base64 += table[c];
		base64 += table[d];
	}
	return base64;
}
function recordAsyncAnnotation(test$7, promise) {
	promise = promise.finally(() => {
		if (!test$7.promises) return;
		const index = test$7.promises.indexOf(promise);
		if (index !== -1) test$7.promises.splice(index, 1);
	});
	if (!test$7.promises) test$7.promises = [];
	test$7.promises.push(promise);
	return promise;
}
function getDefaultHookTimeout() {
	return getRunner().config.hookTimeout;
}
const CLEANUP_TIMEOUT_KEY = Symbol.for("VITEST_CLEANUP_TIMEOUT");
const CLEANUP_STACK_TRACE_KEY = Symbol.for("VITEST_CLEANUP_STACK_TRACE");
/**
* Registers a callback function to be executed before each test within the current suite.
* This hook is useful for scenarios where you need to reset or reinitialize the test environment before each test runs, such as resetting database states, clearing caches, or reinitializing variables.
*
* **Note:** The `beforeEach` hooks are executed in the order they are defined one after another. You can configure this by changing the `sequence.hooks` option in the config file.
*
* @param {Function} fn - The callback function to be executed before each test. This function receives an `TestContext` parameter if additional test context is needed.
* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.
* @returns {void}
* @example
* ```ts
* // Example of using beforeEach to reset a database state
* beforeEach(async () => {
*   await database.reset();
* });
* ```
*/
function beforeEach(fn$1, timeout = getDefaultHookTimeout()) {
	assertTypes(fn$1, "\"beforeEach\" callback", ["function"]);
	const stackTraceError = /* @__PURE__ */ new Error("STACK_TRACE_ERROR");
	const runner$1 = getRunner();
	return getCurrentSuite().on("beforeEach", Object.assign(withTimeout(withFixtures(runner$1, fn$1), timeout ?? getDefaultHookTimeout(), true, stackTraceError, abortIfTimeout), {
		[CLEANUP_TIMEOUT_KEY]: timeout,
		[CLEANUP_STACK_TRACE_KEY]: stackTraceError
	}));
}
/**
* Registers a callback function to be executed after each test within the current suite has completed.
* This hook is useful for scenarios where you need to clean up or reset the test environment after each test runs, such as deleting temporary files, clearing test-specific database entries, or resetting mocked functions.
*
* **Note:** The `afterEach` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.
*
* @param {Function} fn - The callback function to be executed after each test. This function receives an `TestContext` parameter if additional test context is needed.
* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.
* @returns {void}
* @example
* ```ts
* // Example of using afterEach to delete temporary files created during a test
* afterEach(async () => {
*   await fileSystem.deleteTempFiles();
* });
* ```
*/
function afterEach(fn$1, timeout) {
	assertTypes(fn$1, "\"afterEach\" callback", ["function"]);
	const runner$1 = getRunner();
	return getCurrentSuite().on("afterEach", withTimeout(withFixtures(runner$1, fn$1), timeout ?? getDefaultHookTimeout(), true, /* @__PURE__ */ new Error("STACK_TRACE_ERROR"), abortIfTimeout));
}
/**
* Registers a callback function to be executed when a test fails within the current suite.
* This function allows for custom actions to be performed in response to test failures, such as logging, cleanup, or additional diagnostics.
*
* **Note:** The `onTestFailed` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.
*
* @param {Function} fn - The callback function to be executed upon a test failure. The function receives the test result (including errors).
* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.
* @throws {Error} Throws an error if the function is not called within a test.
* @returns {void}
* @example
* ```ts
* // Example of using onTestFailed to log failure details
* onTestFailed(({ errors }) => {
*   console.log(`Test failed: ${test.name}`, errors);
* });
* ```
*/
const onTestFailed = createTestHook("onTestFailed", (test$7, handler, timeout) => {
	test$7.onFailed || (test$7.onFailed = []);
	test$7.onFailed.push(withTimeout(handler, timeout ?? getDefaultHookTimeout(), true, /* @__PURE__ */ new Error("STACK_TRACE_ERROR"), abortIfTimeout));
});
/**
* Registers a callback function to be executed when the current test finishes, regardless of the outcome (pass or fail).
* This function is ideal for performing actions that should occur after every test execution, such as cleanup, logging, or resetting shared resources.
*
* This hook is useful if you have access to a resource in the test itself and you want to clean it up after the test finishes. It is a more compact way to clean up resources than using the combination of `beforeEach` and `afterEach`.
*
* **Note:** The `onTestFinished` hooks are running in reverse order of their registration. You can configure this by changing the `sequence.hooks` option in the config file.
*
* **Note:** The `onTestFinished` hook is not called if the test is canceled with a dynamic `ctx.skip()` call.
*
* @param {Function} fn - The callback function to be executed after a test finishes. The function can receive parameters providing details about the completed test, including its success or failure status.
* @param {number} [timeout] - Optional timeout in milliseconds for the hook. If not provided, the default hook timeout from the runner's configuration is used.
* @throws {Error} Throws an error if the function is not called within a test.
* @returns {void}
* @example
* ```ts
* // Example of using onTestFinished for cleanup
* const db = await connectToDatabase();
* onTestFinished(async () => {
*   await db.disconnect();
* });
* ```
*/
const onTestFinished = createTestHook("onTestFinished", (test$7, handler, timeout) => {
	test$7.onFinished || (test$7.onFinished = []);
	test$7.onFinished.push(withTimeout(handler, timeout ?? getDefaultHookTimeout(), true, /* @__PURE__ */ new Error("STACK_TRACE_ERROR"), abortIfTimeout));
});
function createTestHook(name, handler) {
	return (fn$1, timeout) => {
		assertTypes(fn$1, `"${name}" callback`, ["function"]);
		const current = getCurrentTest();
		if (!current) throw new Error(`Hook ${name}() can only be called inside a test`);
		return handler(current, fn$1, timeout);
	};
}

//#endregion
//#region node_modules/.pnpm/vitest@3.2.4_@types+node@24.5.2/node_modules/vitest/dist/chunks/utils.XdZDrNZV.js
const NAME_WORKER_STATE = "__vitest_worker__";
function getWorkerState() {
	const workerState = globalThis[NAME_WORKER_STATE];
	if (!workerState) throw new Error("Vitest failed to access its internal state.\n\nOne of the following is possible:\n- \"vitest\" is imported directly without running \"vitest\" command\n- \"vitest\" is imported inside \"globalSetup\" (to fix this, use \"setupFiles\" instead, because \"globalSetup\" runs in a different context)\n- \"vitest\" is imported inside Vite / Vitest config file\n- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues\n");
	return workerState;
}
function getCurrentEnvironment() {
	return getWorkerState()?.environment.name;
}
function isChildProcess() {
	return typeof process !== "undefined" && !!process.send;
}
function resetModules(modules, resetMocks = false) {
	const skipPaths = [
		/\/vitest\/dist\//,
		/\/vite-node\/dist\//,
		/vitest-virtual-\w+\/dist/,
		/@vitest\/dist/,
		...!resetMocks ? [/^mock:/] : []
	];
	modules.forEach((mod, path) => {
		if (skipPaths.some((re) => re.test(path))) return;
		modules.invalidateModule(mod);
	});
}
function waitNextTick() {
	const { setTimeout: setTimeout$1 } = getSafeTimers();
	return new Promise((resolve$4) => setTimeout$1(resolve$4, 0));
}
async function waitForImportsToResolve() {
	await waitNextTick();
	const state = getWorkerState();
	const promises = [];
	let resolvingCount = 0;
	for (const mod of state.moduleCache.values()) {
		if (mod.promise && !mod.evaluated) promises.push(mod.promise);
		if (mod.resolving) resolvingCount++;
	}
	if (!promises.length && !resolvingCount) return;
	await Promise.allSettled(promises);
	await waitForImportsToResolve();
}

//#endregion
//#region node_modules/.pnpm/vitest@3.2.4_@types+node@24.5.2/node_modules/vitest/dist/chunks/_commonjsHelpers.BFTU3MAI.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x$1) {
	return x$1 && x$1.__esModule && Object.prototype.hasOwnProperty.call(x$1, "default") ? x$1["default"] : x$1;
}

//#endregion
//#region node_modules/.pnpm/@vitest+snapshot@3.2.4/node_modules/@vitest/snapshot/dist/index.js
const comma = ",".charCodeAt(0);
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const intToChar = new Uint8Array(64);
const charToInt = new Uint8Array(128);
for (let i = 0; i < 64; i++) {
	const c = chars.charCodeAt(i);
	intToChar[i] = c;
	charToInt[c] = i;
}
function decodeInteger(reader, relative) {
	let value = 0;
	let shift = 0;
	let integer = 0;
	do {
		const c = reader.next();
		integer = charToInt[c];
		value |= (integer & 31) << shift;
		shift += 5;
	} while (integer & 32);
	const shouldNegate = value & 1;
	value >>>= 1;
	if (shouldNegate) value = -2147483648 | -value;
	return relative + value;
}
function hasMoreVlq(reader, max) {
	if (reader.pos >= max) return false;
	return reader.peek() !== comma;
}
var StringReader = class {
	constructor(buffer) {
		this.pos = 0;
		this.buffer = buffer;
	}
	next() {
		return this.buffer.charCodeAt(this.pos++);
	}
	peek() {
		return this.buffer.charCodeAt(this.pos);
	}
	indexOf(char) {
		const { buffer, pos } = this;
		const idx = buffer.indexOf(char, pos);
		return idx === -1 ? buffer.length : idx;
	}
};
function decode(mappings) {
	const { length } = mappings;
	const reader = new StringReader(mappings);
	const decoded = [];
	let genColumn = 0;
	let sourcesIndex = 0;
	let sourceLine = 0;
	let sourceColumn = 0;
	let namesIndex = 0;
	do {
		const semi = reader.indexOf(";");
		const line = [];
		let sorted = true;
		let lastCol = 0;
		genColumn = 0;
		while (reader.pos < semi) {
			let seg;
			genColumn = decodeInteger(reader, genColumn);
			if (genColumn < lastCol) sorted = false;
			lastCol = genColumn;
			if (hasMoreVlq(reader, semi)) {
				sourcesIndex = decodeInteger(reader, sourcesIndex);
				sourceLine = decodeInteger(reader, sourceLine);
				sourceColumn = decodeInteger(reader, sourceColumn);
				if (hasMoreVlq(reader, semi)) {
					namesIndex = decodeInteger(reader, namesIndex);
					seg = [
						genColumn,
						sourcesIndex,
						sourceLine,
						sourceColumn,
						namesIndex
					];
				} else seg = [
					genColumn,
					sourcesIndex,
					sourceLine,
					sourceColumn
				];
			} else seg = [genColumn];
			line.push(seg);
			reader.pos++;
		}
		if (!sorted) sort(line);
		decoded.push(line);
		reader.pos = semi + 1;
	} while (reader.pos <= length);
	return decoded;
}
function sort(line) {
	line.sort(sortComparator$1);
}
function sortComparator$1(a$2, b$1) {
	return a$2[0] - b$1[0];
}
const schemeRegex = /^[\w+.-]+:\/\//;
/**
* Matches the parts of a URL:
* 1. Scheme, including ":", guaranteed.
* 2. User/password, including "@", optional.
* 3. Host, guaranteed.
* 4. Port, including ":", optional.
* 5. Path, including "/", optional.
* 6. Query, including "?", optional.
* 7. Hash, including "#", optional.
*/
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
*
* 1. Host, optional.
* 2. Path, which may include "/", guaranteed.
* 3. Query, including "?", optional.
* 4. Hash, including "#", optional.
*/
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
(function(UrlType$2) {
	UrlType$2[UrlType$2["Empty"] = 1] = "Empty";
	UrlType$2[UrlType$2["Hash"] = 2] = "Hash";
	UrlType$2[UrlType$2["Query"] = 3] = "Query";
	UrlType$2[UrlType$2["RelativePath"] = 4] = "RelativePath";
	UrlType$2[UrlType$2["AbsolutePath"] = 5] = "AbsolutePath";
	UrlType$2[UrlType$2["SchemeRelative"] = 6] = "SchemeRelative";
	UrlType$2[UrlType$2["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
	return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
	return input.startsWith("//");
}
function isAbsolutePath(input) {
	return input.startsWith("/");
}
function isFileUrl(input) {
	return input.startsWith("file:");
}
function isRelative(input) {
	return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
	const match = urlRegex.exec(input);
	return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
	const match = fileRegex.exec(input);
	const path = match[2];
	return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path, query, hash) {
	return {
		scheme,
		user,
		host,
		port,
		path,
		query,
		hash,
		type: UrlType.Absolute
	};
}
function parseUrl(input) {
	if (isSchemeRelativeUrl(input)) {
		const url$1 = parseAbsoluteUrl("http:" + input);
		url$1.scheme = "";
		url$1.type = UrlType.SchemeRelative;
		return url$1;
	}
	if (isAbsolutePath(input)) {
		const url$1 = parseAbsoluteUrl("http://foo.com" + input);
		url$1.scheme = "";
		url$1.host = "";
		url$1.type = UrlType.AbsolutePath;
		return url$1;
	}
	if (isFileUrl(input)) return parseFileUrl(input);
	if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
	const url = parseAbsoluteUrl("http://foo.com/" + input);
	url.scheme = "";
	url.host = "";
	url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
	return url;
}
function stripPathFilename(path) {
	if (path.endsWith("/..")) return path;
	const index = path.lastIndexOf("/");
	return path.slice(0, index + 1);
}
function mergePaths(url, base) {
	normalizePath(base, base.type);
	if (url.path === "/") url.path = base.path;
	else url.path = stripPathFilename(base.path) + url.path;
}
/**
* The path can have empty directories "//", unneeded parents "foo/..", or current directory
* "foo/.". We need to normalize to a standard representation.
*/
function normalizePath(url, type$1) {
	const rel = type$1 <= UrlType.RelativePath;
	const pieces = url.path.split("/");
	let pointer = 1;
	let positive = 0;
	let addTrailingSlash = false;
	for (let i = 1; i < pieces.length; i++) {
		const piece = pieces[i];
		if (!piece) {
			addTrailingSlash = true;
			continue;
		}
		addTrailingSlash = false;
		if (piece === ".") continue;
		if (piece === "..") {
			if (positive) {
				addTrailingSlash = true;
				positive--;
				pointer--;
			} else if (rel) pieces[pointer++] = piece;
			continue;
		}
		pieces[pointer++] = piece;
		positive++;
	}
	let path = "";
	for (let i = 1; i < pointer; i++) path += "/" + pieces[i];
	if (!path || addTrailingSlash && !path.endsWith("/..")) path += "/";
	url.path = path;
}
/**
* Attempts to resolve `input` URL/path relative to `base`.
*/
function resolve$1(input, base) {
	if (!input && !base) return "";
	const url = parseUrl(input);
	let inputType = url.type;
	if (base && inputType !== UrlType.Absolute) {
		const baseUrl = parseUrl(base);
		const baseType = baseUrl.type;
		switch (inputType) {
			case UrlType.Empty: url.hash = baseUrl.hash;
			case UrlType.Hash: url.query = baseUrl.query;
			case UrlType.Query:
			case UrlType.RelativePath: mergePaths(url, baseUrl);
			case UrlType.AbsolutePath:
				url.user = baseUrl.user;
				url.host = baseUrl.host;
				url.port = baseUrl.port;
			case UrlType.SchemeRelative: url.scheme = baseUrl.scheme;
		}
		if (baseType > inputType) inputType = baseType;
	}
	normalizePath(url, inputType);
	const queryHash = url.query + url.hash;
	switch (inputType) {
		case UrlType.Hash:
		case UrlType.Query: return queryHash;
		case UrlType.RelativePath: {
			const path = url.path.slice(1);
			if (!path) return queryHash || ".";
			if (isRelative(base || input) && !isRelative(path)) return "./" + path + queryHash;
			return path + queryHash;
		}
		case UrlType.AbsolutePath: return url.path + queryHash;
		default: return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
	}
}
function resolve$2(input, base) {
	if (base && !base.endsWith("/")) base += "/";
	return resolve$1(input, base);
}
/**
* Removes everything after the last "/", but leaves the slash.
*/
function stripFilename(path) {
	if (!path) return "";
	const index = path.lastIndexOf("/");
	return path.slice(0, index + 1);
}
const COLUMN = 0;
const SOURCES_INDEX = 1;
const SOURCE_LINE = 2;
const SOURCE_COLUMN = 3;
const NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
	const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
	if (unsortedIndex === mappings.length) return mappings;
	if (!owned) mappings = mappings.slice();
	for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) mappings[i] = sortSegments(mappings[i], owned);
	return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
	for (let i = start; i < mappings.length; i++) if (!isSorted(mappings[i])) return i;
	return mappings.length;
}
function isSorted(line) {
	for (let j$1 = 1; j$1 < line.length; j$1++) if (line[j$1][COLUMN] < line[j$1 - 1][COLUMN]) return false;
	return true;
}
function sortSegments(line, owned) {
	if (!owned) line = line.slice();
	return line.sort(sortComparator);
}
function sortComparator(a$2, b$1) {
	return a$2[COLUMN] - b$1[COLUMN];
}
let found = false;
/**
* A binary search implementation that returns the index if a match is found.
* If no match is found, then the left-index (the index associated with the item that comes just
* before the desired index) is returned. To maintain proper sort order, a splice would happen at
* the next index:
*
* ```js
* const array = [1, 3];
* const needle = 2;
* const index = binarySearch(array, needle, (item, needle) => item - needle);
*
* assert.equal(index, 0);
* array.splice(index + 1, 0, needle);
* assert.deepEqual(array, [1, 2, 3]);
* ```
*/
function binarySearch(haystack, needle, low, high) {
	while (low <= high) {
		const mid = low + (high - low >> 1);
		const cmp = haystack[mid][COLUMN] - needle;
		if (cmp === 0) {
			found = true;
			return mid;
		}
		if (cmp < 0) low = mid + 1;
		else high = mid - 1;
	}
	found = false;
	return low - 1;
}
function upperBound(haystack, needle, index) {
	for (let i = index + 1; i < haystack.length; index = i++) if (haystack[i][COLUMN] !== needle) break;
	return index;
}
function lowerBound(haystack, needle, index) {
	for (let i = index - 1; i >= 0; index = i--) if (haystack[i][COLUMN] !== needle) break;
	return index;
}
function memoizedState() {
	return {
		lastKey: -1,
		lastNeedle: -1,
		lastIndex: -1
	};
}
/**
* This overly complicated beast is just to record the last tested line/column and the resulting
* index, allowing us to skip a few tests if mappings are monotonically increasing.
*/
function memoizedBinarySearch(haystack, needle, state, key) {
	const { lastKey, lastNeedle, lastIndex } = state;
	let low = 0;
	let high = haystack.length - 1;
	if (key === lastKey) {
		if (needle === lastNeedle) {
			found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
			return lastIndex;
		}
		if (needle >= lastNeedle) low = lastIndex === -1 ? 0 : lastIndex;
		else high = lastIndex;
	}
	state.lastKey = key;
	state.lastNeedle = needle;
	return state.lastIndex = binarySearch(haystack, needle, low, high);
}
const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
const LEAST_UPPER_BOUND = -1;
const GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
	constructor(map$1, mapUrl) {
		const isString = typeof map$1 === "string";
		if (!isString && map$1._decodedMemo) return map$1;
		const parsed = isString ? JSON.parse(map$1) : map$1;
		const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
		this.version = version;
		this.file = file;
		this.names = names || [];
		this.sourceRoot = sourceRoot;
		this.sources = sources;
		this.sourcesContent = sourcesContent;
		this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
		const from = resolve$2(sourceRoot || "", stripFilename(mapUrl));
		this.resolvedSources = sources.map((s) => resolve$2(s || "", from));
		const { mappings } = parsed;
		if (typeof mappings === "string") {
			this._encoded = mappings;
			this._decoded = void 0;
		} else {
			this._encoded = void 0;
			this._decoded = maybeSort(mappings, isString);
		}
		this._decodedMemo = memoizedState();
		this._bySources = void 0;
		this._bySourceMemos = void 0;
	}
};
/**
* Typescript doesn't allow friend access to private fields, so this just casts the map into a type
* with public access modifiers.
*/
function cast(map$1) {
	return map$1;
}
/**
* Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
*/
function decodedMappings(map$1) {
	var _a;
	return (_a = cast(map$1))._decoded || (_a._decoded = decode(cast(map$1)._encoded));
}
/**
* A higher-level API to find the source/line/column associated with a generated line/column
* (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
* `source-map` library.
*/
function originalPositionFor(map$1, needle) {
	let { line, column, bias } = needle;
	line--;
	if (line < 0) throw new Error(LINE_GTR_ZERO);
	if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
	const decoded = decodedMappings(map$1);
	if (line >= decoded.length) return OMapping(null, null, null, null);
	const segments = decoded[line];
	const index = traceSegmentInternal(segments, cast(map$1)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
	if (index === -1) return OMapping(null, null, null, null);
	const segment = segments[index];
	if (segment.length === 1) return OMapping(null, null, null, null);
	const { names, resolvedSources } = map$1;
	return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function OMapping(source, line, column, name) {
	return {
		source,
		line,
		column,
		name
	};
}
function traceSegmentInternal(segments, memo, line, column, bias) {
	let index = memoizedBinarySearch(segments, column, memo, line);
	if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
	else if (bias === LEAST_UPPER_BOUND) index++;
	if (index === -1 || index === segments.length) return -1;
	return index;
}
/**
* Get original stacktrace without source map support the most performant way.
* - Create only 1 stack frame.
* - Rewrite prepareStackTrace to bypass "support-stack-trace" (usually takes ~250ms).
*/
function notNullish(v$1) {
	return v$1 != null;
}
function isPrimitive(value) {
	return value === null || typeof value !== "function" && typeof value !== "object";
}
function isObject(item) {
	return item != null && typeof item === "object" && !Array.isArray(item);
}
/**
* If code starts with a function call, will return its last index, respecting arguments.
* This will return 25 - last ending character of toMatch ")"
* Also works with callbacks
* ```
* toMatch({ test: '123' });
* toBeAliased('123')
* ```
*/
function getCallLastIndex(code) {
	let charIndex = -1;
	let inString = null;
	let startedBracers = 0;
	let endedBracers = 0;
	let beforeChar = null;
	while (charIndex <= code.length) {
		beforeChar = code[charIndex];
		charIndex++;
		const char = code[charIndex];
		if ((char === "\"" || char === "'" || char === "`") && beforeChar !== "\\") {
			if (inString === char) inString = null;
			else if (!inString) inString = char;
		}
		if (!inString) {
			if (char === "(") startedBracers++;
			if (char === ")") endedBracers++;
		}
		if (startedBracers && endedBracers && startedBracers === endedBracers) return charIndex;
	}
	return null;
}
const CHROME_IE_STACK_REGEXP = /^\s*at .*(?:\S:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\[native code\])?$/;
const stackIgnorePatterns = [
	"node:internal",
	/\/packages\/\w+\/dist\//,
	/\/@vitest\/\w+\/dist\//,
	"/vitest/dist/",
	"/vitest/src/",
	"/vite-node/dist/",
	"/vite-node/src/",
	"/node_modules/chai/",
	"/node_modules/tinypool/",
	"/node_modules/tinyspy/",
	"/deps/chunk-",
	"/deps/@vitest",
	"/deps/loupe",
	"/deps/chai",
	/node:\w+/,
	/__vitest_test__/,
	/__vitest_browser__/,
	/\/deps\/vitest_/
];
function extractLocation(urlLike) {
	if (!urlLike.includes(":")) return [urlLike];
	const parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/^\(|\)$/g, ""));
	if (!parts) return [urlLike];
	let url = parts[1];
	if (url.startsWith("async ")) url = url.slice(6);
	if (url.startsWith("http:") || url.startsWith("https:")) {
		const urlObj = new URL(url);
		urlObj.searchParams.delete("import");
		urlObj.searchParams.delete("browserv");
		url = urlObj.pathname + urlObj.hash + urlObj.search;
	}
	if (url.startsWith("/@fs/")) {
		const isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
		url = url.slice(isWindows ? 5 : 4);
	}
	return [
		url,
		parts[2] || void 0,
		parts[3] || void 0
	];
}
function parseSingleFFOrSafariStack(raw) {
	let line = raw.trim();
	if (SAFARI_NATIVE_CODE_REGEXP.test(line)) return null;
	if (line.includes(" > eval")) line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
	if (!line.includes("@") && !line.includes(":")) return null;
	const functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/;
	const matches = line.match(functionNameRegex);
	const functionName$1 = matches && matches[1] ? matches[1] : void 0;
	const [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, ""));
	if (!url || !lineNumber || !columnNumber) return null;
	return {
		file: url,
		method: functionName$1 || "",
		line: Number.parseInt(lineNumber),
		column: Number.parseInt(columnNumber)
	};
}
function parseSingleV8Stack(raw) {
	let line = raw.trim();
	if (!CHROME_IE_STACK_REGEXP.test(line)) return null;
	if (line.includes("(eval ")) line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
	let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
	const location = sanitizedLine.match(/ (\(.+\)$)/);
	sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
	const [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);
	let method = location && sanitizedLine || "";
	let file = url && ["eval", "<anonymous>"].includes(url) ? void 0 : url;
	if (!file || !lineNumber || !columnNumber) return null;
	if (method.startsWith("async ")) method = method.slice(6);
	if (file.startsWith("file://")) file = file.slice(7);
	file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve(file);
	if (method) method = method.replace(/__vite_ssr_import_\d+__\./g, "");
	return {
		method,
		file,
		line: Number.parseInt(lineNumber),
		column: Number.parseInt(columnNumber)
	};
}
function parseStacktrace(stack, options = {}) {
	const { ignoreStackEntries = stackIgnorePatterns } = options;
	return (!CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack)).map((stack$1) => {
		var _options$getSourceMap;
		if (options.getUrlId) stack$1.file = options.getUrlId(stack$1.file);
		const map$1 = (_options$getSourceMap = options.getSourceMap) === null || _options$getSourceMap === void 0 ? void 0 : _options$getSourceMap.call(options, stack$1.file);
		if (!map$1 || typeof map$1 !== "object" || !map$1.version) return shouldFilter(ignoreStackEntries, stack$1.file) ? null : stack$1;
		const traceMap = new TraceMap(map$1);
		const { line, column, source, name } = originalPositionFor(traceMap, stack$1);
		let file = stack$1.file;
		if (source) {
			const fileUrl = stack$1.file.startsWith("file://") ? stack$1.file : `file://${stack$1.file}`;
			const sourceRootUrl = map$1.sourceRoot ? new URL(map$1.sourceRoot, fileUrl) : fileUrl;
			file = new URL(source, sourceRootUrl).pathname;
			if (file.match(/\/\w:\//)) file = file.slice(1);
		}
		if (shouldFilter(ignoreStackEntries, file)) return null;
		if (line != null && column != null) return {
			line,
			column,
			file,
			method: name || stack$1.method
		};
		return stack$1;
	}).filter((s) => s != null);
}
function shouldFilter(ignoreStackEntries, file) {
	return ignoreStackEntries.some((p$2) => file.match(p$2));
}
function parseFFOrSafariStackTrace(stack) {
	return stack.split("\n").map((line) => parseSingleFFOrSafariStack(line)).filter(notNullish);
}
function parseV8Stacktrace(stack) {
	return stack.split("\n").map((line) => parseSingleV8Stack(line)).filter(notNullish);
}
function parseErrorStacktrace(e, options = {}) {
	if (!e || isPrimitive(e)) return [];
	if (e.stacks) return e.stacks;
	const stackStr = e.stack || "";
	let stackFrames = typeof stackStr === "string" ? parseStacktrace(stackStr, options) : [];
	if (!stackFrames.length) {
		const e_ = e;
		if (e_.fileName != null && e_.lineNumber != null && e_.columnNumber != null) stackFrames = parseStacktrace(`${e_.fileName}:${e_.lineNumber}:${e_.columnNumber}`, options);
		if (e_.sourceURL != null && e_.line != null && e_._column != null) stackFrames = parseStacktrace(`${e_.sourceURL}:${e_.line}:${e_.column}`, options);
	}
	if (options.frameFilter) stackFrames = stackFrames.filter((f$3) => options.frameFilter(e, f$3) !== false);
	e.stacks = stackFrames;
	return stackFrames;
}
try {
	const { getPromiseDetails, kPending, kRejected } = process.binding("util");
	if (Array.isArray(getPromiseDetails(Promise.resolve()))) {}
} catch (notNode) {}
const { AsymmetricMatcher: AsymmetricMatcher$1, DOMCollection: DOMCollection$1, DOMElement: DOMElement$1, Immutable: Immutable$1, ReactElement: ReactElement$1, ReactTestComponent: ReactTestComponent$1 } = plugins;
function getDefaultExportFromCjs$1(x$1) {
	return x$1 && x$1.__esModule && Object.prototype.hasOwnProperty.call(x$1, "default") ? x$1["default"] : x$1;
}
var jsTokens_1;
var hasRequiredJsTokens;
function requireJsTokens() {
	if (hasRequiredJsTokens) return jsTokens_1;
	hasRequiredJsTokens = 1;
	var Identifier$1, JSXIdentifier$1, JSXPunctuator$1, JSXString$1, JSXText$1, KeywordsWithExpressionAfter$1, KeywordsWithNoLineTerminatorAfter$1, LineTerminatorSequence$1, MultiLineComment$1, Newline$1, NumericLiteral$1, Punctuator$1, RegularExpressionLiteral$1 = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy, SingleLineComment$1, StringLiteral$1, Template$1, TokensNotPrecedingObjectLiteral$1, TokensPrecedingExpression$1, WhiteSpace$1;
	Punctuator$1 = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
	Identifier$1 = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy;
	StringLiteral$1 = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y;
	NumericLiteral$1 = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
	Template$1 = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y;
	WhiteSpace$1 = /[\t\v\f\ufeff\p{Zs}]+/uy;
	LineTerminatorSequence$1 = /\r?\n|[\r\u2028\u2029]/y;
	MultiLineComment$1 = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y;
	SingleLineComment$1 = /\/\/.*/y;
	JSXPunctuator$1 = /[<>.:={}]|\/(?![\/*])/y;
	JSXIdentifier$1 = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy;
	JSXString$1 = /(['"])(?:(?!\1)[^])*(\1)?/y;
	JSXText$1 = /[^<>{}]+/y;
	TokensPrecedingExpression$1 = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
	TokensNotPrecedingObjectLiteral$1 = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
	KeywordsWithExpressionAfter$1 = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
	KeywordsWithNoLineTerminatorAfter$1 = /^(?:return|throw|yield)$/;
	Newline$1 = RegExp(LineTerminatorSequence$1.source);
	jsTokens_1 = function* (input, { jsx = false } = {}) {
		var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
		({length} = input);
		lastIndex = 0;
		lastSignificantToken = "";
		stack = [{ tag: "JS" }];
		braces = [];
		parenNesting = 0;
		postfixIncDec = false;
		while (lastIndex < length) {
			mode = stack[stack.length - 1];
			switch (mode.tag) {
				case "JS":
				case "JSNonExpressionParen":
				case "InterpolationInTemplate":
				case "InterpolationInJSX":
					if (input[lastIndex] === "/" && (TokensPrecedingExpression$1.test(lastSignificantToken) || KeywordsWithExpressionAfter$1.test(lastSignificantToken))) {
						RegularExpressionLiteral$1.lastIndex = lastIndex;
						if (match = RegularExpressionLiteral$1.exec(input)) {
							lastIndex = RegularExpressionLiteral$1.lastIndex;
							lastSignificantToken = match[0];
							postfixIncDec = true;
							yield {
								type: "RegularExpressionLiteral",
								value: match[0],
								closed: match[1] !== void 0 && match[1] !== "\\"
							};
							continue;
						}
					}
					Punctuator$1.lastIndex = lastIndex;
					if (match = Punctuator$1.exec(input)) {
						punctuator = match[0];
						nextLastIndex = Punctuator$1.lastIndex;
						nextLastSignificantToken = punctuator;
						switch (punctuator) {
							case "(":
								if (lastSignificantToken === "?NonExpressionParenKeyword") stack.push({
									tag: "JSNonExpressionParen",
									nesting: parenNesting
								});
								parenNesting++;
								postfixIncDec = false;
								break;
							case ")":
								parenNesting--;
								postfixIncDec = true;
								if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
									stack.pop();
									nextLastSignificantToken = "?NonExpressionParenEnd";
									postfixIncDec = false;
								}
								break;
							case "{":
								Punctuator$1.lastIndex = 0;
								isExpression = !TokensNotPrecedingObjectLiteral$1.test(lastSignificantToken) && (TokensPrecedingExpression$1.test(lastSignificantToken) || KeywordsWithExpressionAfter$1.test(lastSignificantToken));
								braces.push(isExpression);
								postfixIncDec = false;
								break;
							case "}":
								switch (mode.tag) {
									case "InterpolationInTemplate":
										if (braces.length === mode.nesting) {
											Template$1.lastIndex = lastIndex;
											match = Template$1.exec(input);
											lastIndex = Template$1.lastIndex;
											lastSignificantToken = match[0];
											if (match[1] === "${") {
												lastSignificantToken = "?InterpolationInTemplate";
												postfixIncDec = false;
												yield {
													type: "TemplateMiddle",
													value: match[0]
												};
											} else {
												stack.pop();
												postfixIncDec = true;
												yield {
													type: "TemplateTail",
													value: match[0],
													closed: match[1] === "`"
												};
											}
											continue;
										}
										break;
									case "InterpolationInJSX": if (braces.length === mode.nesting) {
										stack.pop();
										lastIndex += 1;
										lastSignificantToken = "}";
										yield {
											type: "JSXPunctuator",
											value: "}"
										};
										continue;
									}
								}
								postfixIncDec = braces.pop();
								nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
								break;
							case "]":
								postfixIncDec = true;
								break;
							case "++":
							case "--":
								nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
								break;
							case "<":
								if (jsx && (TokensPrecedingExpression$1.test(lastSignificantToken) || KeywordsWithExpressionAfter$1.test(lastSignificantToken))) {
									stack.push({ tag: "JSXTag" });
									lastIndex += 1;
									lastSignificantToken = "<";
									yield {
										type: "JSXPunctuator",
										value: punctuator
									};
									continue;
								}
								postfixIncDec = false;
								break;
							default: postfixIncDec = false;
						}
						lastIndex = nextLastIndex;
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "Punctuator",
							value: punctuator
						};
						continue;
					}
					Identifier$1.lastIndex = lastIndex;
					if (match = Identifier$1.exec(input)) {
						lastIndex = Identifier$1.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "for":
							case "if":
							case "while":
							case "with": if (lastSignificantToken !== "." && lastSignificantToken !== "?.") nextLastSignificantToken = "?NonExpressionParenKeyword";
						}
						lastSignificantToken = nextLastSignificantToken;
						postfixIncDec = !KeywordsWithExpressionAfter$1.test(match[0]);
						yield {
							type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
							value: match[0]
						};
						continue;
					}
					StringLiteral$1.lastIndex = lastIndex;
					if (match = StringLiteral$1.exec(input)) {
						lastIndex = StringLiteral$1.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "StringLiteral",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					NumericLiteral$1.lastIndex = lastIndex;
					if (match = NumericLiteral$1.exec(input)) {
						lastIndex = NumericLiteral$1.lastIndex;
						lastSignificantToken = match[0];
						postfixIncDec = true;
						yield {
							type: "NumericLiteral",
							value: match[0]
						};
						continue;
					}
					Template$1.lastIndex = lastIndex;
					if (match = Template$1.exec(input)) {
						lastIndex = Template$1.lastIndex;
						lastSignificantToken = match[0];
						if (match[1] === "${") {
							lastSignificantToken = "?InterpolationInTemplate";
							stack.push({
								tag: "InterpolationInTemplate",
								nesting: braces.length
							});
							postfixIncDec = false;
							yield {
								type: "TemplateHead",
								value: match[0]
							};
						} else {
							postfixIncDec = true;
							yield {
								type: "NoSubstitutionTemplate",
								value: match[0],
								closed: match[1] === "`"
							};
						}
						continue;
					}
					break;
				case "JSXTag":
				case "JSXTagEnd":
					JSXPunctuator$1.lastIndex = lastIndex;
					if (match = JSXPunctuator$1.exec(input)) {
						lastIndex = JSXPunctuator$1.lastIndex;
						nextLastSignificantToken = match[0];
						switch (match[0]) {
							case "<":
								stack.push({ tag: "JSXTag" });
								break;
							case ">":
								stack.pop();
								if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
									nextLastSignificantToken = "?JSX";
									postfixIncDec = true;
								} else stack.push({ tag: "JSXChildren" });
								break;
							case "{":
								stack.push({
									tag: "InterpolationInJSX",
									nesting: braces.length
								});
								nextLastSignificantToken = "?InterpolationInJSX";
								postfixIncDec = false;
								break;
							case "/": if (lastSignificantToken === "<") {
								stack.pop();
								if (stack[stack.length - 1].tag === "JSXChildren") stack.pop();
								stack.push({ tag: "JSXTagEnd" });
							}
						}
						lastSignificantToken = nextLastSignificantToken;
						yield {
							type: "JSXPunctuator",
							value: match[0]
						};
						continue;
					}
					JSXIdentifier$1.lastIndex = lastIndex;
					if (match = JSXIdentifier$1.exec(input)) {
						lastIndex = JSXIdentifier$1.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXIdentifier",
							value: match[0]
						};
						continue;
					}
					JSXString$1.lastIndex = lastIndex;
					if (match = JSXString$1.exec(input)) {
						lastIndex = JSXString$1.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXString",
							value: match[0],
							closed: match[2] !== void 0
						};
						continue;
					}
					break;
				case "JSXChildren":
					JSXText$1.lastIndex = lastIndex;
					if (match = JSXText$1.exec(input)) {
						lastIndex = JSXText$1.lastIndex;
						lastSignificantToken = match[0];
						yield {
							type: "JSXText",
							value: match[0]
						};
						continue;
					}
					switch (input[lastIndex]) {
						case "<":
							stack.push({ tag: "JSXTag" });
							lastIndex++;
							lastSignificantToken = "<";
							yield {
								type: "JSXPunctuator",
								value: "<"
							};
							continue;
						case "{":
							stack.push({
								tag: "InterpolationInJSX",
								nesting: braces.length
							});
							lastIndex++;
							lastSignificantToken = "?InterpolationInJSX";
							postfixIncDec = false;
							yield {
								type: "JSXPunctuator",
								value: "{"
							};
							continue;
					}
			}
			WhiteSpace$1.lastIndex = lastIndex;
			if (match = WhiteSpace$1.exec(input)) {
				lastIndex = WhiteSpace$1.lastIndex;
				yield {
					type: "WhiteSpace",
					value: match[0]
				};
				continue;
			}
			LineTerminatorSequence$1.lastIndex = lastIndex;
			if (match = LineTerminatorSequence$1.exec(input)) {
				lastIndex = LineTerminatorSequence$1.lastIndex;
				postfixIncDec = false;
				if (KeywordsWithNoLineTerminatorAfter$1.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				yield {
					type: "LineTerminatorSequence",
					value: match[0]
				};
				continue;
			}
			MultiLineComment$1.lastIndex = lastIndex;
			if (match = MultiLineComment$1.exec(input)) {
				lastIndex = MultiLineComment$1.lastIndex;
				if (Newline$1.test(match[0])) {
					postfixIncDec = false;
					if (KeywordsWithNoLineTerminatorAfter$1.test(lastSignificantToken)) lastSignificantToken = "?NoLineTerminatorHere";
				}
				yield {
					type: "MultiLineComment",
					value: match[0],
					closed: match[1] !== void 0
				};
				continue;
			}
			SingleLineComment$1.lastIndex = lastIndex;
			if (match = SingleLineComment$1.exec(input)) {
				lastIndex = SingleLineComment$1.lastIndex;
				postfixIncDec = false;
				yield {
					type: "SingleLineComment",
					value: match[0]
				};
				continue;
			}
			firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
			lastIndex += firstCodePoint.length;
			lastSignificantToken = firstCodePoint;
			postfixIncDec = false;
			yield {
				type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
				value: firstCodePoint
			};
		}
	};
	return jsTokens_1;
}
requireJsTokens();
var reservedWords = {
	keyword: [
		"break",
		"case",
		"catch",
		"continue",
		"debugger",
		"default",
		"do",
		"else",
		"finally",
		"for",
		"function",
		"if",
		"return",
		"switch",
		"throw",
		"try",
		"var",
		"const",
		"while",
		"with",
		"new",
		"this",
		"super",
		"class",
		"extends",
		"export",
		"import",
		"null",
		"true",
		"false",
		"in",
		"instanceof",
		"typeof",
		"void",
		"delete"
	],
	strict: [
		"implements",
		"interface",
		"let",
		"package",
		"private",
		"protected",
		"public",
		"static",
		"yield"
	]
};
new Set(reservedWords.keyword);
new Set(reservedWords.strict);
var f = {
	reset: [0, 0],
	bold: [
		1,
		22,
		"\x1B[22m\x1B[1m"
	],
	dim: [
		2,
		22,
		"\x1B[22m\x1B[2m"
	],
	italic: [3, 23],
	underline: [4, 24],
	inverse: [7, 27],
	hidden: [8, 28],
	strikethrough: [9, 29],
	black: [30, 39],
	red: [31, 39],
	green: [32, 39],
	yellow: [33, 39],
	blue: [34, 39],
	magenta: [35, 39],
	cyan: [36, 39],
	white: [37, 39],
	gray: [90, 39],
	bgBlack: [40, 49],
	bgRed: [41, 49],
	bgGreen: [42, 49],
	bgYellow: [43, 49],
	bgBlue: [44, 49],
	bgMagenta: [45, 49],
	bgCyan: [46, 49],
	bgWhite: [47, 49],
	blackBright: [90, 39],
	redBright: [91, 39],
	greenBright: [92, 39],
	yellowBright: [93, 39],
	blueBright: [94, 39],
	magentaBright: [95, 39],
	cyanBright: [96, 39],
	whiteBright: [97, 39],
	bgBlackBright: [100, 49],
	bgRedBright: [101, 49],
	bgGreenBright: [102, 49],
	bgYellowBright: [103, 49],
	bgBlueBright: [104, 49],
	bgMagentaBright: [105, 49],
	bgCyanBright: [106, 49],
	bgWhiteBright: [107, 49]
}, h = Object.entries(f);
function a(n) {
	return String(n);
}
a.open = "";
a.close = "";
function C(n = false) {
	let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
	return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p(n = false) {
	let e = C(n), i = (r$1, t, c, o) => {
		let l$1 = "", s = 0;
		do
			l$1 += r$1.substring(s, o) + c, s = o + t.length, o = r$1.indexOf(t, s);
		while (~o);
		return l$1 + r$1.substring(s);
	}, g = (r$1, t, c = r$1) => {
		let o = (l$1) => {
			let s = String(l$1), b$1 = s.indexOf(t, r$1.length);
			return ~b$1 ? r$1 + i(s, t, c, b$1) + t : r$1 + s + t;
		};
		return o.open = r$1, o.close = t, o;
	}, u$2 = { isColorSupported: e }, d = (r$1) => `\x1B[${r$1}m`;
	for (let [r$1, t] of h) u$2[r$1] = e ? g(d(t[0]), d(t[1]), t[2]) : a;
	return u$2;
}
p();
const lineSplitRE = /\r?\n/;
function positionToOffset(source, lineNumber, columnNumber) {
	const lines = source.split(lineSplitRE);
	const nl = /\r\n/.test(source) ? 2 : 1;
	let start = 0;
	if (lineNumber > lines.length) return source.length;
	for (let i = 0; i < lineNumber - 1; i++) start += lines[i].length + nl;
	return start + columnNumber;
}
function offsetToLineNumber(source, offset) {
	if (offset > source.length) throw new Error(`offset is longer than source length! offset ${offset} > length ${source.length}`);
	const lines = source.split(lineSplitRE);
	const nl = /\r\n/.test(source) ? 2 : 1;
	let counted = 0;
	let line = 0;
	for (; line < lines.length; line++) {
		const lineLength = lines[line].length + nl;
		if (counted + lineLength >= offset) break;
		counted += lineLength;
	}
	return line + 1;
}
async function saveInlineSnapshots(environment, snapshots) {
	const MagicString = (await import("./magic-string.es-Dde5ItI4.js")).default;
	const files = new Set(snapshots.map((i) => i.file));
	await Promise.all(Array.from(files).map(async (file) => {
		const snaps = snapshots.filter((i) => i.file === file);
		const code = await environment.readSnapshotFile(file);
		const s = new MagicString(code);
		for (const snap of snaps) {
			const index = positionToOffset(code, snap.line, snap.column);
			replaceInlineSnap(code, s, index, snap.snapshot);
		}
		const transformed = s.toString();
		if (transformed !== code) await environment.saveSnapshotFile(file, transformed);
	}));
}
const startObjectRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*\{/;
function replaceObjectSnap(code, s, index, newSnap) {
	let _code = code.slice(index);
	const startMatch = startObjectRegex.exec(_code);
	if (!startMatch) return false;
	_code = _code.slice(startMatch.index);
	let callEnd = getCallLastIndex(_code);
	if (callEnd === null) return false;
	callEnd += index + startMatch.index;
	const shapeStart = index + startMatch.index + startMatch[0].length;
	const shapeEnd = getObjectShapeEndIndex(code, shapeStart);
	const snap = `, ${prepareSnapString(newSnap, code, index)}`;
	if (shapeEnd === callEnd) s.appendLeft(callEnd, snap);
	else s.overwrite(shapeEnd, callEnd, snap);
	return true;
}
function getObjectShapeEndIndex(code, index) {
	let startBraces = 1;
	let endBraces = 0;
	while (startBraces !== endBraces && index < code.length) {
		const s = code[index++];
		if (s === "{") startBraces++;
		else if (s === "}") endBraces++;
	}
	return index;
}
function prepareSnapString(snap, source, index) {
	const lineNumber = offsetToLineNumber(source, index);
	const indent = source.split(lineSplitRE)[lineNumber - 1].match(/^\s*/)[0] || "";
	const indentNext = indent.includes("	") ? `${indent}\t` : `${indent}  `;
	const lines = snap.trim().replace(/\\/g, "\\\\").split(/\n/g);
	const isOneline = lines.length <= 1;
	const quote = "`";
	if (isOneline) return `${quote}${lines.join("\n").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")}${quote}`;
	return `${quote}\n${lines.map((i) => i ? indentNext + i : "").join("\n").replace(/`/g, "\\`").replace(/\$\{/g, "\\${")}\n${indent}${quote}`;
}
const toMatchInlineName = "toMatchInlineSnapshot";
const toThrowErrorMatchingInlineName = "toThrowErrorMatchingInlineSnapshot";
function getCodeStartingAtIndex(code, index) {
	const indexInline = index - 21;
	if (code.slice(indexInline, index) === toMatchInlineName) return {
		code: code.slice(indexInline),
		index: indexInline
	};
	const indexThrowInline = index - 34;
	if (code.slice(index - indexThrowInline, index) === toThrowErrorMatchingInlineName) return {
		code: code.slice(index - indexThrowInline),
		index: index - indexThrowInline
	};
	return {
		code: code.slice(index),
		index
	};
}
const startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*[\w$]*(['"`)])/;
function replaceInlineSnap(code, s, currentIndex, newSnap) {
	const { code: codeStartingAtIndex, index } = getCodeStartingAtIndex(code, currentIndex);
	const startMatch = startRegex.exec(codeStartingAtIndex);
	const firstKeywordMatch = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);
	if (!startMatch || startMatch.index !== (firstKeywordMatch === null || firstKeywordMatch === void 0 ? void 0 : firstKeywordMatch.index)) return replaceObjectSnap(code, s, index, newSnap);
	const quote = startMatch[1];
	const startIndex = index + startMatch.index + startMatch[0].length;
	const snapString = prepareSnapString(newSnap, code, index);
	if (quote === ")") {
		s.appendRight(startIndex - 1, snapString);
		return true;
	}
	const endMatch = (/* @__PURE__ */ new RegExp(`(?:^|[^\\\\])${quote}`)).exec(code.slice(startIndex));
	if (!endMatch) return false;
	const endIndex = startIndex + endMatch.index + endMatch[0].length;
	s.overwrite(startIndex - 1, endIndex, snapString);
	return true;
}
const INDENTATION_REGEX = /^([^\S\n]*)\S/m;
function stripSnapshotIndentation(inlineSnapshot) {
	const match = inlineSnapshot.match(INDENTATION_REGEX);
	if (!match || !match[1]) return inlineSnapshot;
	const indentation = match[1];
	const lines = inlineSnapshot.split(/\n/g);
	if (lines.length <= 2) return inlineSnapshot;
	if (lines[0].trim() !== "" || lines[lines.length - 1].trim() !== "") return inlineSnapshot;
	for (let i = 1; i < lines.length - 1; i++) if (lines[i] !== "") {
		if (lines[i].indexOf(indentation) !== 0) return inlineSnapshot;
		lines[i] = lines[i].substring(indentation.length);
	}
	lines[lines.length - 1] = "";
	inlineSnapshot = lines.join("\n");
	return inlineSnapshot;
}
async function saveRawSnapshots(environment, snapshots) {
	await Promise.all(snapshots.map(async (snap) => {
		if (!snap.readonly) await environment.saveSnapshotFile(snap.file, snap.snapshot);
	}));
}
var naturalCompare$1 = { exports: {} };
var hasRequiredNaturalCompare;
function requireNaturalCompare() {
	if (hasRequiredNaturalCompare) return naturalCompare$1.exports;
	hasRequiredNaturalCompare = 1;
	/*
	* @version    1.4.0
	* @date       2015-10-26
	* @stability  3 - Stable
	* @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
	* @license    MIT License
	*/
	var naturalCompare$2 = function(a$2, b$1) {
		var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
		function getCode(str, pos, code) {
			if (code) {
				for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
				return +str.slice(pos - 1, i);
			}
			code = alphabet && alphabet.indexOf(str.charAt(pos));
			return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
		}
		if ((a$2 += "") != (b$1 += "")) for (; codeB;) {
			codeA = getCode(a$2, posA++);
			codeB = getCode(b$1, posB++);
			if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
				codeA = getCode(a$2, posA, posA);
				codeB = getCode(b$1, posB, posA = i);
				posB = i;
			}
			if (codeA != codeB) return codeA < codeB ? -1 : 1;
		}
		return 0;
	};
	try {
		naturalCompare$1.exports = naturalCompare$2;
	} catch (e) {
		String.naturalCompare = naturalCompare$2;
	}
	return naturalCompare$1.exports;
}
var naturalCompareExports = requireNaturalCompare();
var naturalCompare = /* @__PURE__ */ getDefaultExportFromCjs$1(naturalCompareExports);
const serialize$1 = (val, config$1, indentation, depth, refs, printer$1) => {
	const name = val.getMockName();
	const nameString = name === "vi.fn()" ? "" : ` ${name}`;
	let callsString = "";
	if (val.mock.calls.length !== 0) {
		const indentationNext = indentation + config$1.indent;
		callsString = ` {${config$1.spacingOuter}${indentationNext}"calls": ${printer$1(val.mock.calls, config$1, indentationNext, depth, refs)}${config$1.min ? ", " : ","}${config$1.spacingOuter}${indentationNext}"results": ${printer$1(val.mock.results, config$1, indentationNext, depth, refs)}${config$1.min ? "" : ","}${config$1.spacingOuter}${indentation}}`;
	}
	return `[MockFunction${nameString}]${callsString}`;
};
const test = (val) => val && !!val._isMockFunction;
const plugin = {
	serialize: serialize$1,
	test
};
const { DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent, AsymmetricMatcher } = plugins;
let PLUGINS = [
	ReactTestComponent,
	ReactElement,
	DOMElement,
	DOMCollection,
	Immutable,
	AsymmetricMatcher,
	plugin
];
function addSerializer(plugin$7) {
	PLUGINS = [plugin$7].concat(PLUGINS);
}
function getSerializers() {
	return PLUGINS;
}
function testNameToKey(testName$1, count) {
	return `${testName$1} ${count}`;
}
function keyToTestName(key) {
	if (!/ \d+$/.test(key)) throw new Error("Snapshot keys must end with a number.");
	return key.replace(/ \d+$/, "");
}
function getSnapshotData(content, options) {
	const update = options.updateSnapshot;
	const data = Object.create(null);
	let snapshotContents = "";
	let dirty = false;
	if (content != null) try {
		snapshotContents = content;
		new Function("exports", snapshotContents)(data);
	} catch {}
	if ((update === "all" || update === "new") && snapshotContents) dirty = true;
	return {
		data,
		dirty
	};
}
function addExtraLineBreaks(string$1) {
	return string$1.includes("\n") ? `\n${string$1}\n` : string$1;
}
function removeExtraLineBreaks(string$1) {
	return string$1.length > 2 && string$1.startsWith("\n") && string$1.endsWith("\n") ? string$1.slice(1, -1) : string$1;
}
const escapeRegex = true;
const printFunctionName = false;
function serialize(val, indent = 2, formatOverrides = {}) {
	return normalizeNewlines(format(val, {
		escapeRegex,
		indent,
		plugins: getSerializers(),
		printFunctionName,
		...formatOverrides
	}));
}
function escapeBacktickString(str) {
	return str.replace(/`|\\|\$\{/g, "\\$&");
}
function printBacktickString(str) {
	return `\`${escapeBacktickString(str)}\``;
}
function normalizeNewlines(string$1) {
	return string$1.replace(/\r\n|\r/g, "\n");
}
async function saveSnapshotFile(environment, snapshotData, snapshotPath) {
	const snapshots = Object.keys(snapshotData).sort(naturalCompare).map((key) => `exports[${printBacktickString(key)}] = ${printBacktickString(normalizeNewlines(snapshotData[key]))};`);
	const content = `${environment.getHeader()}\n\n${snapshots.join("\n\n")}\n`;
	const oldContent = await environment.readSnapshotFile(snapshotPath);
	if (oldContent != null && oldContent === content) return;
	await environment.saveSnapshotFile(snapshotPath, content);
}
function deepMergeArray(target = [], source = []) {
	const mergedOutput = Array.from(target);
	source.forEach((sourceElement, index) => {
		const targetElement = mergedOutput[index];
		if (Array.isArray(target[index])) mergedOutput[index] = deepMergeArray(target[index], sourceElement);
		else if (isObject(targetElement)) mergedOutput[index] = deepMergeSnapshot(target[index], sourceElement);
		else mergedOutput[index] = sourceElement;
	});
	return mergedOutput;
}
/**
* Deep merge, but considers asymmetric matchers. Unlike base util's deep merge,
* will merge any object-like instance.
* Compatible with Jest's snapshot matcher. Should not be used outside of snapshot.
*
* @example
* ```ts
* toMatchSnapshot({
*   name: expect.stringContaining('text')
* })
* ```
*/
function deepMergeSnapshot(target, source) {
	if (isObject(target) && isObject(source)) {
		const mergedOutput = { ...target };
		Object.keys(source).forEach((key) => {
			if (isObject(source[key]) && !source[key].$$typeof) if (!(key in target)) Object.assign(mergedOutput, { [key]: source[key] });
			else mergedOutput[key] = deepMergeSnapshot(target[key], source[key]);
			else if (Array.isArray(source[key])) mergedOutput[key] = deepMergeArray(target[key], source[key]);
			else Object.assign(mergedOutput, { [key]: source[key] });
		});
		return mergedOutput;
	} else if (Array.isArray(target) && Array.isArray(source)) return deepMergeArray(target, source);
	return target;
}
var DefaultMap = class extends Map {
	constructor(defaultFn, entries) {
		super(entries);
		this.defaultFn = defaultFn;
	}
	get(key) {
		if (!this.has(key)) this.set(key, this.defaultFn(key));
		return super.get(key);
	}
};
var CounterMap = class extends DefaultMap {
	constructor() {
		super(() => 0);
	}
	_total;
	valueOf() {
		return this._total = this.total();
	}
	increment(key) {
		if (typeof this._total !== "undefined") this._total++;
		this.set(key, this.get(key) + 1);
	}
	total() {
		if (typeof this._total !== "undefined") return this._total;
		let total = 0;
		for (const x$1 of this.values()) total += x$1;
		return total;
	}
};
function isSameStackPosition(x$1, y$1) {
	return x$1.file === y$1.file && x$1.column === y$1.column && x$1.line === y$1.line;
}
var SnapshotState = class SnapshotState {
	_counters = new CounterMap();
	_dirty;
	_updateSnapshot;
	_snapshotData;
	_initialData;
	_inlineSnapshots;
	_inlineSnapshotStacks;
	_testIdToKeys = new DefaultMap(() => []);
	_rawSnapshots;
	_uncheckedKeys;
	_snapshotFormat;
	_environment;
	_fileExists;
	expand;
	_added = new CounterMap();
	_matched = new CounterMap();
	_unmatched = new CounterMap();
	_updated = new CounterMap();
	get added() {
		return this._added;
	}
	set added(value) {
		this._added._total = value;
	}
	get matched() {
		return this._matched;
	}
	set matched(value) {
		this._matched._total = value;
	}
	get unmatched() {
		return this._unmatched;
	}
	set unmatched(value) {
		this._unmatched._total = value;
	}
	get updated() {
		return this._updated;
	}
	set updated(value) {
		this._updated._total = value;
	}
	constructor(testFilePath, snapshotPath, snapshotContent, options) {
		this.testFilePath = testFilePath;
		this.snapshotPath = snapshotPath;
		const { data, dirty } = getSnapshotData(snapshotContent, options);
		this._fileExists = snapshotContent != null;
		this._initialData = { ...data };
		this._snapshotData = { ...data };
		this._dirty = dirty;
		this._inlineSnapshots = [];
		this._inlineSnapshotStacks = [];
		this._rawSnapshots = [];
		this._uncheckedKeys = new Set(Object.keys(this._snapshotData));
		this.expand = options.expand || false;
		this._updateSnapshot = options.updateSnapshot;
		this._snapshotFormat = {
			printBasicPrototype: false,
			escapeString: false,
			...options.snapshotFormat
		};
		this._environment = options.snapshotEnvironment;
	}
	static async create(testFilePath, options) {
		const snapshotPath = await options.snapshotEnvironment.resolvePath(testFilePath);
		const content = await options.snapshotEnvironment.readSnapshotFile(snapshotPath);
		return new SnapshotState(testFilePath, snapshotPath, content, options);
	}
	get environment() {
		return this._environment;
	}
	markSnapshotsAsCheckedForTest(testName$1) {
		this._uncheckedKeys.forEach((uncheckedKey) => {
			if (/ \d+$| > /.test(uncheckedKey.slice(testName$1.length))) this._uncheckedKeys.delete(uncheckedKey);
		});
	}
	clearTest(testId) {
		this._inlineSnapshots = this._inlineSnapshots.filter((s) => s.testId !== testId);
		this._inlineSnapshotStacks = this._inlineSnapshotStacks.filter((s) => s.testId !== testId);
		for (const key of this._testIdToKeys.get(testId)) {
			const name = keyToTestName(key);
			const count = this._counters.get(name);
			if (count > 0) {
				if (key in this._snapshotData || key in this._initialData) this._snapshotData[key] = this._initialData[key];
				this._counters.set(name, count - 1);
			}
		}
		this._testIdToKeys.delete(testId);
		this.added.delete(testId);
		this.updated.delete(testId);
		this.matched.delete(testId);
		this.unmatched.delete(testId);
	}
	_inferInlineSnapshotStack(stacks) {
		const promiseIndex = stacks.findIndex((i) => i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));
		if (promiseIndex !== -1) return stacks[promiseIndex + 3];
		const stackIndex = stacks.findIndex((i) => i.method.includes("__INLINE_SNAPSHOT__"));
		return stackIndex !== -1 ? stacks[stackIndex + 2] : null;
	}
	_addSnapshot(key, receivedSerialized, options) {
		this._dirty = true;
		if (options.stack) this._inlineSnapshots.push({
			snapshot: receivedSerialized,
			testId: options.testId,
			...options.stack
		});
		else if (options.rawSnapshot) this._rawSnapshots.push({
			...options.rawSnapshot,
			snapshot: receivedSerialized
		});
		else this._snapshotData[key] = receivedSerialized;
	}
	async save() {
		const hasExternalSnapshots = Object.keys(this._snapshotData).length;
		const hasInlineSnapshots = this._inlineSnapshots.length;
		const hasRawSnapshots = this._rawSnapshots.length;
		const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots && !hasRawSnapshots;
		const status = {
			deleted: false,
			saved: false
		};
		if ((this._dirty || this._uncheckedKeys.size) && !isEmpty) {
			if (hasExternalSnapshots) {
				await saveSnapshotFile(this._environment, this._snapshotData, this.snapshotPath);
				this._fileExists = true;
			}
			if (hasInlineSnapshots) await saveInlineSnapshots(this._environment, this._inlineSnapshots);
			if (hasRawSnapshots) await saveRawSnapshots(this._environment, this._rawSnapshots);
			status.saved = true;
		} else if (!hasExternalSnapshots && this._fileExists) {
			if (this._updateSnapshot === "all") {
				await this._environment.removeSnapshotFile(this.snapshotPath);
				this._fileExists = false;
			}
			status.deleted = true;
		}
		return status;
	}
	getUncheckedCount() {
		return this._uncheckedKeys.size || 0;
	}
	getUncheckedKeys() {
		return Array.from(this._uncheckedKeys);
	}
	removeUncheckedKeys() {
		if (this._updateSnapshot === "all" && this._uncheckedKeys.size) {
			this._dirty = true;
			this._uncheckedKeys.forEach((key) => delete this._snapshotData[key]);
			this._uncheckedKeys.clear();
		}
	}
	match({ testId, testName: testName$1, received, key, inlineSnapshot, isInline, error, rawSnapshot }) {
		this._counters.increment(testName$1);
		const count = this._counters.get(testName$1);
		if (!key) key = testNameToKey(testName$1, count);
		this._testIdToKeys.get(testId).push(key);
		if (!(isInline && this._snapshotData[key] !== void 0)) this._uncheckedKeys.delete(key);
		let receivedSerialized = rawSnapshot && typeof received === "string" ? received : serialize(received, void 0, this._snapshotFormat);
		if (!rawSnapshot) receivedSerialized = addExtraLineBreaks(receivedSerialized);
		if (rawSnapshot) {
			if (rawSnapshot.content && rawSnapshot.content.match(/\r\n/) && !receivedSerialized.match(/\r\n/)) rawSnapshot.content = normalizeNewlines(rawSnapshot.content);
		}
		const expected = isInline ? inlineSnapshot : rawSnapshot ? rawSnapshot.content : this._snapshotData[key];
		const expectedTrimmed = rawSnapshot ? expected : expected === null || expected === void 0 ? void 0 : expected.trim();
		const pass = expectedTrimmed === (rawSnapshot ? receivedSerialized : receivedSerialized.trim());
		const hasSnapshot = expected !== void 0;
		const snapshotIsPersisted = isInline || this._fileExists || rawSnapshot && rawSnapshot.content != null;
		if (pass && !isInline && !rawSnapshot) this._snapshotData[key] = receivedSerialized;
		let stack;
		if (isInline) {
			var _this$environment$pro, _this$environment;
			const stacks = parseErrorStacktrace(error || /* @__PURE__ */ new Error("snapshot"), { ignoreStackEntries: [] });
			const _stack = this._inferInlineSnapshotStack(stacks);
			if (!_stack) throw new Error(`@vitest/snapshot: Couldn't infer stack frame for inline snapshot.\n${JSON.stringify(stacks)}`);
			stack = ((_this$environment$pro = (_this$environment = this.environment).processStackTrace) === null || _this$environment$pro === void 0 ? void 0 : _this$environment$pro.call(_this$environment, _stack)) || _stack;
			stack.column--;
			const snapshotsWithSameStack = this._inlineSnapshotStacks.filter((s) => isSameStackPosition(s, stack));
			if (snapshotsWithSameStack.length > 0) {
				this._inlineSnapshots = this._inlineSnapshots.filter((s) => !isSameStackPosition(s, stack));
				const differentSnapshot = snapshotsWithSameStack.find((s) => s.snapshot !== receivedSerialized);
				if (differentSnapshot) throw Object.assign(/* @__PURE__ */ new Error("toMatchInlineSnapshot with different snapshots cannot be called at the same location"), {
					actual: receivedSerialized,
					expected: differentSnapshot.snapshot
				});
			}
			this._inlineSnapshotStacks.push({
				...stack,
				testId,
				snapshot: receivedSerialized
			});
		}
		if (hasSnapshot && this._updateSnapshot === "all" || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === "new" || this._updateSnapshot === "all")) {
			if (this._updateSnapshot === "all") if (!pass) {
				if (hasSnapshot) this.updated.increment(testId);
				else this.added.increment(testId);
				this._addSnapshot(key, receivedSerialized, {
					stack,
					testId,
					rawSnapshot
				});
			} else this.matched.increment(testId);
			else {
				this._addSnapshot(key, receivedSerialized, {
					stack,
					testId,
					rawSnapshot
				});
				this.added.increment(testId);
			}
			return {
				actual: "",
				count,
				expected: "",
				key,
				pass: true
			};
		} else if (!pass) {
			this.unmatched.increment(testId);
			return {
				actual: rawSnapshot ? receivedSerialized : removeExtraLineBreaks(receivedSerialized),
				count,
				expected: expectedTrimmed !== void 0 ? rawSnapshot ? expectedTrimmed : removeExtraLineBreaks(expectedTrimmed) : void 0,
				key,
				pass: false
			};
		} else {
			this.matched.increment(testId);
			return {
				actual: "",
				count,
				expected: "",
				key,
				pass: true
			};
		}
	}
	async pack() {
		const snapshot = {
			filepath: this.testFilePath,
			added: 0,
			fileDeleted: false,
			matched: 0,
			unchecked: 0,
			uncheckedKeys: [],
			unmatched: 0,
			updated: 0
		};
		const uncheckedCount = this.getUncheckedCount();
		const uncheckedKeys = this.getUncheckedKeys();
		if (uncheckedCount) this.removeUncheckedKeys();
		const status = await this.save();
		snapshot.fileDeleted = status.deleted;
		snapshot.added = this.added.total();
		snapshot.matched = this.matched.total();
		snapshot.unmatched = this.unmatched.total();
		snapshot.updated = this.updated.total();
		snapshot.unchecked = !status.deleted ? uncheckedCount : 0;
		snapshot.uncheckedKeys = Array.from(uncheckedKeys);
		return snapshot;
	}
};
function createMismatchError(message, expand, actual, expected) {
	const error = new Error(message);
	Object.defineProperty(error, "actual", {
		value: actual,
		enumerable: true,
		configurable: true,
		writable: true
	});
	Object.defineProperty(error, "expected", {
		value: expected,
		enumerable: true,
		configurable: true,
		writable: true
	});
	Object.defineProperty(error, "diffOptions", { value: { expand } });
	return error;
}
var SnapshotClient = class {
	snapshotStateMap = /* @__PURE__ */ new Map();
	constructor(options = {}) {
		this.options = options;
	}
	async setup(filepath, options) {
		if (this.snapshotStateMap.has(filepath)) return;
		this.snapshotStateMap.set(filepath, await SnapshotState.create(filepath, options));
	}
	async finish(filepath) {
		const result = await this.getSnapshotState(filepath).pack();
		this.snapshotStateMap.delete(filepath);
		return result;
	}
	skipTest(filepath, testName$1) {
		this.getSnapshotState(filepath).markSnapshotsAsCheckedForTest(testName$1);
	}
	clearTest(filepath, testId) {
		this.getSnapshotState(filepath).clearTest(testId);
	}
	getSnapshotState(filepath) {
		const state = this.snapshotStateMap.get(filepath);
		if (!state) throw new Error(`The snapshot state for '${filepath}' is not found. Did you call 'SnapshotClient.setup()'?`);
		return state;
	}
	assert(options) {
		const { filepath, name, testId = name, message, isInline = false, properties, inlineSnapshot, error, errorMessage, rawSnapshot } = options;
		let { received } = options;
		if (!filepath) throw new Error("Snapshot cannot be used outside of test");
		const snapshotState = this.getSnapshotState(filepath);
		if (typeof properties === "object") {
			if (typeof received !== "object" || !received) throw new Error("Received value must be an object when the matcher has properties");
			try {
				var _this$options$isEqual, _this$options;
				if (!(((_this$options$isEqual = (_this$options = this.options).isEqual) === null || _this$options$isEqual === void 0 ? void 0 : _this$options$isEqual.call(_this$options, received, properties)) ?? false)) throw createMismatchError("Snapshot properties mismatched", snapshotState.expand, received, properties);
				else received = deepMergeSnapshot(received, properties);
			} catch (err) {
				err.message = errorMessage || "Snapshot mismatched";
				throw err;
			}
		}
		const testName$1 = [name, ...message ? [message] : []].join(" > ");
		const { actual, expected, key, pass } = snapshotState.match({
			testId,
			testName: testName$1,
			received,
			isInline,
			error,
			inlineSnapshot,
			rawSnapshot
		});
		if (!pass) throw createMismatchError(`Snapshot \`${key || "unknown"}\` mismatched`, snapshotState.expand, rawSnapshot ? actual : actual === null || actual === void 0 ? void 0 : actual.trim(), rawSnapshot ? expected : expected === null || expected === void 0 ? void 0 : expected.trim());
	}
	async assertRaw(options) {
		if (!options.rawSnapshot) throw new Error("Raw snapshot is required");
		const { filepath, rawSnapshot } = options;
		if (rawSnapshot.content == null) {
			if (!filepath) throw new Error("Snapshot cannot be used outside of test");
			const snapshotState = this.getSnapshotState(filepath);
			options.filepath || (options.filepath = filepath);
			rawSnapshot.file = await snapshotState.environment.resolveRawPath(filepath, rawSnapshot.file);
			rawSnapshot.content = await snapshotState.environment.readSnapshotFile(rawSnapshot.file) ?? void 0;
		}
		return this.assert(options);
	}
	clear() {
		this.snapshotStateMap.clear();
	}
};

//#endregion
//#region node_modules/.pnpm/vitest@3.2.4_@types+node@24.5.2/node_modules/vitest/dist/chunks/date.Bq6ZW5rf.js
const RealDate = Date;
let now = null;
var MockDate = class MockDate extends RealDate {
	constructor(y$1, m$1, d, h$3, M$1, s, ms) {
		super();
		let date;
		switch (arguments.length) {
			case 0:
				if (now !== null) date = new RealDate(now.valueOf());
				else date = new RealDate();
				break;
			case 1:
				date = new RealDate(y$1);
				break;
			default:
				d = typeof d === "undefined" ? 1 : d;
				h$3 = h$3 || 0;
				M$1 = M$1 || 0;
				s = s || 0;
				ms = ms || 0;
				date = new RealDate(y$1, m$1, d, h$3, M$1, s, ms);
				break;
		}
		Object.setPrototypeOf(date, MockDate.prototype);
		return date;
	}
};
MockDate.UTC = RealDate.UTC;
MockDate.now = function() {
	return new MockDate().valueOf();
};
MockDate.parse = function(dateString) {
	return RealDate.parse(dateString);
};
MockDate.toString = function() {
	return RealDate.toString();
};
function mockDate(date) {
	const dateObj = new RealDate(date.valueOf());
	if (Number.isNaN(dateObj.getTime())) throw new TypeError(`mockdate: The time set is an invalid date: ${date}`);
	globalThis.Date = MockDate;
	now = dateObj.valueOf();
}
function resetDate() {
	globalThis.Date = RealDate;
}

//#endregion
//#region node_modules/.pnpm/vitest@3.2.4_@types+node@24.5.2/node_modules/vitest/dist/chunks/vi.bdSIJ99Y.js
const unsupported = [
	"matchSnapshot",
	"toMatchSnapshot",
	"toMatchInlineSnapshot",
	"toThrowErrorMatchingSnapshot",
	"toThrowErrorMatchingInlineSnapshot",
	"throws",
	"Throw",
	"throw",
	"toThrow",
	"toThrowError"
];
function createExpectPoll(expect$1) {
	return function poll(fn$1, options = {}) {
		const defaults = getWorkerState().config.expect?.poll ?? {};
		const { interval = defaults.interval ?? 50, timeout = defaults.timeout ?? 1e3, message } = options;
		const assertion = expect$1(null, message).withContext({ poll: true });
		fn$1 = fn$1.bind(assertion);
		const test$7 = utils_exports.flag(assertion, "vitest-test");
		if (!test$7) throw new Error("expect.poll() must be called inside a test");
		const proxy = new Proxy(assertion, { get(target, key, receiver) {
			const assertionFunction = Reflect.get(target, key, receiver);
			if (typeof assertionFunction !== "function") return assertionFunction instanceof Assertion ? proxy : assertionFunction;
			if (key === "assert") return assertionFunction;
			if (typeof key === "string" && unsupported.includes(key)) throw new SyntaxError(`expect.poll() is not supported in combination with .${key}(). Use vi.waitFor() if your assertion condition is unstable.`);
			return function(...args) {
				const STACK_TRACE_ERROR = /* @__PURE__ */ new Error("STACK_TRACE_ERROR");
				const promise = () => new Promise((resolve$4, reject) => {
					let intervalId;
					let timeoutId;
					let lastError;
					const { setTimeout: setTimeout$1, clearTimeout: clearTimeout$1 } = getSafeTimers();
					const check = async () => {
						try {
							utils_exports.flag(assertion, "_name", key);
							const obj = await fn$1();
							utils_exports.flag(assertion, "object", obj);
							resolve$4(await assertionFunction.call(assertion, ...args));
							clearTimeout$1(intervalId);
							clearTimeout$1(timeoutId);
						} catch (err) {
							lastError = err;
							if (!utils_exports.flag(assertion, "_isLastPollAttempt")) intervalId = setTimeout$1(check, interval);
						}
					};
					timeoutId = setTimeout$1(() => {
						clearTimeout$1(intervalId);
						utils_exports.flag(assertion, "_isLastPollAttempt", true);
						const rejectWithCause = (cause) => {
							reject(copyStackTrace$1(new Error("Matcher did not succeed in time.", { cause }), STACK_TRACE_ERROR));
						};
						check().then(() => rejectWithCause(lastError)).catch((e) => rejectWithCause(e));
					}, timeout);
					check();
				});
				let awaited = false;
				test$7.onFinished ??= [];
				test$7.onFinished.push(() => {
					if (!awaited) {
						const negated = utils_exports.flag(assertion, "negate") ? "not." : "";
						const assertionString = `expect.${utils_exports.flag(assertion, "_poll.element") ? "element(locator)" : "poll(assertion)"}.${negated}${String(key)}()`;
						const error = /* @__PURE__ */ new Error(`${assertionString} was not awaited. This assertion is asynchronous and must be awaited; otherwise, it is not executed to avoid unhandled rejections:\n\nawait ${assertionString}\n`);
						throw copyStackTrace$1(error, STACK_TRACE_ERROR);
					}
				});
				let resultPromise;
				return {
					then(onFulfilled, onRejected) {
						awaited = true;
						return (resultPromise ||= promise()).then(onFulfilled, onRejected);
					},
					catch(onRejected) {
						return (resultPromise ||= promise()).catch(onRejected);
					},
					finally(onFinally) {
						return (resultPromise ||= promise()).finally(onFinally);
					},
					[Symbol.toStringTag]: "Promise"
				};
			};
		} });
		return proxy;
	};
}
function copyStackTrace$1(target, source) {
	if (source.stack !== void 0) target.stack = source.stack.replace(source.message, target.message);
	return target;
}
function commonjsRequire(path) {
	throw new Error("Could not dynamically require \"" + path + "\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.");
}
var chaiSubset$1 = { exports: {} };
var chaiSubset = chaiSubset$1.exports;
var hasRequiredChaiSubset;
function requireChaiSubset() {
	if (hasRequiredChaiSubset) return chaiSubset$1.exports;
	hasRequiredChaiSubset = 1;
	(function(module$1, exports) {
		(function() {
			(function(chaiSubset$2) {
				if (typeof commonjsRequire === "function" && true) return module$1.exports = chaiSubset$2;
				else return chai.use(chaiSubset$2);
			})(function(chai$1, utils) {
				var Assertion$1 = chai$1.Assertion;
				var assertionPrototype = Assertion$1.prototype;
				Assertion$1.addMethod("containSubset", function(expected) {
					var actual = utils.flag(this, "object");
					var showDiff = chai$1.config.showDiff;
					assertionPrototype.assert.call(this, compare(expected, actual), "expected #{act} to contain subset #{exp}", "expected #{act} to not contain subset #{exp}", expected, actual, showDiff);
				});
				chai$1.assert.containSubset = function(val, exp, msg) {
					new chai$1.Assertion(val, msg).to.be.containSubset(exp);
				};
				function compare(expected, actual) {
					if (expected === actual) return true;
					if (typeof actual !== typeof expected) return false;
					if (typeof expected !== "object" || expected === null) return expected === actual;
					if (!!expected && !actual) return false;
					if (Array.isArray(expected)) {
						if (typeof actual.length !== "number") return false;
						var aa = Array.prototype.slice.call(actual);
						return expected.every(function(exp) {
							return aa.some(function(act) {
								return compare(exp, act);
							});
						});
					}
					if (expected instanceof Date) if (actual instanceof Date) return expected.getTime() === actual.getTime();
					else return false;
					return Object.keys(expected).every(function(key) {
						var eo = expected[key];
						var ao = actual[key];
						if (typeof eo === "object" && eo !== null && ao !== null) return compare(eo, ao);
						if (typeof eo === "function") return eo(ao);
						return ao === eo;
					});
				}
			});
		}).call(chaiSubset);
	})(chaiSubset$1);
	return chaiSubset$1.exports;
}
var chaiSubsetExports = requireChaiSubset();
var Subset = /* @__PURE__ */ getDefaultExportFromCjs(chaiSubsetExports);
function createAssertionMessage(util, assertion, hasArgs) {
	const not = util.flag(assertion, "negate") ? "not." : "";
	const name = `${util.flag(assertion, "_name")}(expected)`;
	const promiseName = util.flag(assertion, "promise");
	return `expect(actual)${promiseName ? `.${promiseName}` : ""}.${not}${name}`;
}
function recordAsyncExpect(_test$1, promise, assertion, error) {
	const test$7 = _test$1;
	if (test$7 && promise instanceof Promise) {
		promise = promise.finally(() => {
			if (!test$7.promises) return;
			const index = test$7.promises.indexOf(promise);
			if (index !== -1) test$7.promises.splice(index, 1);
		});
		if (!test$7.promises) test$7.promises = [];
		test$7.promises.push(promise);
		let resolved = false;
		test$7.onFinished ??= [];
		test$7.onFinished.push(() => {
			if (!resolved) {
				const stack = (globalThis.__vitest_worker__?.onFilterStackTrace || ((s) => s || ""))(error.stack);
				console.warn([
					`Promise returned by \`${assertion}\` was not awaited. `,
					"Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
					"Please remember to await the assertion.\n",
					stack
				].join(""));
			}
		});
		return {
			then(onFulfilled, onRejected) {
				resolved = true;
				return promise.then(onFulfilled, onRejected);
			},
			catch(onRejected) {
				return promise.catch(onRejected);
			},
			finally(onFinally) {
				return promise.finally(onFinally);
			},
			[Symbol.toStringTag]: "Promise"
		};
	}
	return promise;
}
let _client;
function getSnapshotClient() {
	if (!_client) _client = new SnapshotClient({ isEqual: (received, expected) => {
		return equals(received, expected, [iterableEquality, subsetEquality]);
	} });
	return _client;
}
function getError(expected, promise) {
	if (typeof expected !== "function") {
		if (!promise) throw new Error(`expected must be a function, received ${typeof expected}`);
		return expected;
	}
	try {
		expected();
	} catch (e) {
		return e;
	}
	throw new Error("snapshot function didn't throw");
}
function getTestNames(test$7) {
	return {
		filepath: test$7.file.filepath,
		name: getNames(test$7).slice(1).join(" > "),
		testId: test$7.id
	};
}
const SnapshotPlugin = (chai$1, utils) => {
	function getTest(assertionName, obj) {
		const test$7 = utils.flag(obj, "vitest-test");
		if (!test$7) throw new Error(`'${assertionName}' cannot be used without test context`);
		return test$7;
	}
	for (const key of ["matchSnapshot", "toMatchSnapshot"]) utils.addMethod(chai$1.Assertion.prototype, key, function(properties, message) {
		utils.flag(this, "_name", key);
		if (utils.flag(this, "negate")) throw new Error(`${key} cannot be used with "not"`);
		const expected = utils.flag(this, "object");
		const test$7 = getTest(key, this);
		if (typeof properties === "string" && typeof message === "undefined") {
			message = properties;
			properties = void 0;
		}
		const errorMessage = utils.flag(this, "message");
		getSnapshotClient().assert({
			received: expected,
			message,
			isInline: false,
			properties,
			errorMessage,
			...getTestNames(test$7)
		});
	});
	utils.addMethod(chai$1.Assertion.prototype, "toMatchFileSnapshot", function(file, message) {
		utils.flag(this, "_name", "toMatchFileSnapshot");
		if (utils.flag(this, "negate")) throw new Error("toMatchFileSnapshot cannot be used with \"not\"");
		const error = /* @__PURE__ */ new Error("resolves");
		const expected = utils.flag(this, "object");
		const test$7 = getTest("toMatchFileSnapshot", this);
		const errorMessage = utils.flag(this, "message");
		const promise = getSnapshotClient().assertRaw({
			received: expected,
			message,
			isInline: false,
			rawSnapshot: { file },
			errorMessage,
			...getTestNames(test$7)
		});
		return recordAsyncExpect(test$7, promise, createAssertionMessage(utils, this), error);
	});
	utils.addMethod(chai$1.Assertion.prototype, "toMatchInlineSnapshot", function __INLINE_SNAPSHOT__(properties, inlineSnapshot, message) {
		utils.flag(this, "_name", "toMatchInlineSnapshot");
		if (utils.flag(this, "negate")) throw new Error("toMatchInlineSnapshot cannot be used with \"not\"");
		const test$7 = getTest("toMatchInlineSnapshot", this);
		if (test$7.each || test$7.suite?.each) throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
		const expected = utils.flag(this, "object");
		const error = utils.flag(this, "error");
		if (typeof properties === "string") {
			message = inlineSnapshot;
			inlineSnapshot = properties;
			properties = void 0;
		}
		if (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
		const errorMessage = utils.flag(this, "message");
		getSnapshotClient().assert({
			received: expected,
			message,
			isInline: true,
			properties,
			inlineSnapshot,
			error,
			errorMessage,
			...getTestNames(test$7)
		});
	});
	utils.addMethod(chai$1.Assertion.prototype, "toThrowErrorMatchingSnapshot", function(message) {
		utils.flag(this, "_name", "toThrowErrorMatchingSnapshot");
		if (utils.flag(this, "negate")) throw new Error("toThrowErrorMatchingSnapshot cannot be used with \"not\"");
		const expected = utils.flag(this, "object");
		const test$7 = getTest("toThrowErrorMatchingSnapshot", this);
		const promise = utils.flag(this, "promise");
		const errorMessage = utils.flag(this, "message");
		getSnapshotClient().assert({
			received: getError(expected, promise),
			message,
			errorMessage,
			...getTestNames(test$7)
		});
	});
	utils.addMethod(chai$1.Assertion.prototype, "toThrowErrorMatchingInlineSnapshot", function __INLINE_SNAPSHOT__(inlineSnapshot, message) {
		if (utils.flag(this, "negate")) throw new Error("toThrowErrorMatchingInlineSnapshot cannot be used with \"not\"");
		const test$7 = getTest("toThrowErrorMatchingInlineSnapshot", this);
		if (test$7.each || test$7.suite?.each) throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
		const expected = utils.flag(this, "object");
		const error = utils.flag(this, "error");
		const promise = utils.flag(this, "promise");
		const errorMessage = utils.flag(this, "message");
		if (inlineSnapshot) inlineSnapshot = stripSnapshotIndentation(inlineSnapshot);
		getSnapshotClient().assert({
			received: getError(expected, promise),
			message,
			inlineSnapshot,
			isInline: true,
			error,
			errorMessage,
			...getTestNames(test$7)
		});
	});
	utils.addMethod(chai$1.expect, "addSnapshotSerializer", addSerializer);
};
use(JestExtend);
use(JestChaiExpect);
use(Subset);
use(SnapshotPlugin);
use(JestAsymmetricMatchers);
function createExpect(test$7) {
	const expect$1 = (value, message) => {
		const { assertionCalls } = getState(expect$1);
		setState({ assertionCalls: assertionCalls + 1 }, expect$1);
		const assert$2 = expect(value, message);
		const _test$1 = test$7 || getCurrentTest();
		if (_test$1) return assert$2.withTest(_test$1);
		else return assert$2;
	};
	Object.assign(expect$1, expect);
	Object.assign(expect$1, globalThis[ASYMMETRIC_MATCHERS_OBJECT]);
	expect$1.getState = () => getState(expect$1);
	expect$1.setState = (state) => setState(state, expect$1);
	const globalState = getState(globalThis[GLOBAL_EXPECT]) || {};
	setState({
		...globalState,
		assertionCalls: 0,
		isExpectingAssertions: false,
		isExpectingAssertionsError: null,
		expectedAssertionsNumber: null,
		expectedAssertionsNumberErrorGen: null,
		environment: getCurrentEnvironment(),
		get testPath() {
			return getWorkerState().filepath;
		},
		currentTestName: test$7 ? getTestName(test$7) : globalState.currentTestName
	}, expect$1);
	expect$1.extend = (matchers) => expect.extend(expect$1, matchers);
	expect$1.addEqualityTesters = (customTesters) => addCustomEqualityTesters(customTesters);
	expect$1.soft = (...args) => {
		return expect$1(...args).withContext({ soft: true });
	};
	expect$1.poll = createExpectPoll(expect$1);
	expect$1.unreachable = (message) => {
		assert$1.fail(`expected${message ? ` "${message}" ` : " "}not to be reached`);
	};
	function assertions(expected) {
		const errorGen = () => /* @__PURE__ */ new Error(`expected number of assertions to be ${expected}, but got ${expect$1.getState().assertionCalls}`);
		if (Error.captureStackTrace) Error.captureStackTrace(errorGen(), assertions);
		expect$1.setState({
			expectedAssertionsNumber: expected,
			expectedAssertionsNumberErrorGen: errorGen
		});
	}
	function hasAssertions() {
		const error = /* @__PURE__ */ new Error("expected any number of assertion, but got none");
		if (Error.captureStackTrace) Error.captureStackTrace(error, hasAssertions);
		expect$1.setState({
			isExpectingAssertions: true,
			isExpectingAssertionsError: error
		});
	}
	utils_exports.addMethod(expect$1, "assertions", assertions);
	utils_exports.addMethod(expect$1, "hasAssertions", hasAssertions);
	expect$1.extend(customMatchers);
	return expect$1;
}
const globalExpect = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, {
	value: globalExpect,
	writable: true,
	configurable: true
});
var fakeTimersSrc = {};
var global$1;
var hasRequiredGlobal;
function requireGlobal() {
	if (hasRequiredGlobal) return global$1;
	hasRequiredGlobal = 1;
	/**
	* A reference to the global object
	* @type {object} globalObject
	*/
	var globalObject;
	/* istanbul ignore else */
	if (typeof commonjsGlobal !== "undefined") globalObject = commonjsGlobal;
	else if (typeof window !== "undefined") globalObject = window;
	else globalObject = self;
	global$1 = globalObject;
	return global$1;
}
var throwsOnProto_1;
var hasRequiredThrowsOnProto;
function requireThrowsOnProto() {
	if (hasRequiredThrowsOnProto) return throwsOnProto_1;
	hasRequiredThrowsOnProto = 1;
	/**
	* Is true when the environment causes an error to be thrown for accessing the
	* __proto__ property.
	* This is necessary in order to support `node --disable-proto=throw`.
	*
	* See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto
	* @type {boolean}
	*/
	let throwsOnProto;
	try {
		({}).__proto__;
		throwsOnProto = false;
	} catch (_) {
		/* istanbul ignore next */
		throwsOnProto = true;
	}
	throwsOnProto_1 = throwsOnProto;
	return throwsOnProto_1;
}
var copyPrototypeMethods;
var hasRequiredCopyPrototypeMethods;
function requireCopyPrototypeMethods() {
	if (hasRequiredCopyPrototypeMethods) return copyPrototypeMethods;
	hasRequiredCopyPrototypeMethods = 1;
	var call$1 = Function.call;
	var throwsOnProto = requireThrowsOnProto();
	var disallowedProperties = [
		"size",
		"caller",
		"callee",
		"arguments"
	];
	/* istanbul ignore next */
	if (throwsOnProto) disallowedProperties.push("__proto__");
	copyPrototypeMethods = function copyPrototypeMethods$1(prototype) {
		return Object.getOwnPropertyNames(prototype).reduce(function(result, name) {
			if (disallowedProperties.includes(name)) return result;
			if (typeof prototype[name] !== "function") return result;
			result[name] = call$1.bind(prototype[name]);
			return result;
		}, Object.create(null));
	};
	return copyPrototypeMethods;
}
var array;
var hasRequiredArray;
function requireArray() {
	if (hasRequiredArray) return array;
	hasRequiredArray = 1;
	array = requireCopyPrototypeMethods()(Array.prototype);
	return array;
}
var calledInOrder_1;
var hasRequiredCalledInOrder;
function requireCalledInOrder() {
	if (hasRequiredCalledInOrder) return calledInOrder_1;
	hasRequiredCalledInOrder = 1;
	var every$1 = requireArray().every;
	/**
	* @private
	*/
	function hasCallsLeft(callMap, spy) {
		if (callMap[spy.id] === void 0) callMap[spy.id] = 0;
		return callMap[spy.id] < spy.callCount;
	}
	/**
	* @private
	*/
	function checkAdjacentCalls(callMap, spy, index, spies) {
		var calledBeforeNext = true;
		if (index !== spies.length - 1) calledBeforeNext = spy.calledBefore(spies[index + 1]);
		if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
			callMap[spy.id] += 1;
			return true;
		}
		return false;
	}
	/**
	* A Sinon proxy object (fake, spy, stub)
	* @typedef {object} SinonProxy
	* @property {Function} calledBefore - A method that determines if this proxy was called before another one
	* @property {string} id - Some id
	* @property {number} callCount - Number of times this proxy has been called
	*/
	/**
	* Returns true when the spies have been called in the order they were supplied in
	* @param  {SinonProxy[] | SinonProxy} spies An array of proxies, or several proxies as arguments
	* @returns {boolean} true when spies are called in order, false otherwise
	*/
	function calledInOrder(spies) {
		var callMap = {};
		var _spies = arguments.length > 1 ? arguments : spies;
		return every$1(_spies, checkAdjacentCalls.bind(null, callMap));
	}
	calledInOrder_1 = calledInOrder;
	return calledInOrder_1;
}
var className_1;
var hasRequiredClassName;
function requireClassName() {
	if (hasRequiredClassName) return className_1;
	hasRequiredClassName = 1;
	/**
	* Returns a display name for a value from a constructor
	* @param  {object} value A value to examine
	* @returns {(string|null)} A string or null
	*/
	function className(value) {
		return value.constructor && value.constructor.name || null;
	}
	className_1 = className;
	return className_1;
}
var deprecated = {};
var hasRequiredDeprecated;
function requireDeprecated() {
	if (hasRequiredDeprecated) return deprecated;
	hasRequiredDeprecated = 1;
	(function(exports) {
		/**
		* Returns a function that will invoke the supplied function and print a
		* deprecation warning to the console each time it is called.
		* @param  {Function} func
		* @param  {string} msg
		* @returns {Function}
		*/
		exports.wrap = function(func, msg) {
			var wrapped = function() {
				exports.printWarning(msg);
				return func.apply(this, arguments);
			};
			if (func.prototype) wrapped.prototype = func.prototype;
			return wrapped;
		};
		/**
		* Returns a string which can be supplied to `wrap()` to notify the user that a
		* particular part of the sinon API has been deprecated.
		* @param  {string} packageName
		* @param  {string} funcName
		* @returns {string}
		*/
		exports.defaultMsg = function(packageName, funcName) {
			return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;
		};
		/**
		* Prints a warning on the console, when it exists
		* @param  {string} msg
		* @returns {undefined}
		*/
		exports.printWarning = function(msg) {
			/* istanbul ignore next */
			if (typeof process === "object" && process.emitWarning) process.emitWarning(msg);
			else if (console.info) console.info(msg);
			else console.log(msg);
		};
	})(deprecated);
	return deprecated;
}
var every;
var hasRequiredEvery;
function requireEvery() {
	if (hasRequiredEvery) return every;
	hasRequiredEvery = 1;
	/**
	* Returns true when fn returns true for all members of obj.
	* This is an every implementation that works for all iterables
	* @param  {object}   obj
	* @param  {Function} fn
	* @returns {boolean}
	*/
	every = function every$1(obj, fn$1) {
		var pass = true;
		try {
			obj.forEach(function() {
				if (!fn$1.apply(this, arguments)) throw new Error();
			});
		} catch (e) {
			pass = false;
		}
		return pass;
	};
	return every;
}
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
	if (hasRequiredFunctionName) return functionName;
	hasRequiredFunctionName = 1;
	/**
	* Returns a display name for a function
	* @param  {Function} func
	* @returns {string}
	*/
	functionName = function functionName$1(func) {
		if (!func) return "";
		try {
			return func.displayName || func.name || (String(func).match(/function ([^\s(]+)/) || [])[1];
		} catch (e) {
			return "";
		}
	};
	return functionName;
}
var orderByFirstCall_1;
var hasRequiredOrderByFirstCall;
function requireOrderByFirstCall() {
	if (hasRequiredOrderByFirstCall) return orderByFirstCall_1;
	hasRequiredOrderByFirstCall = 1;
	var sort$1 = requireArray().sort;
	var slice = requireArray().slice;
	/**
	* @private
	*/
	function comparator(a$2, b$1) {
		var aCall = a$2.getCall(0);
		var bCall = b$1.getCall(0);
		var aId = aCall && aCall.callId || -1;
		var bId = bCall && bCall.callId || -1;
		return aId < bId ? -1 : 1;
	}
	/**
	* A Sinon proxy object (fake, spy, stub)
	* @typedef {object} SinonProxy
	* @property {Function} getCall - A method that can return the first call
	*/
	/**
	* Sorts an array of SinonProxy instances (fake, spy, stub) by their first call
	* @param  {SinonProxy[] | SinonProxy} spies
	* @returns {SinonProxy[]}
	*/
	function orderByFirstCall(spies) {
		return sort$1(slice(spies), comparator);
	}
	orderByFirstCall_1 = orderByFirstCall;
	return orderByFirstCall_1;
}
var _function;
var hasRequired_function;
function require_function() {
	if (hasRequired_function) return _function;
	hasRequired_function = 1;
	_function = requireCopyPrototypeMethods()(Function.prototype);
	return _function;
}
var map;
var hasRequiredMap;
function requireMap() {
	if (hasRequiredMap) return map;
	hasRequiredMap = 1;
	map = requireCopyPrototypeMethods()(Map.prototype);
	return map;
}
var object;
var hasRequiredObject;
function requireObject() {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	object = requireCopyPrototypeMethods()(Object.prototype);
	return object;
}
var set;
var hasRequiredSet;
function requireSet() {
	if (hasRequiredSet) return set;
	hasRequiredSet = 1;
	set = requireCopyPrototypeMethods()(Set.prototype);
	return set;
}
var string;
var hasRequiredString;
function requireString() {
	if (hasRequiredString) return string;
	hasRequiredString = 1;
	string = requireCopyPrototypeMethods()(String.prototype);
	return string;
}
var prototypes;
var hasRequiredPrototypes;
function requirePrototypes() {
	if (hasRequiredPrototypes) return prototypes;
	hasRequiredPrototypes = 1;
	prototypes = {
		array: requireArray(),
		function: require_function(),
		map: requireMap(),
		object: requireObject(),
		set: requireSet(),
		string: requireString()
	};
	return prototypes;
}
var typeDetect$1 = { exports: {} };
var typeDetect = typeDetect$1.exports;
var hasRequiredTypeDetect;
function requireTypeDetect() {
	if (hasRequiredTypeDetect) return typeDetect$1.exports;
	hasRequiredTypeDetect = 1;
	(function(module$1, exports) {
		(function(global$2, factory) {
			module$1.exports = factory();
		})(typeDetect, (function() {
			var promiseExists = typeof Promise === "function";
			var globalObject = typeof self === "object" ? self : commonjsGlobal;
			var symbolExists = typeof Symbol !== "undefined";
			var mapExists = typeof Map !== "undefined";
			var setExists = typeof Set !== "undefined";
			var weakMapExists = typeof WeakMap !== "undefined";
			var weakSetExists = typeof WeakSet !== "undefined";
			var dataViewExists = typeof DataView !== "undefined";
			var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
			var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
			var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
			var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
			var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries());
			var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries());
			var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
			var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
			var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
			var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
			var toStringLeftSliceLength = 8;
			var toStringRightSliceLength = -1;
			/**
			* ### typeOf (obj)
			*
			* Uses `Object.prototype.toString` to determine the type of an object,
			* normalising behaviour across engine versions & well optimised.
			*
			* @param {Mixed} object
			* @return {String} object type
			* @api public
			*/
			function typeDetect$2(obj) {
				var typeofObj = typeof obj;
				if (typeofObj !== "object") return typeofObj;
				if (obj === null) return "null";
				if (obj === globalObject) return "global";
				if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) return "Array";
				if (typeof window === "object" && window !== null) {
					if (typeof window.location === "object" && obj === window.location) return "Location";
					if (typeof window.document === "object" && obj === window.document) return "Document";
					if (typeof window.navigator === "object") {
						if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) return "MimeTypeArray";
						if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) return "PluginArray";
					}
					if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
						if (obj.tagName === "BLOCKQUOTE") return "HTMLQuoteElement";
						if (obj.tagName === "TD") return "HTMLTableDataCellElement";
						if (obj.tagName === "TH") return "HTMLTableHeaderCellElement";
					}
				}
				var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
				if (typeof stringTag === "string") return stringTag;
				var objPrototype = Object.getPrototypeOf(obj);
				if (objPrototype === RegExp.prototype) return "RegExp";
				if (objPrototype === Date.prototype) return "Date";
				if (promiseExists && objPrototype === Promise.prototype) return "Promise";
				if (setExists && objPrototype === Set.prototype) return "Set";
				if (mapExists && objPrototype === Map.prototype) return "Map";
				if (weakSetExists && objPrototype === WeakSet.prototype) return "WeakSet";
				if (weakMapExists && objPrototype === WeakMap.prototype) return "WeakMap";
				if (dataViewExists && objPrototype === DataView.prototype) return "DataView";
				if (mapExists && objPrototype === mapIteratorPrototype) return "Map Iterator";
				if (setExists && objPrototype === setIteratorPrototype) return "Set Iterator";
				if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) return "Array Iterator";
				if (stringIteratorExists && objPrototype === stringIteratorPrototype) return "String Iterator";
				if (objPrototype === null) return "Object";
				return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
			}
			return typeDetect$2;
		}));
	})(typeDetect$1);
	return typeDetect$1.exports;
}
var typeOf;
var hasRequiredTypeOf;
function requireTypeOf() {
	if (hasRequiredTypeOf) return typeOf;
	hasRequiredTypeOf = 1;
	var type$1 = requireTypeDetect();
	/**
	* Returns the lower-case result of running type from type-detect on the value
	* @param  {*} value
	* @returns {string}
	*/
	typeOf = function typeOf$1(value) {
		return type$1(value).toLowerCase();
	};
	return typeOf;
}
var valueToString_1;
var hasRequiredValueToString;
function requireValueToString() {
	if (hasRequiredValueToString) return valueToString_1;
	hasRequiredValueToString = 1;
	/**
	* Returns a string representation of the value
	* @param  {*} value
	* @returns {string}
	*/
	function valueToString(value) {
		if (value && value.toString) return value.toString();
		return String(value);
	}
	valueToString_1 = valueToString;
	return valueToString_1;
}
var lib;
var hasRequiredLib;
function requireLib() {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	lib = {
		global: requireGlobal(),
		calledInOrder: requireCalledInOrder(),
		className: requireClassName(),
		deprecated: requireDeprecated(),
		every: requireEvery(),
		functionName: requireFunctionName(),
		orderByFirstCall: requireOrderByFirstCall(),
		prototypes: requirePrototypes(),
		typeOf: requireTypeOf(),
		valueToString: requireValueToString()
	};
	return lib;
}
var hasRequiredFakeTimersSrc;
function requireFakeTimersSrc() {
	if (hasRequiredFakeTimersSrc) return fakeTimersSrc;
	hasRequiredFakeTimersSrc = 1;
	const globalObject = requireLib().global;
	let timersModule, timersPromisesModule;
	if (typeof __vitest_required__ !== "undefined") {
		try {
			timersModule = __vitest_required__.timers;
		} catch (e) {}
		try {
			timersPromisesModule = __vitest_required__.timersPromises;
		} catch (e) {}
	}
	/**
	* @typedef {object} IdleDeadline
	* @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout
	* @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period
	*/
	/**
	* Queues a function to be called during a browser's idle periods
	* @callback RequestIdleCallback
	* @param {function(IdleDeadline)} callback
	* @param {{timeout: number}} options - an options object
	* @returns {number} the id
	*/
	/**
	* @callback NextTick
	* @param {VoidVarArgsFunc} callback - the callback to run
	* @param {...*} args - optional arguments to call the callback with
	* @returns {void}
	*/
	/**
	* @callback SetImmediate
	* @param {VoidVarArgsFunc} callback - the callback to run
	* @param {...*} args - optional arguments to call the callback with
	* @returns {NodeImmediate}
	*/
	/**
	* @callback VoidVarArgsFunc
	* @param {...*} callback - the callback to run
	* @returns {void}
	*/
	/**
	* @typedef RequestAnimationFrame
	* @property {function(number):void} requestAnimationFrame
	* @returns {number} - the id
	*/
	/**
	* @typedef Performance
	* @property {function(): number} now
	*/
	/**
	* @typedef {object} Clock
	* @property {number} now - the current time
	* @property {Date} Date - the Date constructor
	* @property {number} loopLimit - the maximum number of timers before assuming an infinite loop
	* @property {RequestIdleCallback} requestIdleCallback
	* @property {function(number):void} cancelIdleCallback
	* @property {setTimeout} setTimeout
	* @property {clearTimeout} clearTimeout
	* @property {NextTick} nextTick
	* @property {queueMicrotask} queueMicrotask
	* @property {setInterval} setInterval
	* @property {clearInterval} clearInterval
	* @property {SetImmediate} setImmediate
	* @property {function(NodeImmediate):void} clearImmediate
	* @property {function():number} countTimers
	* @property {RequestAnimationFrame} requestAnimationFrame
	* @property {function(number):void} cancelAnimationFrame
	* @property {function():void} runMicrotasks
	* @property {function(string | number): number} tick
	* @property {function(string | number): Promise<number>} tickAsync
	* @property {function(): number} next
	* @property {function(): Promise<number>} nextAsync
	* @property {function(): number} runAll
	* @property {function(): number} runToFrame
	* @property {function(): Promise<number>} runAllAsync
	* @property {function(): number} runToLast
	* @property {function(): Promise<number>} runToLastAsync
	* @property {function(): void} reset
	* @property {function(number | Date): void} setSystemTime
	* @property {function(number): void} jump
	* @property {Performance} performance
	* @property {function(number[]): number[]} hrtime - process.hrtime (legacy)
	* @property {function(): void} uninstall Uninstall the clock.
	* @property {Function[]} methods - the methods that are faked
	* @property {boolean} [shouldClearNativeTimers] inherited from config
	* @property {{methodName:string, original:any}[] | undefined} timersModuleMethods
	* @property {{methodName:string, original:any}[] | undefined} timersPromisesModuleMethods
	* @property {Map<function(): void, AbortSignal>} abortListenerMap
	*/
	/**
	* Configuration object for the `install` method.
	* @typedef {object} Config
	* @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)
	* @property {string[]} [toFake] names of the methods that should be faked.
	* @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()
	* @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)
	* @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)
	* @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)
	* @property {boolean} [ignoreMissingTimers] default is false, meaning asking to fake timers that are not present will throw an error
	*/
	/**
	* The internal structure to describe a scheduled fake timer
	* @typedef {object} Timer
	* @property {Function} func
	* @property {*[]} args
	* @property {number} delay
	* @property {number} callAt
	* @property {number} createdAt
	* @property {boolean} immediate
	* @property {number} id
	* @property {Error} [error]
	*/
	/**
	* A Node timer
	* @typedef {object} NodeImmediate
	* @property {function(): boolean} hasRef
	* @property {function(): NodeImmediate} ref
	* @property {function(): NodeImmediate} unref
	*/
	/**
	* Mocks available features in the specified global namespace.
	* @param {*} _global Namespace to mock (e.g. `window`)
	* @returns {FakeTimers}
	*/
	function withGlobal(_global) {
		const maxTimeout = Math.pow(2, 31) - 1;
		const idCounterStart = 0xe8d4a51000;
		const NOOP = function() {};
		const NOOP_ARRAY = function() {
			return [];
		};
		const isPresent = {};
		let timeoutResult, addTimerReturnsObject = false;
		if (_global.setTimeout) {
			isPresent.setTimeout = true;
			timeoutResult = _global.setTimeout(NOOP, 0);
			addTimerReturnsObject = typeof timeoutResult === "object";
		}
		isPresent.clearTimeout = Boolean(_global.clearTimeout);
		isPresent.setInterval = Boolean(_global.setInterval);
		isPresent.clearInterval = Boolean(_global.clearInterval);
		isPresent.hrtime = _global.process && typeof _global.process.hrtime === "function";
		isPresent.hrtimeBigint = isPresent.hrtime && typeof _global.process.hrtime.bigint === "function";
		isPresent.nextTick = _global.process && typeof _global.process.nextTick === "function";
		const utilPromisify = _global.process && _global.__vitest_required__ && _global.__vitest_required__.util.promisify;
		isPresent.performance = _global.performance && typeof _global.performance.now === "function";
		const hasPerformancePrototype = _global.Performance && (typeof _global.Performance).match(/^(function|object)$/);
		const hasPerformanceConstructorPrototype = _global.performance && _global.performance.constructor && _global.performance.constructor.prototype;
		isPresent.queueMicrotask = _global.hasOwnProperty("queueMicrotask");
		isPresent.requestAnimationFrame = _global.requestAnimationFrame && typeof _global.requestAnimationFrame === "function";
		isPresent.cancelAnimationFrame = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame === "function";
		isPresent.requestIdleCallback = _global.requestIdleCallback && typeof _global.requestIdleCallback === "function";
		isPresent.cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback === "function";
		isPresent.setImmediate = _global.setImmediate && typeof _global.setImmediate === "function";
		isPresent.clearImmediate = _global.clearImmediate && typeof _global.clearImmediate === "function";
		isPresent.Intl = _global.Intl && typeof _global.Intl === "object";
		if (_global.clearTimeout) _global.clearTimeout(timeoutResult);
		const NativeDate = _global.Date;
		const NativeIntl = isPresent.Intl ? Object.defineProperties(Object.create(null), Object.getOwnPropertyDescriptors(_global.Intl)) : void 0;
		let uniqueTimerId = idCounterStart;
		if (NativeDate === void 0) throw new Error("The global scope doesn't have a `Date` object (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)");
		isPresent.Date = true;
		/**
		* The PerformanceEntry object encapsulates a single performance metric
		* that is part of the browser's performance timeline.
		*
		* This is an object returned by the `mark` and `measure` methods on the Performance prototype
		*/
		class FakePerformanceEntry {
			constructor(name, entryType, startTime, duration) {
				this.name = name;
				this.entryType = entryType;
				this.startTime = startTime;
				this.duration = duration;
			}
			toJSON() {
				return JSON.stringify({ ...this });
			}
		}
		/**
		* @param {number} num
		* @returns {boolean}
		*/
		function isNumberFinite(num) {
			if (Number.isFinite) return Number.isFinite(num);
			return isFinite(num);
		}
		let isNearInfiniteLimit = false;
		/**
		* @param {Clock} clock
		* @param {number} i
		*/
		function checkIsNearInfiniteLimit(clock, i) {
			if (clock.loopLimit && i === clock.loopLimit - 1) isNearInfiniteLimit = true;
		}
		/**
		*
		*/
		function resetIsNearInfiniteLimit() {
			isNearInfiniteLimit = false;
		}
		/**
		* Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
		* number of milliseconds. This is used to support human-readable strings passed
		* to clock.tick()
		* @param {string} str
		* @returns {number}
		*/
		function parseTime(str) {
			if (!str) return 0;
			const strings = str.split(":");
			const l$1 = strings.length;
			let i = l$1;
			let ms = 0;
			let parsed;
			if (l$1 > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) throw new Error("tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits");
			while (i--) {
				parsed = parseInt(strings[i], 10);
				if (parsed >= 60) throw new Error(`Invalid time ${str}`);
				ms += parsed * Math.pow(60, l$1 - i - 1);
			}
			return ms * 1e3;
		}
		/**
		* Get the decimal part of the millisecond value as nanoseconds
		* @param {number} msFloat the number of milliseconds
		* @returns {number} an integer number of nanoseconds in the range [0,1e6)
		*
		* Example: nanoRemainer(123.456789) -> 456789
		*/
		function nanoRemainder(msFloat) {
			const modulo = 1e6;
			const remainder = msFloat * 1e6 % modulo;
			const positiveRemainder = remainder < 0 ? remainder + modulo : remainder;
			return Math.floor(positiveRemainder);
		}
		/**
		* Used to grok the `now` parameter to createClock.
		* @param {Date|number} epoch the system time
		* @returns {number}
		*/
		function getEpoch(epoch) {
			if (!epoch) return 0;
			if (typeof epoch.getTime === "function") return epoch.getTime();
			if (typeof epoch === "number") return epoch;
			throw new TypeError("now should be milliseconds since UNIX epoch");
		}
		/**
		* @param {number} from
		* @param {number} to
		* @param {Timer} timer
		* @returns {boolean}
		*/
		function inRange(from, to, timer) {
			return timer && timer.callAt >= from && timer.callAt <= to;
		}
		/**
		* @param {Clock} clock
		* @param {Timer} job
		*/
		function getInfiniteLoopError(clock, job) {
			const infiniteLoopError = /* @__PURE__ */ new Error(`Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`);
			if (!job.error) return infiniteLoopError;
			const computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/;
			let clockMethodPattern = new RegExp(String(Object.keys(clock).join("|")));
			if (addTimerReturnsObject) clockMethodPattern = /* @__PURE__ */ new RegExp(`\\s+at (Object\\.)?(?:${Object.keys(clock).join("|")})\\s+`);
			let matchedLineIndex = -1;
			job.error.stack.split("\n").some(function(line, i) {
				/* istanbul ignore if */
				if (line.match(computedTargetPattern)) {
					matchedLineIndex = i;
					return true;
				}
				if (line.match(clockMethodPattern)) {
					matchedLineIndex = i;
					return false;
				}
				return matchedLineIndex >= 0;
			});
			const stack = `${infiniteLoopError}\n${job.type || "Microtask"} - ${job.func.name || "anonymous"}\n${job.error.stack.split("\n").slice(matchedLineIndex + 1).join("\n")}`;
			try {
				Object.defineProperty(infiniteLoopError, "stack", { value: stack });
			} catch (e) {}
			return infiniteLoopError;
		}
		function createDate() {
			class ClockDate extends NativeDate {
				/**
				* @param {number} year
				* @param {number} month
				* @param {number} date
				* @param {number} hour
				* @param {number} minute
				* @param {number} second
				* @param {number} ms
				* @returns void
				*/
				constructor(year, month, date, hour, minute, second, ms) {
					if (arguments.length === 0) super(ClockDate.clock.now);
					else super(...arguments);
					Object.defineProperty(this, "constructor", {
						value: NativeDate,
						enumerable: false
					});
				}
				static [Symbol.hasInstance](instance) {
					return instance instanceof NativeDate;
				}
			}
			ClockDate.isFake = true;
			if (NativeDate.now) ClockDate.now = function now$4() {
				return ClockDate.clock.now;
			};
			if (NativeDate.toSource) ClockDate.toSource = function toSource() {
				return NativeDate.toSource();
			};
			ClockDate.toString = function toString$3() {
				return NativeDate.toString();
			};
			return new Proxy(ClockDate, { apply() {
				if (this instanceof ClockDate) throw new TypeError("A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic.");
				return new NativeDate(ClockDate.clock.now).toString();
			} });
		}
		/**
		* Mirror Intl by default on our fake implementation
		*
		* Most of the properties are the original native ones,
		* but we need to take control of those that have a
		* dependency on the current clock.
		* @returns {object} the partly fake Intl implementation
		*/
		function createIntl() {
			const ClockIntl = {};
			Object.getOwnPropertyNames(NativeIntl).forEach((property) => ClockIntl[property] = NativeIntl[property]);
			ClockIntl.DateTimeFormat = function(...args) {
				const realFormatter = new NativeIntl.DateTimeFormat(...args);
				const formatter = {};
				[
					"formatRange",
					"formatRangeToParts",
					"resolvedOptions"
				].forEach((method) => {
					formatter[method] = realFormatter[method].bind(realFormatter);
				});
				["format", "formatToParts"].forEach((method) => {
					formatter[method] = function(date) {
						return realFormatter[method](date || ClockIntl.clock.now);
					};
				});
				return formatter;
			};
			ClockIntl.DateTimeFormat.prototype = Object.create(NativeIntl.DateTimeFormat.prototype);
			ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;
			return ClockIntl;
		}
		function enqueueJob(clock, job) {
			if (!clock.jobs) clock.jobs = [];
			clock.jobs.push(job);
		}
		function runJobs(clock) {
			if (!clock.jobs) return;
			for (let i = 0; i < clock.jobs.length; i++) {
				const job = clock.jobs[i];
				job.func.apply(null, job.args);
				checkIsNearInfiniteLimit(clock, i);
				if (clock.loopLimit && i > clock.loopLimit) throw getInfiniteLoopError(clock, job);
			}
			resetIsNearInfiniteLimit();
			clock.jobs = [];
		}
		/**
		* @param {Clock} clock
		* @param {Timer} timer
		* @returns {number} id of the created timer
		*/
		function addTimer(clock, timer) {
			if (timer.func === void 0) throw new Error("Callback must be provided to timer calls");
			if (addTimerReturnsObject) {
				if (typeof timer.func !== "function") throw new TypeError(`[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${timer.func} of type ${typeof timer.func}`);
			}
			if (isNearInfiniteLimit) timer.error = /* @__PURE__ */ new Error();
			timer.type = timer.immediate ? "Immediate" : "Timeout";
			if (timer.hasOwnProperty("delay")) {
				if (typeof timer.delay !== "number") timer.delay = parseInt(timer.delay, 10);
				if (!isNumberFinite(timer.delay)) timer.delay = 0;
				timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;
				timer.delay = Math.max(0, timer.delay);
			}
			if (timer.hasOwnProperty("interval")) {
				timer.type = "Interval";
				timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;
			}
			if (timer.hasOwnProperty("animation")) {
				timer.type = "AnimationFrame";
				timer.animation = true;
			}
			if (timer.hasOwnProperty("idleCallback")) {
				timer.type = "IdleCallback";
				timer.idleCallback = true;
			}
			if (!clock.timers) clock.timers = {};
			timer.id = uniqueTimerId++;
			timer.createdAt = clock.now;
			timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
			clock.timers[timer.id] = timer;
			if (addTimerReturnsObject) {
				const res = {
					refed: true,
					ref: function() {
						this.refed = true;
						return res;
					},
					unref: function() {
						this.refed = false;
						return res;
					},
					hasRef: function() {
						return this.refed;
					},
					refresh: function() {
						timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));
						clock.timers[timer.id] = timer;
						return res;
					},
					[Symbol.toPrimitive]: function() {
						return timer.id;
					}
				};
				return res;
			}
			return timer.id;
		}
		/**
		* Timer comparitor
		* @param {Timer} a
		* @param {Timer} b
		* @returns {number}
		*/
		function compareTimers(a$2, b$1) {
			if (a$2.callAt < b$1.callAt) return -1;
			if (a$2.callAt > b$1.callAt) return 1;
			if (a$2.immediate && !b$1.immediate) return -1;
			if (!a$2.immediate && b$1.immediate) return 1;
			if (a$2.createdAt < b$1.createdAt) return -1;
			if (a$2.createdAt > b$1.createdAt) return 1;
			if (a$2.id < b$1.id) return -1;
			if (a$2.id > b$1.id) return 1;
		}
		/**
		* @param {Clock} clock
		* @param {number} from
		* @param {number} to
		* @returns {Timer}
		*/
		function firstTimerInRange(clock, from, to) {
			const timers$1 = clock.timers;
			let timer = null;
			let id, isInRange;
			for (id in timers$1) if (timers$1.hasOwnProperty(id)) {
				isInRange = inRange(from, to, timers$1[id]);
				if (isInRange && (!timer || compareTimers(timer, timers$1[id]) === 1)) timer = timers$1[id];
			}
			return timer;
		}
		/**
		* @param {Clock} clock
		* @returns {Timer}
		*/
		function firstTimer(clock) {
			const timers$1 = clock.timers;
			let timer = null;
			let id;
			for (id in timers$1) if (timers$1.hasOwnProperty(id)) {
				if (!timer || compareTimers(timer, timers$1[id]) === 1) timer = timers$1[id];
			}
			return timer;
		}
		/**
		* @param {Clock} clock
		* @returns {Timer}
		*/
		function lastTimer(clock) {
			const timers$1 = clock.timers;
			let timer = null;
			let id;
			for (id in timers$1) if (timers$1.hasOwnProperty(id)) {
				if (!timer || compareTimers(timer, timers$1[id]) === -1) timer = timers$1[id];
			}
			return timer;
		}
		/**
		* @param {Clock} clock
		* @param {Timer} timer
		*/
		function callTimer(clock, timer) {
			if (typeof timer.interval === "number") clock.timers[timer.id].callAt += timer.interval;
			else delete clock.timers[timer.id];
			if (typeof timer.func === "function") timer.func.apply(null, timer.args);
			else {
				const eval2 = eval;
				(function() {
					eval2(timer.func);
				})();
			}
		}
		/**
		* Gets clear handler name for a given timer type
		* @param {string} ttype
		*/
		function getClearHandler(ttype) {
			if (ttype === "IdleCallback" || ttype === "AnimationFrame") return `cancel${ttype}`;
			return `clear${ttype}`;
		}
		/**
		* Gets schedule handler name for a given timer type
		* @param {string} ttype
		*/
		function getScheduleHandler(ttype) {
			if (ttype === "IdleCallback" || ttype === "AnimationFrame") return `request${ttype}`;
			return `set${ttype}`;
		}
		/**
		* Creates an anonymous function to warn only once
		*/
		function createWarnOnce() {
			let calls = 0;
			return function(msg) {
				!calls++ && console.warn(msg);
			};
		}
		const warnOnce = createWarnOnce();
		/**
		* @param {Clock} clock
		* @param {number} timerId
		* @param {string} ttype
		*/
		function clearTimer(clock, timerId, ttype) {
			if (!timerId) return;
			if (!clock.timers) clock.timers = {};
			const id = Number(timerId);
			if (Number.isNaN(id) || id < idCounterStart) {
				const handlerName = getClearHandler(ttype);
				if (clock.shouldClearNativeTimers === true) {
					const nativeHandler = clock[`_${handlerName}`];
					return typeof nativeHandler === "function" ? nativeHandler(timerId) : void 0;
				}
				warnOnce(`FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.
To automatically clean-up native timers, use \`shouldClearNativeTimers\`.`);
			}
			if (clock.timers.hasOwnProperty(id)) {
				const timer = clock.timers[id];
				if (timer.type === ttype || timer.type === "Timeout" && ttype === "Interval" || timer.type === "Interval" && ttype === "Timeout") delete clock.timers[id];
				else {
					const clear = getClearHandler(ttype);
					const schedule = getScheduleHandler(timer.type);
					throw new Error(`Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`);
				}
			}
		}
		/**
		* @param {Clock} clock
		* @param {Config} config
		* @returns {Timer[]}
		*/
		function uninstall(clock, config$1) {
			let method, i, l$1;
			const installedHrTime = "_hrtime";
			const installedNextTick = "_nextTick";
			for (i = 0, l$1 = clock.methods.length; i < l$1; i++) {
				method = clock.methods[i];
				if (method === "hrtime" && _global.process) _global.process.hrtime = clock[installedHrTime];
				else if (method === "nextTick" && _global.process) _global.process.nextTick = clock[installedNextTick];
				else if (method === "performance") {
					const originalPerfDescriptor = Object.getOwnPropertyDescriptor(clock, `_${method}`);
					if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) Object.defineProperty(_global, method, originalPerfDescriptor);
					else if (originalPerfDescriptor.configurable) _global[method] = clock[`_${method}`];
				} else if (_global[method] && _global[method].hadOwnProperty) _global[method] = clock[`_${method}`];
				else try {
					delete _global[method];
				} catch (ignore) {}
				if (clock.timersModuleMethods !== void 0) for (let j$1 = 0; j$1 < clock.timersModuleMethods.length; j$1++) {
					const entry = clock.timersModuleMethods[j$1];
					timersModule[entry.methodName] = entry.original;
				}
				if (clock.timersPromisesModuleMethods !== void 0) for (let j$1 = 0; j$1 < clock.timersPromisesModuleMethods.length; j$1++) {
					const entry = clock.timersPromisesModuleMethods[j$1];
					timersPromisesModule[entry.methodName] = entry.original;
				}
			}
			if (config$1.shouldAdvanceTime === true) _global.clearInterval(clock.attachedInterval);
			clock.methods = [];
			for (const [listener, signal] of clock.abortListenerMap.entries()) {
				signal.removeEventListener("abort", listener);
				clock.abortListenerMap.delete(listener);
			}
			if (!clock.timers) return [];
			return Object.keys(clock.timers).map(function mapper(key) {
				return clock.timers[key];
			});
		}
		/**
		* @param {object} target the target containing the method to replace
		* @param {string} method the keyname of the method on the target
		* @param {Clock} clock
		*/
		function hijackMethod(target, method, clock) {
			clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);
			clock[`_${method}`] = target[method];
			if (method === "Date") target[method] = clock[method];
			else if (method === "Intl") target[method] = clock[method];
			else if (method === "performance") {
				const originalPerfDescriptor = Object.getOwnPropertyDescriptor(target, method);
				if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
					Object.defineProperty(clock, `_${method}`, originalPerfDescriptor);
					const perfDescriptor = Object.getOwnPropertyDescriptor(clock, method);
					Object.defineProperty(target, method, perfDescriptor);
				} else target[method] = clock[method];
			} else {
				target[method] = function() {
					return clock[method].apply(clock, arguments);
				};
				Object.defineProperties(target[method], Object.getOwnPropertyDescriptors(clock[method]));
			}
			target[method].clock = clock;
		}
		/**
		* @param {Clock} clock
		* @param {number} advanceTimeDelta
		*/
		function doIntervalTick(clock, advanceTimeDelta) {
			clock.tick(advanceTimeDelta);
		}
		/**
		* @typedef {object} Timers
		* @property {setTimeout} setTimeout
		* @property {clearTimeout} clearTimeout
		* @property {setInterval} setInterval
		* @property {clearInterval} clearInterval
		* @property {Date} Date
		* @property {Intl} Intl
		* @property {SetImmediate=} setImmediate
		* @property {function(NodeImmediate): void=} clearImmediate
		* @property {function(number[]):number[]=} hrtime
		* @property {NextTick=} nextTick
		* @property {Performance=} performance
		* @property {RequestAnimationFrame=} requestAnimationFrame
		* @property {boolean=} queueMicrotask
		* @property {function(number): void=} cancelAnimationFrame
		* @property {RequestIdleCallback=} requestIdleCallback
		* @property {function(number): void=} cancelIdleCallback
		*/
		/** @type {Timers} */
		const timers = {
			setTimeout: _global.setTimeout,
			clearTimeout: _global.clearTimeout,
			setInterval: _global.setInterval,
			clearInterval: _global.clearInterval,
			Date: _global.Date
		};
		if (isPresent.setImmediate) timers.setImmediate = _global.setImmediate;
		if (isPresent.clearImmediate) timers.clearImmediate = _global.clearImmediate;
		if (isPresent.hrtime) timers.hrtime = _global.process.hrtime;
		if (isPresent.nextTick) timers.nextTick = _global.process.nextTick;
		if (isPresent.performance) timers.performance = _global.performance;
		if (isPresent.requestAnimationFrame) timers.requestAnimationFrame = _global.requestAnimationFrame;
		if (isPresent.queueMicrotask) timers.queueMicrotask = _global.queueMicrotask;
		if (isPresent.cancelAnimationFrame) timers.cancelAnimationFrame = _global.cancelAnimationFrame;
		if (isPresent.requestIdleCallback) timers.requestIdleCallback = _global.requestIdleCallback;
		if (isPresent.cancelIdleCallback) timers.cancelIdleCallback = _global.cancelIdleCallback;
		if (isPresent.Intl) timers.Intl = NativeIntl;
		const originalSetTimeout = _global.setImmediate || _global.setTimeout;
		/**
		* @param {Date|number} [start] the system time - non-integer values are floored
		* @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()
		* @returns {Clock}
		*/
		function createClock(start, loopLimit) {
			start = Math.floor(getEpoch(start));
			loopLimit = loopLimit || 1e3;
			let nanos = 0;
			const adjustedSystemTime = [0, 0];
			const clock = {
				now: start,
				Date: createDate(),
				loopLimit
			};
			clock.Date.clock = clock;
			function getTimeToNextFrame() {
				return 16 - (clock.now - start) % 16;
			}
			function hrtime(prev) {
				const millisSinceStart = clock.now - adjustedSystemTime[0] - start;
				const secsSinceStart = Math.floor(millisSinceStart / 1e3);
				const remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];
				if (Array.isArray(prev)) {
					if (prev[1] > 1e9) throw new TypeError("Number of nanoseconds can't exceed a billion");
					const oldSecs = prev[0];
					let nanoDiff = remainderInNanos - prev[1];
					let secDiff = secsSinceStart - oldSecs;
					if (nanoDiff < 0) {
						nanoDiff += 1e9;
						secDiff -= 1;
					}
					return [secDiff, nanoDiff];
				}
				return [secsSinceStart, remainderInNanos];
			}
			/**
			* A high resolution timestamp in milliseconds.
			* @typedef {number} DOMHighResTimeStamp
			*/
			/**
			* performance.now()
			* @returns {DOMHighResTimeStamp}
			*/
			function fakePerformanceNow() {
				const hrt = hrtime();
				return hrt[0] * 1e3 + hrt[1] / 1e6;
			}
			if (isPresent.hrtimeBigint) hrtime.bigint = function() {
				const parts = hrtime();
				return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]);
			};
			if (isPresent.Intl) {
				clock.Intl = createIntl();
				clock.Intl.clock = clock;
			}
			clock.requestIdleCallback = function requestIdleCallback(func, timeout) {
				let timeToNextIdlePeriod = 0;
				if (clock.countTimers() > 0) timeToNextIdlePeriod = 50;
				const result = addTimer(clock, {
					func,
					args: Array.prototype.slice.call(arguments, 2),
					delay: typeof timeout === "undefined" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),
					idleCallback: true
				});
				return Number(result);
			};
			clock.cancelIdleCallback = function cancelIdleCallback(timerId) {
				return clearTimer(clock, timerId, "IdleCallback");
			};
			clock.setTimeout = function setTimeout$1(func, timeout) {
				return addTimer(clock, {
					func,
					args: Array.prototype.slice.call(arguments, 2),
					delay: timeout
				});
			};
			if (typeof _global.Promise !== "undefined" && utilPromisify) clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {
				return new _global.Promise(function setTimeoutExecutor(resolve$4) {
					addTimer(clock, {
						func: resolve$4,
						args: [arg],
						delay: timeout
					});
				});
			};
			clock.clearTimeout = function clearTimeout$1(timerId) {
				return clearTimer(clock, timerId, "Timeout");
			};
			clock.nextTick = function nextTick(func) {
				return enqueueJob(clock, {
					func,
					args: Array.prototype.slice.call(arguments, 1),
					error: isNearInfiniteLimit ? /* @__PURE__ */ new Error() : null
				});
			};
			clock.queueMicrotask = function queueMicrotask(func) {
				return clock.nextTick(func);
			};
			clock.setInterval = function setInterval(func, timeout) {
				timeout = parseInt(timeout, 10);
				return addTimer(clock, {
					func,
					args: Array.prototype.slice.call(arguments, 2),
					delay: timeout,
					interval: timeout
				});
			};
			clock.clearInterval = function clearInterval(timerId) {
				return clearTimer(clock, timerId, "Interval");
			};
			if (isPresent.setImmediate) {
				clock.setImmediate = function setImmediate(func) {
					return addTimer(clock, {
						func,
						args: Array.prototype.slice.call(arguments, 1),
						immediate: true
					});
				};
				if (typeof _global.Promise !== "undefined" && utilPromisify) clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {
					return new _global.Promise(function setImmediateExecutor(resolve$4) {
						addTimer(clock, {
							func: resolve$4,
							args: [arg],
							immediate: true
						});
					});
				};
				clock.clearImmediate = function clearImmediate(timerId) {
					return clearTimer(clock, timerId, "Immediate");
				};
			}
			clock.countTimers = function countTimers() {
				return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;
			};
			clock.requestAnimationFrame = function requestAnimationFrame(func) {
				const result = addTimer(clock, {
					func,
					delay: getTimeToNextFrame(),
					get args() {
						return [fakePerformanceNow()];
					},
					animation: true
				});
				return Number(result);
			};
			clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {
				return clearTimer(clock, timerId, "AnimationFrame");
			};
			clock.runMicrotasks = function runMicrotasks() {
				runJobs(clock);
			};
			/**
			* @param {number|string} tickValue milliseconds or a string parseable by parseTime
			* @param {boolean} isAsync
			* @param {Function} resolve
			* @param {Function} reject
			* @returns {number|undefined} will return the new `now` value or nothing for async
			*/
			function doTick(tickValue, isAsync, resolve$4, reject) {
				const msFloat = typeof tickValue === "number" ? tickValue : parseTime(tickValue);
				const ms = Math.floor(msFloat);
				const remainder = nanoRemainder(msFloat);
				let nanosTotal = nanos + remainder;
				let tickTo = clock.now + ms;
				if (msFloat < 0) throw new TypeError("Negative ticks are not supported");
				if (nanosTotal >= 1e6) {
					tickTo += 1;
					nanosTotal -= 1e6;
				}
				nanos = nanosTotal;
				let tickFrom = clock.now;
				let previous = clock.now;
				let timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;
				clock.duringTick = true;
				oldNow = clock.now;
				runJobs(clock);
				if (oldNow !== clock.now) {
					tickFrom += clock.now - oldNow;
					tickTo += clock.now - oldNow;
				}
				function doTickInner() {
					timer = firstTimerInRange(clock, tickFrom, tickTo);
					while (timer && tickFrom <= tickTo) {
						if (clock.timers[timer.id]) {
							tickFrom = timer.callAt;
							clock.now = timer.callAt;
							oldNow = clock.now;
							try {
								runJobs(clock);
								callTimer(clock, timer);
							} catch (e) {
								firstException = firstException || e;
							}
							if (isAsync) {
								originalSetTimeout(nextPromiseTick);
								return;
							}
							compensationCheck();
						}
						postTimerCall();
					}
					oldNow = clock.now;
					runJobs(clock);
					if (oldNow !== clock.now) {
						tickFrom += clock.now - oldNow;
						tickTo += clock.now - oldNow;
					}
					clock.duringTick = false;
					timer = firstTimerInRange(clock, tickFrom, tickTo);
					if (timer) try {
						clock.tick(tickTo - clock.now);
					} catch (e) {
						firstException = firstException || e;
					}
					else {
						clock.now = tickTo;
						nanos = nanosTotal;
					}
					if (firstException) throw firstException;
					if (isAsync) resolve$4(clock.now);
					else return clock.now;
				}
				nextPromiseTick = isAsync && function() {
					try {
						compensationCheck();
						postTimerCall();
						doTickInner();
					} catch (e) {
						reject(e);
					}
				};
				compensationCheck = function() {
					if (oldNow !== clock.now) {
						tickFrom += clock.now - oldNow;
						tickTo += clock.now - oldNow;
						previous += clock.now - oldNow;
					}
				};
				postTimerCall = function() {
					timer = firstTimerInRange(clock, previous, tickTo);
					previous = tickFrom;
				};
				return doTickInner();
			}
			/**
			* @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
			* @returns {number} will return the new `now` value
			*/
			clock.tick = function tick(tickValue) {
				return doTick(tickValue, false);
			};
			if (typeof _global.Promise !== "undefined")
 /**
			* @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
			* @returns {Promise}
			*/
			clock.tickAsync = function tickAsync(tickValue) {
				return new _global.Promise(function(resolve$4, reject) {
					originalSetTimeout(function() {
						try {
							doTick(tickValue, true, resolve$4, reject);
						} catch (e) {
							reject(e);
						}
					});
				});
			};
			clock.next = function next() {
				runJobs(clock);
				const timer = firstTimer(clock);
				if (!timer) return clock.now;
				clock.duringTick = true;
				try {
					clock.now = timer.callAt;
					callTimer(clock, timer);
					runJobs(clock);
					return clock.now;
				} finally {
					clock.duringTick = false;
				}
			};
			if (typeof _global.Promise !== "undefined") clock.nextAsync = function nextAsync() {
				return new _global.Promise(function(resolve$4, reject) {
					originalSetTimeout(function() {
						try {
							const timer = firstTimer(clock);
							if (!timer) {
								resolve$4(clock.now);
								return;
							}
							let err;
							clock.duringTick = true;
							clock.now = timer.callAt;
							try {
								callTimer(clock, timer);
							} catch (e) {
								err = e;
							}
							clock.duringTick = false;
							originalSetTimeout(function() {
								if (err) reject(err);
								else resolve$4(clock.now);
							});
						} catch (e) {
							reject(e);
						}
					});
				});
			};
			clock.runAll = function runAll() {
				let numTimers, i;
				runJobs(clock);
				for (i = 0; i < clock.loopLimit; i++) {
					if (!clock.timers) {
						resetIsNearInfiniteLimit();
						return clock.now;
					}
					numTimers = Object.keys(clock.timers).length;
					if (numTimers === 0) {
						resetIsNearInfiniteLimit();
						return clock.now;
					}
					clock.next();
					checkIsNearInfiniteLimit(clock, i);
				}
				const excessJob = firstTimer(clock);
				throw getInfiniteLoopError(clock, excessJob);
			};
			clock.runToFrame = function runToFrame() {
				return clock.tick(getTimeToNextFrame());
			};
			if (typeof _global.Promise !== "undefined") clock.runAllAsync = function runAllAsync() {
				return new _global.Promise(function(resolve$4, reject) {
					let i = 0;
					/**
					*
					*/
					function doRun() {
						originalSetTimeout(function() {
							try {
								runJobs(clock);
								let numTimers;
								if (i < clock.loopLimit) {
									if (!clock.timers) {
										resetIsNearInfiniteLimit();
										resolve$4(clock.now);
										return;
									}
									numTimers = Object.keys(clock.timers).length;
									if (numTimers === 0) {
										resetIsNearInfiniteLimit();
										resolve$4(clock.now);
										return;
									}
									clock.next();
									i++;
									doRun();
									checkIsNearInfiniteLimit(clock, i);
									return;
								}
								const excessJob = firstTimer(clock);
								reject(getInfiniteLoopError(clock, excessJob));
							} catch (e) {
								reject(e);
							}
						});
					}
					doRun();
				});
			};
			clock.runToLast = function runToLast() {
				const timer = lastTimer(clock);
				if (!timer) {
					runJobs(clock);
					return clock.now;
				}
				return clock.tick(timer.callAt - clock.now);
			};
			if (typeof _global.Promise !== "undefined") clock.runToLastAsync = function runToLastAsync() {
				return new _global.Promise(function(resolve$4, reject) {
					originalSetTimeout(function() {
						try {
							const timer = lastTimer(clock);
							if (!timer) {
								runJobs(clock);
								resolve$4(clock.now);
							}
							resolve$4(clock.tickAsync(timer.callAt - clock.now));
						} catch (e) {
							reject(e);
						}
					});
				});
			};
			clock.reset = function reset() {
				nanos = 0;
				clock.timers = {};
				clock.jobs = [];
				clock.now = start;
			};
			clock.setSystemTime = function setSystemTime(systemTime) {
				const newNow = getEpoch(systemTime);
				const difference = newNow - clock.now;
				let id, timer;
				adjustedSystemTime[0] = adjustedSystemTime[0] + difference;
				adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;
				clock.now = newNow;
				nanos = 0;
				for (id in clock.timers) if (clock.timers.hasOwnProperty(id)) {
					timer = clock.timers[id];
					timer.createdAt += difference;
					timer.callAt += difference;
				}
			};
			/**
			* @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
			* @returns {number} will return the new `now` value
			*/
			clock.jump = function jump(tickValue) {
				const msFloat = typeof tickValue === "number" ? tickValue : parseTime(tickValue);
				const ms = Math.floor(msFloat);
				for (const timer of Object.values(clock.timers)) if (clock.now + ms > timer.callAt) timer.callAt = clock.now + ms;
				clock.tick(ms);
			};
			if (isPresent.performance) {
				clock.performance = Object.create(null);
				clock.performance.now = fakePerformanceNow;
			}
			if (isPresent.hrtime) clock.hrtime = hrtime;
			return clock;
		}
		/**
		* @param {Config=} [config] Optional config
		* @returns {Clock}
		*/
		function install(config$1) {
			if (arguments.length > 1 || config$1 instanceof Date || Array.isArray(config$1) || typeof config$1 === "number") throw new TypeError(`FakeTimers.install called with ${String(config$1)} install requires an object parameter`);
			if (_global.Date.isFake === true) throw new TypeError("Can't install fake timers twice on the same global object.");
			config$1 = typeof config$1 !== "undefined" ? config$1 : {};
			config$1.shouldAdvanceTime = config$1.shouldAdvanceTime || false;
			config$1.advanceTimeDelta = config$1.advanceTimeDelta || 20;
			config$1.shouldClearNativeTimers = config$1.shouldClearNativeTimers || false;
			if (config$1.target) throw new TypeError("config.target is no longer supported. Use `withGlobal(target)` instead.");
			/**
			* @param {string} timer/object the name of the thing that is not present
			* @param timer
			*/
			function handleMissingTimer(timer) {
				if (config$1.ignoreMissingTimers) return;
				throw new ReferenceError(`non-existent timers and/or objects cannot be faked: '${timer}'`);
			}
			let i, l$1;
			const clock = createClock(config$1.now, config$1.loopLimit);
			clock.shouldClearNativeTimers = config$1.shouldClearNativeTimers;
			clock.uninstall = function() {
				return uninstall(clock, config$1);
			};
			clock.abortListenerMap = /* @__PURE__ */ new Map();
			clock.methods = config$1.toFake || [];
			if (clock.methods.length === 0) clock.methods = Object.keys(timers);
			if (config$1.shouldAdvanceTime === true) {
				const intervalTick = doIntervalTick.bind(null, clock, config$1.advanceTimeDelta);
				clock.attachedInterval = _global.setInterval(intervalTick, config$1.advanceTimeDelta);
			}
			if (clock.methods.includes("performance")) {
				const proto = (() => {
					if (hasPerformanceConstructorPrototype) return _global.performance.constructor.prototype;
					if (hasPerformancePrototype) return _global.Performance.prototype;
				})();
				if (proto) {
					Object.getOwnPropertyNames(proto).forEach(function(name) {
						if (name !== "now") clock.performance[name] = name.indexOf("getEntries") === 0 ? NOOP_ARRAY : NOOP;
					});
					clock.performance.mark = (name) => new FakePerformanceEntry(name, "mark", 0, 0);
					clock.performance.measure = (name) => new FakePerformanceEntry(name, "measure", 0, 100);
					clock.performance.timeOrigin = getEpoch(config$1.now);
				} else if ((config$1.toFake || []).includes("performance")) return handleMissingTimer("performance");
			}
			if (_global === globalObject && timersModule) clock.timersModuleMethods = [];
			if (_global === globalObject && timersPromisesModule) clock.timersPromisesModuleMethods = [];
			for (i = 0, l$1 = clock.methods.length; i < l$1; i++) {
				const nameOfMethodToReplace = clock.methods[i];
				if (!isPresent[nameOfMethodToReplace]) {
					handleMissingTimer(nameOfMethodToReplace);
					continue;
				}
				if (nameOfMethodToReplace === "hrtime") {
					if (_global.process && typeof _global.process.hrtime === "function") hijackMethod(_global.process, nameOfMethodToReplace, clock);
				} else if (nameOfMethodToReplace === "nextTick") {
					if (_global.process && typeof _global.process.nextTick === "function") hijackMethod(_global.process, nameOfMethodToReplace, clock);
				} else hijackMethod(_global, nameOfMethodToReplace, clock);
				if (clock.timersModuleMethods !== void 0 && timersModule[nameOfMethodToReplace]) {
					const original = timersModule[nameOfMethodToReplace];
					clock.timersModuleMethods.push({
						methodName: nameOfMethodToReplace,
						original
					});
					timersModule[nameOfMethodToReplace] = _global[nameOfMethodToReplace];
				}
				if (clock.timersPromisesModuleMethods !== void 0) {
					if (nameOfMethodToReplace === "setTimeout") {
						clock.timersPromisesModuleMethods.push({
							methodName: "setTimeout",
							original: timersPromisesModule.setTimeout
						});
						timersPromisesModule.setTimeout = (delay, value, options = {}) => new Promise((resolve$4, reject) => {
							const abort = () => {
								options.signal.removeEventListener("abort", abort);
								clock.abortListenerMap.delete(abort);
								clock.clearTimeout(handle);
								reject(options.signal.reason);
							};
							const handle = clock.setTimeout(() => {
								if (options.signal) {
									options.signal.removeEventListener("abort", abort);
									clock.abortListenerMap.delete(abort);
								}
								resolve$4(value);
							}, delay);
							if (options.signal) if (options.signal.aborted) abort();
							else {
								options.signal.addEventListener("abort", abort);
								clock.abortListenerMap.set(abort, options.signal);
							}
						});
					} else if (nameOfMethodToReplace === "setImmediate") {
						clock.timersPromisesModuleMethods.push({
							methodName: "setImmediate",
							original: timersPromisesModule.setImmediate
						});
						timersPromisesModule.setImmediate = (value, options = {}) => new Promise((resolve$4, reject) => {
							const abort = () => {
								options.signal.removeEventListener("abort", abort);
								clock.abortListenerMap.delete(abort);
								clock.clearImmediate(handle);
								reject(options.signal.reason);
							};
							const handle = clock.setImmediate(() => {
								if (options.signal) {
									options.signal.removeEventListener("abort", abort);
									clock.abortListenerMap.delete(abort);
								}
								resolve$4(value);
							});
							if (options.signal) if (options.signal.aborted) abort();
							else {
								options.signal.addEventListener("abort", abort);
								clock.abortListenerMap.set(abort, options.signal);
							}
						});
					} else if (nameOfMethodToReplace === "setInterval") {
						clock.timersPromisesModuleMethods.push({
							methodName: "setInterval",
							original: timersPromisesModule.setInterval
						});
						timersPromisesModule.setInterval = (delay, value, options = {}) => ({ [Symbol.asyncIterator]: () => {
							const createResolvable = () => {
								let resolve$4, reject;
								const promise = new Promise((res, rej) => {
									resolve$4 = res;
									reject = rej;
								});
								promise.resolve = resolve$4;
								promise.reject = reject;
								return promise;
							};
							let done = false;
							let hasThrown = false;
							let returnCall;
							let nextAvailable = 0;
							const nextQueue = [];
							const handle = clock.setInterval(() => {
								if (nextQueue.length > 0) nextQueue.shift().resolve();
								else nextAvailable++;
							}, delay);
							const abort = () => {
								options.signal.removeEventListener("abort", abort);
								clock.abortListenerMap.delete(abort);
								clock.clearInterval(handle);
								done = true;
								for (const resolvable of nextQueue) resolvable.resolve();
							};
							if (options.signal) if (options.signal.aborted) done = true;
							else {
								options.signal.addEventListener("abort", abort);
								clock.abortListenerMap.set(abort, options.signal);
							}
							return {
								next: async () => {
									if (options.signal?.aborted && !hasThrown) {
										hasThrown = true;
										throw options.signal.reason;
									}
									if (done) return {
										done: true,
										value: void 0
									};
									if (nextAvailable > 0) {
										nextAvailable--;
										return {
											done: false,
											value
										};
									}
									const resolvable = createResolvable();
									nextQueue.push(resolvable);
									await resolvable;
									if (returnCall && nextQueue.length === 0) returnCall.resolve();
									if (options.signal?.aborted && !hasThrown) {
										hasThrown = true;
										throw options.signal.reason;
									}
									if (done) return {
										done: true,
										value: void 0
									};
									return {
										done: false,
										value
									};
								},
								return: async () => {
									if (done) return {
										done: true,
										value: void 0
									};
									if (nextQueue.length > 0) {
										returnCall = createResolvable();
										await returnCall;
									}
									clock.clearInterval(handle);
									done = true;
									if (options.signal) {
										options.signal.removeEventListener("abort", abort);
										clock.abortListenerMap.delete(abort);
									}
									return {
										done: true,
										value: void 0
									};
								}
							};
						} });
					}
				}
			}
			return clock;
		}
		return {
			timers,
			createClock,
			install,
			withGlobal
		};
	}
	/**
	* @typedef {object} FakeTimers
	* @property {Timers} timers
	* @property {createClock} createClock
	* @property {Function} install
	* @property {withGlobal} withGlobal
	*/
	/** @type {FakeTimers} */
	const defaultImplementation = withGlobal(globalObject);
	fakeTimersSrc.timers = defaultImplementation.timers;
	fakeTimersSrc.createClock = defaultImplementation.createClock;
	fakeTimersSrc.install = defaultImplementation.install;
	fakeTimersSrc.withGlobal = withGlobal;
	return fakeTimersSrc;
}
var fakeTimersSrcExports = requireFakeTimersSrc();
var FakeTimers = class {
	_global;
	_clock;
	_fakingTime;
	_fakingDate;
	_fakeTimers;
	_userConfig;
	_now = RealDate.now;
	constructor({ global: global$2, config: config$1 }) {
		this._userConfig = config$1;
		this._fakingDate = null;
		this._fakingTime = false;
		this._fakeTimers = fakeTimersSrcExports.withGlobal(global$2);
		this._global = global$2;
	}
	clearAllTimers() {
		if (this._fakingTime) this._clock.reset();
	}
	dispose() {
		this.useRealTimers();
	}
	runAllTimers() {
		if (this._checkFakeTimers()) this._clock.runAll();
	}
	async runAllTimersAsync() {
		if (this._checkFakeTimers()) await this._clock.runAllAsync();
	}
	runOnlyPendingTimers() {
		if (this._checkFakeTimers()) this._clock.runToLast();
	}
	async runOnlyPendingTimersAsync() {
		if (this._checkFakeTimers()) await this._clock.runToLastAsync();
	}
	advanceTimersToNextTimer(steps = 1) {
		if (this._checkFakeTimers()) for (let i = steps; i > 0; i--) {
			this._clock.next();
			this._clock.tick(0);
			if (this._clock.countTimers() === 0) break;
		}
	}
	async advanceTimersToNextTimerAsync(steps = 1) {
		if (this._checkFakeTimers()) for (let i = steps; i > 0; i--) {
			await this._clock.nextAsync();
			this._clock.tick(0);
			if (this._clock.countTimers() === 0) break;
		}
	}
	advanceTimersByTime(msToRun) {
		if (this._checkFakeTimers()) this._clock.tick(msToRun);
	}
	async advanceTimersByTimeAsync(msToRun) {
		if (this._checkFakeTimers()) await this._clock.tickAsync(msToRun);
	}
	advanceTimersToNextFrame() {
		if (this._checkFakeTimers()) this._clock.runToFrame();
	}
	runAllTicks() {
		if (this._checkFakeTimers()) this._clock.runMicrotasks();
	}
	useRealTimers() {
		if (this._fakingDate) {
			resetDate();
			this._fakingDate = null;
		}
		if (this._fakingTime) {
			this._clock.uninstall();
			this._fakingTime = false;
		}
	}
	useFakeTimers() {
		if (this._fakingDate) throw new Error("\"setSystemTime\" was called already and date was mocked. Reset timers using `vi.useRealTimers()` if you want to use fake timers again.");
		if (!this._fakingTime) {
			const toFake = Object.keys(this._fakeTimers.timers).filter((timer) => timer !== "nextTick" && timer !== "queueMicrotask");
			if (this._userConfig?.toFake?.includes("nextTick") && isChildProcess()) throw new Error("process.nextTick cannot be mocked inside child_process");
			this._clock = this._fakeTimers.install({
				now: Date.now(),
				...this._userConfig,
				toFake: this._userConfig?.toFake || toFake,
				ignoreMissingTimers: true
			});
			this._fakingTime = true;
		}
	}
	reset() {
		if (this._checkFakeTimers()) {
			const { now: now$4 } = this._clock;
			this._clock.reset();
			this._clock.setSystemTime(now$4);
		}
	}
	setSystemTime(now$4) {
		const date = typeof now$4 === "undefined" || now$4 instanceof Date ? now$4 : new Date(now$4);
		if (this._fakingTime) this._clock.setSystemTime(date);
		else {
			this._fakingDate = date ?? new Date(this.getRealSystemTime());
			mockDate(this._fakingDate);
		}
	}
	getMockedSystemTime() {
		return this._fakingTime ? new Date(this._clock.now) : this._fakingDate;
	}
	getRealSystemTime() {
		return this._now();
	}
	getTimerCount() {
		if (this._checkFakeTimers()) return this._clock.countTimers();
		return 0;
	}
	configure(config$1) {
		this._userConfig = config$1;
	}
	isFakeTimers() {
		return this._fakingTime;
	}
	_checkFakeTimers() {
		if (!this._fakingTime) throw new Error("Timers are not mocked. Try calling \"vi.useFakeTimers()\" first.");
		return this._fakingTime;
	}
};
function copyStackTrace(target, source) {
	if (source.stack !== void 0) target.stack = source.stack.replace(source.message, target.message);
	return target;
}
function waitFor(callback, options = {}) {
	const { setTimeout: setTimeout$1, setInterval, clearTimeout: clearTimeout$1, clearInterval } = getSafeTimers();
	const { interval = 50, timeout = 1e3 } = typeof options === "number" ? { timeout: options } : options;
	const STACK_TRACE_ERROR = /* @__PURE__ */ new Error("STACK_TRACE_ERROR");
	return new Promise((resolve$4, reject) => {
		let lastError;
		let promiseStatus = "idle";
		let timeoutId;
		let intervalId;
		const onResolve = (result) => {
			if (timeoutId) clearTimeout$1(timeoutId);
			if (intervalId) clearInterval(intervalId);
			resolve$4(result);
		};
		const handleTimeout = () => {
			if (intervalId) clearInterval(intervalId);
			let error = lastError;
			if (!error) error = copyStackTrace(/* @__PURE__ */ new Error("Timed out in waitFor!"), STACK_TRACE_ERROR);
			reject(error);
		};
		const checkCallback = () => {
			if (vi.isFakeTimers()) vi.advanceTimersByTime(interval);
			if (promiseStatus === "pending") return;
			try {
				const result = callback();
				if (result !== null && typeof result === "object" && typeof result.then === "function") {
					const thenable = result;
					promiseStatus = "pending";
					thenable.then((resolvedValue) => {
						promiseStatus = "resolved";
						onResolve(resolvedValue);
					}, (rejectedValue) => {
						promiseStatus = "rejected";
						lastError = rejectedValue;
					});
				} else {
					onResolve(result);
					return true;
				}
			} catch (error) {
				lastError = error;
			}
		};
		if (checkCallback() === true) return;
		timeoutId = setTimeout$1(handleTimeout, timeout);
		intervalId = setInterval(checkCallback, interval);
	});
}
function waitUntil(callback, options = {}) {
	const { setTimeout: setTimeout$1, setInterval, clearTimeout: clearTimeout$1, clearInterval } = getSafeTimers();
	const { interval = 50, timeout = 1e3 } = typeof options === "number" ? { timeout: options } : options;
	const STACK_TRACE_ERROR = /* @__PURE__ */ new Error("STACK_TRACE_ERROR");
	return new Promise((resolve$4, reject) => {
		let promiseStatus = "idle";
		let timeoutId;
		let intervalId;
		const onReject = (error) => {
			if (intervalId) clearInterval(intervalId);
			if (!error) error = copyStackTrace(/* @__PURE__ */ new Error("Timed out in waitUntil!"), STACK_TRACE_ERROR);
			reject(error);
		};
		const onResolve = (result) => {
			if (!result) return;
			if (timeoutId) clearTimeout$1(timeoutId);
			if (intervalId) clearInterval(intervalId);
			resolve$4(result);
			return true;
		};
		const checkCallback = () => {
			if (vi.isFakeTimers()) vi.advanceTimersByTime(interval);
			if (promiseStatus === "pending") return;
			try {
				const result = callback();
				if (result !== null && typeof result === "object" && typeof result.then === "function") {
					const thenable = result;
					promiseStatus = "pending";
					thenable.then((resolvedValue) => {
						promiseStatus = "resolved";
						onResolve(resolvedValue);
					}, (rejectedValue) => {
						promiseStatus = "rejected";
						onReject(rejectedValue);
					});
				} else return onResolve(result);
			} catch (error) {
				onReject(error);
			}
		};
		if (checkCallback() === true) return;
		timeoutId = setTimeout$1(onReject, timeout);
		intervalId = setInterval(checkCallback, interval);
	});
}
function createVitest() {
	let _config = null;
	const workerState = getWorkerState();
	let _timers;
	const timers = () => _timers ||= new FakeTimers({
		global: globalThis,
		config: workerState.config.fakeTimers
	});
	const _stubsGlobal = /* @__PURE__ */ new Map();
	const _stubsEnv = /* @__PURE__ */ new Map();
	const _envBooleans = [
		"PROD",
		"DEV",
		"SSR"
	];
	const utils = {
		useFakeTimers(config$1) {
			if (isChildProcess()) {
				if (config$1?.toFake?.includes("nextTick") || workerState.config?.fakeTimers?.toFake?.includes("nextTick")) throw new Error("vi.useFakeTimers({ toFake: [\"nextTick\"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.");
			}
			if (config$1) timers().configure({
				...workerState.config.fakeTimers,
				...config$1
			});
			else timers().configure(workerState.config.fakeTimers);
			timers().useFakeTimers();
			return utils;
		},
		isFakeTimers() {
			return timers().isFakeTimers();
		},
		useRealTimers() {
			timers().useRealTimers();
			return utils;
		},
		runOnlyPendingTimers() {
			timers().runOnlyPendingTimers();
			return utils;
		},
		async runOnlyPendingTimersAsync() {
			await timers().runOnlyPendingTimersAsync();
			return utils;
		},
		runAllTimers() {
			timers().runAllTimers();
			return utils;
		},
		async runAllTimersAsync() {
			await timers().runAllTimersAsync();
			return utils;
		},
		runAllTicks() {
			timers().runAllTicks();
			return utils;
		},
		advanceTimersByTime(ms) {
			timers().advanceTimersByTime(ms);
			return utils;
		},
		async advanceTimersByTimeAsync(ms) {
			await timers().advanceTimersByTimeAsync(ms);
			return utils;
		},
		advanceTimersToNextTimer() {
			timers().advanceTimersToNextTimer();
			return utils;
		},
		async advanceTimersToNextTimerAsync() {
			await timers().advanceTimersToNextTimerAsync();
			return utils;
		},
		advanceTimersToNextFrame() {
			timers().advanceTimersToNextFrame();
			return utils;
		},
		getTimerCount() {
			return timers().getTimerCount();
		},
		setSystemTime(time) {
			timers().setSystemTime(time);
			return utils;
		},
		getMockedSystemTime() {
			return timers().getMockedSystemTime();
		},
		getRealSystemTime() {
			return timers().getRealSystemTime();
		},
		clearAllTimers() {
			timers().clearAllTimers();
			return utils;
		},
		spyOn,
		fn,
		waitFor,
		waitUntil,
		hoisted(factory) {
			assertTypes(factory, "\"vi.hoisted\" factory", ["function"]);
			return factory();
		},
		mock(path, factory) {
			if (typeof path !== "string") throw new TypeError(`vi.mock() expects a string path, but received a ${typeof path}`);
			const importer = getImporter("mock");
			_mocker().queueMock(path, importer, typeof factory === "function" ? () => factory(() => _mocker().importActual(path, importer, _mocker().getMockContext().callstack)) : factory);
		},
		unmock(path) {
			if (typeof path !== "string") throw new TypeError(`vi.unmock() expects a string path, but received a ${typeof path}`);
			_mocker().queueUnmock(path, getImporter("unmock"));
		},
		doMock(path, factory) {
			if (typeof path !== "string") throw new TypeError(`vi.doMock() expects a string path, but received a ${typeof path}`);
			const importer = getImporter("doMock");
			_mocker().queueMock(path, importer, typeof factory === "function" ? () => factory(() => _mocker().importActual(path, importer, _mocker().getMockContext().callstack)) : factory);
		},
		doUnmock(path) {
			if (typeof path !== "string") throw new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof path}`);
			_mocker().queueUnmock(path, getImporter("doUnmock"));
		},
		async importActual(path) {
			return _mocker().importActual(path, getImporter("importActual"), _mocker().getMockContext().callstack);
		},
		async importMock(path) {
			return _mocker().importMock(path, getImporter("importMock"));
		},
		mockObject(value) {
			return _mocker().mockObject({ value }).value;
		},
		mocked(item, _options = {}) {
			return item;
		},
		isMockFunction(fn$1) {
			return isMockFunction(fn$1);
		},
		clearAllMocks() {
			[...mocks].reverse().forEach((spy) => spy.mockClear());
			return utils;
		},
		resetAllMocks() {
			[...mocks].reverse().forEach((spy) => spy.mockReset());
			return utils;
		},
		restoreAllMocks() {
			[...mocks].reverse().forEach((spy) => spy.mockRestore());
			return utils;
		},
		stubGlobal(name, value) {
			if (!_stubsGlobal.has(name)) _stubsGlobal.set(name, Object.getOwnPropertyDescriptor(globalThis, name));
			Object.defineProperty(globalThis, name, {
				value,
				writable: true,
				configurable: true,
				enumerable: true
			});
			return utils;
		},
		stubEnv(name, value) {
			if (!_stubsEnv.has(name)) _stubsEnv.set(name, process.env[name]);
			if (_envBooleans.includes(name)) process.env[name] = value ? "1" : "";
			else if (value === void 0) delete process.env[name];
			else process.env[name] = String(value);
			return utils;
		},
		unstubAllGlobals() {
			_stubsGlobal.forEach((original, name) => {
				if (!original) Reflect.deleteProperty(globalThis, name);
				else Object.defineProperty(globalThis, name, original);
			});
			_stubsGlobal.clear();
			return utils;
		},
		unstubAllEnvs() {
			_stubsEnv.forEach((original, name) => {
				if (original === void 0) delete process.env[name];
				else process.env[name] = original;
			});
			_stubsEnv.clear();
			return utils;
		},
		resetModules() {
			resetModules(workerState.moduleCache);
			return utils;
		},
		async dynamicImportSettled() {
			return waitForImportsToResolve();
		},
		setConfig(config$1) {
			if (!_config) _config = { ...workerState.config };
			Object.assign(workerState.config, config$1);
		},
		resetConfig() {
			if (_config) Object.assign(workerState.config, _config);
		}
	};
	return utils;
}
const vitest = createVitest();
const vi = vitest;
function _mocker() {
	return typeof __vitest_mocker__ !== "undefined" ? __vitest_mocker__ : new Proxy({}, { get(_, name) {
		throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(name)}() is forbidden.`);
	} });
}
function getImporter(name) {
	const stackArray = createSimpleStackTrace({ stackTraceLimit: 5 }).split("\n");
	const importerStackIndex = stackArray.findIndex((stack) => {
		return stack.includes(` at Object.${name}`) || stack.includes(`${name}@`);
	});
	return parseSingleStack(stackArray[importerStackIndex + 1])?.file || "";
}

//#endregion
export { afterEach, beforeEach, describe, globalExpect, it, vi };
//# sourceMappingURL=vi.bdSIJ99Y-CjNqA1ej.js.map